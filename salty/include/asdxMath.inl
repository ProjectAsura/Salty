//----------------------------------------------------------------------------
// File : asdxMath.inl
// Desc : Asura Math Module.
// Copyright(c) Project Asura. All right reserved.
//----------------------------------------------------------------------------

#ifndef __ASDX_MATH_INL__
#define __ASDX_MATH_INL__

namespace asdx {


//////////////////////////////////////////////////////////////////////////////
// Functions
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>度をラジアンに変換します.</summary>
///<param name="degree">角度(度).</param>
///<return>度をラジアンに変換した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     DegToRad( f32 degree )
{ return degree * ( F_PI / 180.0f ); }

//----------------------------------------------------------------------------
///<summary>ラジアンを度に変換します.</summary>
///<param name="radian">角度(ラジアン).</param>
///<return>ラジアンを度に変換した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     RadToDeg( f32 radian )
{ return radian * ( 180.0f / F_PI ); }

//----------------------------------------------------------------------------
///<summary>ラジアンを1円周を65536とする角度に変換します.</summary>
///<param name="radian">角度(ラジアン)</param>
///<return>ラジアンを1円周を65536とする角度に変換した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     RadToIdx( f32 radian )
{ return static_cast<u16>( radian * ( 32768 / F_PI ) ); }

//----------------------------------------------------------------------------
///<summary>度を1円周を65536とする角度に変換します.</summary>
///<param name="degree">角度</param>
///<return>度を1円周を65536とする角度に変換した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     DegToIdx( f32 degree )
{ return static_cast<u16>( degree * ( 32768 / 180.0f ) ); }

//----------------------------------------------------------------------------
///<summary>値がゼロであるかどうか判定します.</summary>
///<param name="value">判定する値</param>
///<return>値がゼロであるとみなせる場合にtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    IsZero( f32 value )
{ return ( -F32_EPSILON <= value ) && ( value <= F32_EPSILON ); }

//----------------------------------------------------------------------------
///<summary>値がゼロであるかどうか判定します.</summary>
///<param name="value">判定する値.</param>
///<return>値がゼロであるとみなせる場合にtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    IsZero( f64 value )
{ return ( -F64_EPSILON <= value ) && ( value <= F64_EPSILON ); }

//----------------------------------------------------------------------------
///<summary>値が等価であるか判定します.</summary>
///<param name="a">判定する値.</param>
///<param name="b">判定する値.</param>
///<return>値が等価であるとみなせる場合にtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    IsEqual( f32 a, f32 b )
{ return ( ( a - F32_EPSILON ) <= b ) && ( b <= ( a + F32_EPSILON ) ); }

//----------------------------------------------------------------------------
///<summary>値が等価であるか判定します.</summary>
///<param name="a">判定する値</param>
///<param name="b">判定する値</param>
///<return>値が等価であるとみなせる場合にtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    IsEqual( f64 a, f64 b )
{ return ( ( a - F64_EPSILON ) <= b ) && ( b <= ( a + F64_EPSILON ) ); }

//----------------------------------------------------------------------------
///<summary>非数であるか判定します.</summary>
///<param name="value">判定する値.</param>
///<return>非数であった場合にtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    IsNan( f32 value )
{ return ( value != value ); }

//----------------------------------------------------------------------------
///<summary>無限大であるか判定します.</summary>
///<param name="value">判定する値</param>
///<return>無限大であった場合にtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    IsInf( f32 value )
{
    u32 f = *reinterpret_cast< u32* >( &value );
    if ( ( ( f & 0x7e000000 ) == 0x7e000000 ) && ( value == value ) )
    { return true; }
    return false;
}

//----------------------------------------------------------------------------
///<summary>階乗を計算します.</summary>
///<param name="number">階乗を計算する値.</param>
///<return>指定された数値の階乗計算の結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u32     Fact( u32 number )
{
    u32 result = 1;
    for( u32 i=1; i<=number; ++i )
    { result *= i; }
    return result;
}

//----------------------------------------------------------------------------
///<summary>2重階乗を計算します.</summary>
///<param name="number">2重階乗を計算する値.</param>
///<return>指定された数値の2重階乗計算の結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u32     DblFact( u32 number )
{
    u32 result = 1;
    u32 start = ( ( number % 2 ) == 0 ) ?  2 : 1;
    for( u32 i=start; i<=number; i+=2 )
    { result *= i; }
    return result;
}

///---------------------------------------------------------------------------
///<summary>順列を計算します.</summary>
///<param name="n">総数</param>
///<param name="r">選択数</param>
///<return>n個のものからr個とった順列を返却します.</return>
///---------------------------------------------------------------------------
ASDX_INLINE
u32     Perm( u32 n, u32 r )
{
    assert( n >= r );
    return Fact( n ) / Fact( n - r );
}

///---------------------------------------------------------------------------
///<summary>組合せを計算します.</summary>
///<param name="n">総数</param>
///<param name="r">選択数</param>
///<return>n個のものからr個とった組合せを返却します.</return>
///---------------------------------------------------------------------------
ASDX_INLINE
u32     Comb( u32 n, u32 r )
{
    assert( n >= r );
    return Fact( n ) / ( Fact( n - r ) * Fact( r ) );
}

//----------------------------------------------------------------------------
///<summary>f32型の値をビット列を変更することなくu32型に変更します.</summary>
///<param name="value">u32型にする値.</param>
///<return>valueと等しいビット列表現を持つu32型の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u32     F32AsU32( f32 value )
{ return *reinterpret_cast< u32* >( &value ); }

//----------------------------------------------------------------------------
///<summary>u32型の値をビット列を変更することなくf32型に変更します.</summary>
///<param name="value">f32型にする値.</param>
///<return>valueと等しいビット列表現を持つf32型の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     U32AsF32( u32 value )
{ return *reinterpret_cast< f32* >( &value ); }

//----------------------------------------------------------------------------
///<summary>f32型からu16型に変換します.</summary>
///<param name="value">u16型に変換する値.</param>
///<return>valueと同じ値を持ったu16型の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     F32ToU16( f32 value )
{ return u16( value ); }

//----------------------------------------------------------------------------
///<summary>u16型からf32型に変換します.</summary>
///<param name="value">f32型に変換する値.</param>
///<return>valueと同じ値を持ったf32型の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     U16ToF32( u16 value )
{ return f32( value ); }

//----------------------------------------------------------------------------
///<summary>f32型からs16型に変換します.</summary>
///<param name="value">s16型に変換する値.</param>
///<return>valueと同じ値を持ったs16型の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
s16     F32ToS16( f32 value )
{ return s16( value ); }

//----------------------------------------------------------------------------
///<summary>s16型からf32型に変換します.</summary>
///<param name="value">f32型に変換する値.</param>
///<return>valueと同じ値を持ったf32型の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     S16ToF32( s16 value )
{ return f32( value ); }

//----------------------------------------------------------------------------
///<summary>f32型からf16型に変換します.</summary>
///<param name="value">f16型に変換する値</param>
///<return>半精度浮動小数表現に変換した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE 
f16 F32ToF16( f32 value )
{
    f16 result;

    // ビット列を崩さないままu32型に変換.
    u32 bit = *reinterpret_cast<u32*>( &value );

    // f32表現の符号bitを取り出し.
    u32 sign   = ( bit & 0x80000000U) >> 16U;

    // 符号部を削ぎ落す.
    bit     = bit & 0x7FFFFFFFU;

    // f16として表現する際に値がデカ過ぎる場合は，無限大にクランプ.
    if ( bit > 0x47FFEFFFU)
    { result = 0x7FFFU; }
    else
    {
        // 正規化されたf16として表現するために小さすぎる値は正規化されていない値に変換.
        if ( bit < 0x38800000U)
        {
            u32 shift = 113U - ( bit >> 23U);
            bit    = (0x800000U | ( bit & 0x7FFFFFU)) >> shift;
        }
        else
        {
            // 正規化されたf16として表現するために指数部に再度バイアスをかける
            bit += 0xC8000000U;
        }

        // f16型表現にする.
        result = (( bit + 0x0FFFU + (( bit >> 13U) & 1U)) >> 13U) & 0x7FFFU; 
    }

    // 符号部を付け足して返却.
    return static_cast<f16>( result | sign );
}

//----------------------------------------------------------------------------
///<summary></summary>
//----------------------------------------------------------------------------
ASDX_INLINE 
f32 F16ToF32( f16 value )
{
    u32 exponent;
    u32 result;

    // 仮数
    u32 mantissa = static_cast<u32>( value & 0x03FF );

    // 正規化済みの場合.
    if ( ( value & 0x7C00 ) != 0 )
    {
        // 指数部を計算.
        exponent = static_cast<u32>( ( value >> 10 ) & 0x1F );
    }
    // 正規化されていない場合.
    else if ( mantissa != 0 )
    {
        // 結果となるf32で値を正規化する.
        exponent = 1;

        do {
            exponent--;
            mantissa <<= 1;
        } while ( ( mantissa & 0x0400 ) == 0);

        mantissa &= 0x03FF;
    }
    // 値がゼロの場合.
    else
    {
        // 指数部を計算.
        exponent = (u32)-112;
    }

    result = ( ( value & 0x8000 ) << 16) | // 符号部.
             ( ( exponent + 112 ) << 23) | // 指数部.
             ( mantissa << 13 );           // 仮数部.

    return *reinterpret_cast<f32*>( &result );
}

//----------------------------------------------------------------------------
///<summary>正弦の値を求めます.</summary>
///<param name="rad">角度(ラジアン).</param>
///<return>正弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SinRad( const f32 rad )
{ return SinIdx( ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>正弦の値を求めます.</summary>
///<param name="deg">角度(度).</param>
///<return>正弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SinDeg( const f32 deg )
{ return SinIdx( ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>余弦の値を求めます.</summary>
///<param name="rad">角度(ラジアン).</param>
///<return>余弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CosRad( const f32 rad )
{ return CosIdx( ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>余弦の値を求めます.</summary>
///<param name="deg">角度(度).</param>
///<return>余弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CosDeg( const f32 deg )
{ return CosIdx( ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>正接の値を求めます.</summary>
///<param name="rad">角度(ラジアン).</param>
///<return>正接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     TanRad( const f32 rad )
{ return TanIdx( ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>正接の値を求めます.</summary>
///<param name="deg">角度(度).</param>
///<return>正接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     TanDeg( const f32 deg )
{ return TanIdx( ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>余割の値を求めます.</summary>
///<param name="rad">角度(ラジアン).</param>
///<return>余割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CscRad( const f32 rad )
{ return 1.0f / SinIdx( ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>余割の値を求めます.</summary>
///<param name="deg">角度(度).</param>
///<return>余割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CscDeg( const f32 deg )
{ return 1.0f / SinIdx( ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>余割の値を求めます.</summary>
///<param name="rad">角度(1周を65536とする角度).</param>
///<return>余割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CscIdx( const u16 idx )
{ return 1.0f / SinIdx( idx ); }

//----------------------------------------------------------------------------
///<summary>正割の値を求めます.</summary>
///<param name="rad">角度(ラジアン).</param>
///<return>正割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SecRad( const f32 rad )
{ return 1.0f / CosIdx( ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>正割の値を求めます.</summary>
///<param name="deg">角度(度).</param>
///<return>正割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SecDeg( const f32 deg )
{ return 1.0f / CosIdx( ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>正割の値を求めます.</summary>
///<param name="idx">角度(1周を65536とする角度)</param>
///<return>正割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SecIdx( const u16 idx )
{ return 1.0f / CosIdx( idx ); }

//----------------------------------------------------------------------------
///<summary>余接の値を求めます.</summary>
///<param name="rad">角度(ラジアン).</param>
///<return>余接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CotRad( const f32 rad )
{ return 1.0f / TanIdx( ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>余接の値を求めます.</summary>
///<param name="deg">角度(度).</param>
///<return>余接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CotDeg( const f32 deg )
{ return 1.0f / TanIdx( ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>余接の値を求めます.</summary>
///<param name="idx">角度(1周を65536とする角度).</param>
///<return>余接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CotIdx( const u16 idx )
{ return 1.0f / TanIdx( idx ); }

//----------------------------------------------------------------------------
///<summary>正弦と余弦の値を求めます</summary>
///<param name="pSin">正弦の値の格納先ポインタ</param>
///<param name="pCos">余弦の値の格納先ポインタ</param>
///<param name="rad">角度(ラジアン).</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    SinCosRad( f32* pSin, f32* pCos, const f32 rad )
{ return SinCosIdx( pSin, pCos, ASDX_RAD_TO_IDX( rad ) ); }

//----------------------------------------------------------------------------
///<summary>正弦と余弦の値を求めます.</summary>
///<param name="pSin">正弦の値の格納先ポインタ</param>
///<param name="pCos">余弦の値の格納先ポインタ</param>
///<param name="deg">角度(度)</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    SinCosDeg( f32* pSin, f32* pCos, const f32 deg )
{ return SinCosIdx( pSin, pCos, ASDX_DEG_TO_IDX( deg ) ); }

//----------------------------------------------------------------------------
///<summary>双曲線正弦の値を求めます.</summary>
///<param name="x">角度(ラジアン).</param>
///<return>双曲線正弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SinhRad( const f32 x )
{ return ( expf( x ) - expf( -x ) ) * 0.5f; }

//----------------------------------------------------------------------------
///<summary>双曲線正弦の値を求めます.</summary>
///<param name="x">角度(度).</param>
///<return>双曲線正弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SinhDeg( const f32 x )
{
    register f32 X = ASDX_DEG_TO_RAD( x );
    return ( expf( X ) - expf( -X ) ) * 0.5f;
}

//----------------------------------------------------------------------------
///<summary>双曲線正弦の値を求めます.</summary>
///<param name="x">角度(インデックス角).</param>
///<return>双曲線正弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SinhIdx( const u16 x )
{
    register f32 X = ASDX_IDX_TO_RAD( x );
    return ( expf( X ) - expf( -X ) ) * 0.5f;
}

//----------------------------------------------------------------------------
///<summary>双曲線余弦の値を求めます.</summary>
///<param name="x">角度(ラジアン).</param>
///<return>双曲線余弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CoshRad( const f32 x )
{ return ( expf( x ) + expf( -x ) ) * 0.5f; }

//----------------------------------------------------------------------------
///<summary>双曲線余弦の値を求めます.</summary>
///<param name="x">角度(度).</param>
///<return>双曲線余弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CoshDeg( const f32 x )
{
    register f32 X = ASDX_DEG_TO_RAD( x );
    return ( expf( X ) + expf( -X ) ) * 0.5f;
}

//----------------------------------------------------------------------------
///<summary>双曲線余弦の値を求めます.</summary>
///<param name="x">角度(インデックス角).</param>
///<return>双曲線余弦の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CoshIdx( const u16 x )
{
    register f32 X = ASDX_IDX_TO_RAD( x );
    return ( expf( X ) + expf( -X ) ) * 0.5f;
}

//----------------------------------------------------------------------------
///<summary>双曲線正接の値を求めます.</summary>
///<param name="x">角度(ラジアン).</param>
///<return>双曲線正接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     TanhRad( const f32 x )
{
    register f32 ex = expf( x );
    register f32 ey = expf( -x );

    return ( ex - ey ) / ( ex + ey );
}

//----------------------------------------------------------------------------
///<summary>双曲線正接の値を求めます.</summary>
///<param name="x">角度(度).</param>
///<return>双曲線正接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     TanhDeg( const f32 x )
{
    register f32 X = ASDX_DEG_TO_RAD( x );
    register f32 ex = expf( X );
    register f32 ey = expf( -X );

    return ( ex - ey ) / ( ex + ey );
}

//----------------------------------------------------------------------------
///<summary>双曲線正接の値を求めます.</summary>
///<param name="x">角度(インデックス角).</param>
///<return>双曲線正接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     TanhIdx( const u16 x )
{
    register f32 X = ASDX_IDX_TO_RAD( x );
    register f32 ex = expf( X );
    register f32 ey = expf( -X );

    return ( ex - ey ) / ( ex + ey );
}

//----------------------------------------------------------------------------
///<summary>双曲線余割の値を求めます.</summary>
///<param name="x">角度(ラジアン).</param>
///<return>双曲線余割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CschRad( const f32 x )
{ return 2.0f / ( expf( x ) - expf( -x ) ); }

//----------------------------------------------------------------------------
///<summary>双曲線余割の値を求めます.</summary>
///<param name="x">角度(度).</param>
///<return>双曲線余割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CschDeg( const f32 x )
{
    register f32 X = ASDX_DEG_TO_RAD( x );
    return 2.0f / ( expf( X ) - expf( -X ) );
}

//----------------------------------------------------------------------------
///<summary>双曲線余割の値を求めます.</summary>
///<param name="x">角度(インデックス角).</param>
///<return>双曲線余割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CschIdx( const u16 x )
{
    register f32 X = ASDX_IDX_TO_RAD( x );
    return 2.0f / ( expf( X ) - expf( -X ) );
}

//----------------------------------------------------------------------------
///<summary>双曲線正割の値を求めます.</summary>
///<param name="x">角度(ラジアン).</param>
///<return>双曲線正割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SechRad( const f32 x )
{ return 2.0f / ( expf( x ) + expf( -x ) ); }

//----------------------------------------------------------------------------
///<summary>双曲線正割の値を求めます.</summary>
///<param name="x">角度(度).</param>
///<return>双曲線正割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SechDeg( const f32 x )
{
    register f32 X = ASDX_DEG_TO_RAD( x );
    return 2.0f / ( expf( X ) + expf( -X ) );
}

//----------------------------------------------------------------------------
///<summary>双曲線正割の値を求めます.</summary>
///<param name="x">角度(インデックス角).</param>
///<return>双曲線正割の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     SechIdx( const u16 x )
{
    register f32 X = ASDX_IDX_TO_RAD( x );
    return  2.0f / ( expf( X ) + expf( -X ) );
}

//----------------------------------------------------------------------------
///<summary>双曲線余接の値を求めます.</summary>
///<param name="x">角度(ラジアン).</param>
///<return>双曲線余接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CothRad( const f32 x )
{
    register f32 ex = expf( x );
    register f32 ey = expf( -x );

    return ( ex + ey ) / ( ex - ey );
}

//----------------------------------------------------------------------------
///<summary>双曲線余接の値を求めます.</summary>
///<param name="x">角度(度).</param>
///<return>双曲線余接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CothDeg( const f32 x )
{
    register f32 X = ASDX_DEG_TO_RAD( x );
    register f32 ex = expf( X );
    register f32 ey = expf( -X );

    return ( ex + ey ) / ( ex - ey );
}

//----------------------------------------------------------------------------
///<summary>双曲線余接の値を求めます.</summary>
///<param name="x">角度(インデックス角).</param>
///<return>双曲線余接の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     CothIdx( const u16 x )
{
    register f32 X = ASDX_IDX_TO_RAD( x );
    register f32 ex = expf( X );
    register f32 ey = expf( -X );

    return ( ex + ey ) / ( ex - ey );
}

//----------------------------------------------------------------------------
///<summary>逆正弦を求めます.</summary>
///<param name="x">逆正弦を求める値.</param>
///<return>逆正弦の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ASinRad( const f32 x )
{ return asinf( x ); }

//----------------------------------------------------------------------------
///<summary>逆正弦を求めます.</summary>
///<param name="x">逆正弦を求める値.</param>
///<return>逆正弦の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ASinDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( asinf( x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正弦を求めます.</summary>
///<param name="x">逆正弦を求める値.</param>
///<return>逆正弦の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ASinIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( asinf( x ) ); }

//----------------------------------------------------------------------------
///<summary>逆余弦を求めます.</summary>
///<param name="x">逆余弦を求める値.</param>
///<return>逆余弦の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACosRad( const f32 x )
{ return acosf( x ); }

//----------------------------------------------------------------------------
///<summary>逆余弦を求めます.</summary>
///<param name="x">逆余弦を求める値.</param>
///<return>逆余弦の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACosDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( acosf( x ) ); }

//----------------------------------------------------------------------------
///<summary>逆余弦を求めます.</summary>
///<param name="x">逆余弦を求める値.</param>
///<return>逆余弦の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ACosIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( acosf( x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正接を求めます.</summary>
///<param name="x">逆正接を求める値.</param>
///<return>逆正接の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ATanRad( const f32 x )
{ return atanf( x ); }

//----------------------------------------------------------------------------
///<summary>逆正接を求めます.</summary>
///<param name="x">逆正接を求める値.</param>
///<return>逆正接の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ATanDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( atanf( x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正接を求めます.</summary>
///<param name="x">逆正接を求める値.</param>
///<return>逆正接の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ATanIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( atanf( x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正接を求めます.</summary>
///<param name="y">正接の値の分子</param>
///<param name="x">正接の値の分母</param>
///<return>y/xの逆正接の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ATan2Rad( const f32 y, const f32 x )
{ return atan2f( y, x ); }

//----------------------------------------------------------------------------
///<summary>逆正接を求めます.</summary>
///<param name="y">正接の値の分子.</param>
///<param name="x">正接の値の分母.</param>
///<return>y/xの逆正接の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ATan2Deg( const f32 y, const f32 x )
{ return ASDX_RAD_TO_DEG( atan2f( y, x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正接を求めます.</summary>
///<param name="y">正接の値の分子.</param>
///<param name="x">正接の値の分母.</param>
///<return>y/xの逆正接の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ATan2Idx( const f32 y, const f32 x )
{ return ASDX_RAD_TO_IDX( atan2f( y, x ) ); }

//----------------------------------------------------------------------------
///<summary>逆余割を求めます.</summary>
///<param name="x">逆余割を求める値.</param>
///<return>逆余割の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACscRad( const f32 x )
{ return asinf( 1.0f / x ); }

//----------------------------------------------------------------------------
///<summary>逆余割を求めます.</summary>
///<param name="x">逆余割を求める値.</param>
///<return>逆余割の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACscDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( asinf( 1.0f / x ) ); }

//----------------------------------------------------------------------------
///<summary>逆余割を求めます.</summary>
///<param name="x">逆余割を求める値.</param>
///<return>逆余割の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ACscIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( asinf( 1.0f / x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正割を求めます.</summary>
///<param name="x">逆正割を求める値.</param>
///<return>逆正割の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ASecRad( const f32 x )
{ return acosf( 1.0f / x ); }

//----------------------------------------------------------------------------
///<summary>逆正割を求めます.</summary>
///<param name="x">逆正割を求める値.</param>
///<return>逆正割の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ASecDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( acosf( 1.0f / x ) ); }

//----------------------------------------------------------------------------
///<summary>逆正割を求めます.</summary>
///<param name="x">逆正割を求める値.</param>
///<return>逆正割の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ASecIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( acosf( 1.0f / x ) ); }

//----------------------------------------------------------------------------
///<summary>逆余接を求めます.</summary>
///<param name="x">逆余接を求める値.</param>
///<return>逆余接の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACotRad( const f32 x )
{ return atanf( 1.0f / x ); }

//----------------------------------------------------------------------------
///<summary>逆余接を求めます.</summary>
///<param name="x">逆余接を求める値.</param>
///<return>逆余接の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACotDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( atanf( 1.0f / x ) ); }

//----------------------------------------------------------------------------
///<summary>逆余接を求めます.</summary>
///<param name="x">逆余接を求める値.</param>
///<return>逆余接の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ACotIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( atanf( 1.0f / x ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線正弦を求めます.</summary>
///<param name="x">逆双曲線正弦を求める値.</param>
///<return>逆双曲線正弦の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ASinhRad( const f32 x )
{ return logf( x + sqrtf( x * x + 1.0f ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線正弦を求めます.</summary>
///<param name="x">逆双曲線正弦を求める値.</param>
///<return>逆双曲線正弦の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ASinhDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( logf( x + sqrtf( x * x + 1.0f ) ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線正弦を求めます.</summary>
///<param name="x">逆双曲線正弦を求める値.</param>
///<return>逆双曲線正弦の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ASinhIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( logf( x + sqrtf( x * x + 1.0f ) ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線余弦を求めます.</summary>
///<param name="x">逆双曲線余弦を求める値.</param>
///<return>逆双曲線余弦の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACoshRad( const f32 x )
{ return logf( x + sqrtf( x * x - 1.0f ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線余弦を求めます.</summary>
///<param name="x">逆双曲線余弦を求める値.</param>
///<return>逆双曲線余弦の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACoshDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( logf( x + sqrtf( x * x - 1.0f ) ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線余弦を求めます.</summary>
///<param name="x">逆双曲線余弦を求める値.</param>
///<return>逆双曲線余弦の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ACoshIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( logf( x + sqrtf( x * x - 1.0f ) ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線正接を求めます.</summary>
///<param name="x">逆双曲線正接を求める値.</param>
///<return>逆双曲線正接の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ATanhRad( const f32 x )
{ return 0.5f * logf( ( 1.0f + x ) / ( 1.0f - x ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線正接を求めます.</summary>
///<param name="x">逆双曲線正接を求める値.</param>
///<return>逆双曲線正接の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ATanhDeg( const f32 x )
{ return ASDX_RAD_TO_DEG( 0.5f * logf( ( 1.0f + x ) / ( 1.0f - x ) ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線正接を求めます.</summary>
///<param name="x">逆双曲線正接を求める値.</param>
///<return>逆双曲線正接の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ATanhIdx( const f32 x )
{ return ASDX_RAD_TO_IDX( 0.5f * logf( ( 1.0f + x ) / ( 1.0f - x ) ) ); }

//----------------------------------------------------------------------------
///<summary>逆双曲線余割を求めます.</summary>
///<param name="x">逆双曲線余割を求める値.</param>
///<return>逆双曲線余割の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACschRad( const f32 x )
{
    register f32 X = 1.0f / x;
    return logf( X + sqrtf( X * X + 1.0f ) );
}

//----------------------------------------------------------------------------
///<summary>逆双曲線余割を求めます.</summary>
///<param name="x">逆双曲線余割を求める値.</param>
///<return>逆双曲線余割の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACschDeg( const f32 x )
{
    register f32 X = 1.0f / x;
    return ASDX_RAD_TO_DEG( logf( X + sqrtf( X * X + 1.0f ) ) );
}

//----------------------------------------------------------------------------
///<summary>逆双曲線余割を求めます.</summary>
///<param name="x">逆双曲線余割を求める値.</param>
///<return>逆双曲線余割の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ACschIdx( const f32 x )
{
    register f32 X = 1.0f / x;
    return ASDX_RAD_TO_IDX( logf( X + sqrtf( X * X + 1.0f ) ) );
}

//----------------------------------------------------------------------------
///<summary>逆双曲線余接を求めます.</summary>
///<param name="x">逆双曲線余接を求める値.</param>
///<return>逆双曲線余接の値をラジアンで返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACothRad( const f32 x )
{
    register f32 X = 1.0f / x;
    return 0.5f * logf( ( 1.0f + X ) / ( 1.0f - X ) );
}

//----------------------------------------------------------------------------
///<summary>逆双曲線余接を求めます.</summary>
///<param name="x">逆双曲線余接を求める値.</param>
///<return>逆双曲線余接の値を度で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     ACothDeg( const f32 x )
{
    register f32 X = 1.0f / x;
    return ASDX_RAD_TO_DEG( 0.5f * logf( ( 1.0f + X ) / ( 1.0f - X ) ) );
}

//----------------------------------------------------------------------------
///<summary>逆双曲線余接を求めます.</summary>
///<param name="x">逆双曲線余接を求める値.</param>
///<return>逆双曲線余接の値をインデックス角で返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16     ACothIdx( const f32 x )
{
    register f32 X = 1.0f / x;
    return ASDX_RAD_TO_IDX( 0.5f * logf( ( 1.0f + X ) / ( 1.0f - X ) ) );
}


//////////////////////////////////////////////////////////////////////////////
// Vector2 class
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値</param>
///<param name="value">乗算されるベクトル</param>
///<return>乗算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2 operator * ( const f32 scalar, const Vector2& value )
{
    return Vector2( 
        value.x * scalar,
        value.y * scalar );
}

//----------------------------------------------------------------------------
///<summary>コンストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::Vector2()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="pValues">要素数2の配列</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::Vector2( const f32* pValues )
{
    assert( pValues != 0 );
    x = pValues[ 0 ];
    y = pValues[ 1 ];
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::Vector2( const f32 nx, const f32 ny )
{
    x = nx;
    y = ny;
}

//----------------------------------------------------------------------------
///<summary>コピーコンストラクタです.</summary>
///<param name="value">コピー元の値</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::Vector2( const Vector2& value )
{
    x = value.x;
    y = value.y;
}

//----------------------------------------------------------------------------
///<summary>デストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::~Vector2()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>f32ポインタ型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::operator f32* () 
{ return &x; }

//----------------------------------------------------------------------------
///<summary>const f32ポインタ型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2::operator const f32* () const
{ return &x; }

//----------------------------------------------------------------------------
///<summary>加算代入演算子です.</summary>
///<param name="value">加算する値</param>
///<return>加算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::operator += ( const Vector2& value )
{
    x += value.x;
    y += value.y;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>減算代入演算子です.</summary>
///<param name="value">減算する値</param>
///<return>減算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::operator -= ( const Vector2& value )
{
    x -= value.x;
    y -= value.y;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="scalar">乗算するスカラー値</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::operator *= ( const f32 scalar )
{
    x *= scalar;
    y *= scalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>除算代入演算子です.</summary>
///<param name="scalar">除算するスカラー値</param>
///<return>除算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::operator /= ( const f32 scalar )
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    x *= invScalar;
    y *= invScalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>正符号演算子です.</summary>
///<return>自分自身の値を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::operator + () const
{ return (*this); }

//----------------------------------------------------------------------------
///<summary>負符号演算子です.</summary>
///<return>マイナスにした値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::operator - () const
{ return Vector2( -x, -y ); }

//----------------------------------------------------------------------------
///<summary>加算演算子です.</summary>
///<param name="value">加算する値.</param>
///<return>加算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::operator + ( const Vector2& value ) const
{
    return Vector2( 
        x + value.x,
        y + value.y 
    );
}

//----------------------------------------------------------------------------
///<summary>減算演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::operator - ( const Vector2& value ) const
{
    return Vector2(
        x - value.x,
        y - value.y
    );
}

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<return>スカラー乗算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::operator * ( const f32 scalar ) const
{
    return Vector2(
        x * scalar,
        y * scalar
    );
}

//----------------------------------------------------------------------------
///<summary>除算演算子です.</summary>
///<param name="scalar">除算するスカラー値.</param>
///<return>スカラー除算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::operator / ( const f32 scalar ) const
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    return Vector2(
        x * invScalar,
        y * invScalar
    );
}

//----------------------------------------------------------------------------
///<summary>等価演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が等価であればtrue,そうでなければfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Vector2::operator == ( const Vector2& value ) const
{
    return ( x == value.x )
        && ( y == value.y );
}

//----------------------------------------------------------------------------
///<summary>非等価演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が非等価であればtrue，そうでなければfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Vector2::operator != ( const Vector2& value ) const
{
    return ( x != value.x )
        || ( y != value.y );
}

//----------------------------------------------------------------------------
///<summary>代入演算子です.</summary>
///<param name="value">代入する値.</param>
///<return>代入結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::operator = ( const Vector2& value )
{
    x = value.x;
    y = value.y;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルの長さを求めます.</summary>
///<return>ベクトルの長さを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector2::Length() const
{
    return sqrtf( ( x * x ) + ( y * y ) );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの長さの2乗値を求めます.</summary>
///<return>ベクトルの長さの2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector2::LengthSq() const
{
    return ( ( x * x ) + ( y * y ) );
}

//----------------------------------------------------------------------------
///<summary>単位ベクトルを求めます.</summary>
///<return>単位ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2     Vector2::UnitVector() const
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    return Vector2(
        x * invMag,
        y * invMag 
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<return>ベクトルを正規化した結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::Normalize()
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    x *= invMag;
    y *= invMag;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルを安全に正規化します.</summary>
///<param name="value">長さが0の場合に設定する値.</param>
///<return>ベクトルの長さが0の場合はvalueを返却,そうでないときは正規化した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2&    Vector2::SafeNormalize( const Vector2& value ) 
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) );
    if ( mag > 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        x *= invMag;
        y *= invMag;
    }
    else
    {
        x = value.x;
        y = value.y;
    }
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<return>ベクトルの内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector2::Dot( const Vector2& v ) const
{ return ( x * v.x ) + ( y * v.y ); }

//----------------------------------------------------------------------------
///<summary>各成分の値を設定します.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void        Vector2::Set( const f32 nx, const f32 ny )
{
    x = nx;
    y = ny;
}

//////////////////////////////////////////////////////////////////////////////
// Vector2 Methods
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>各成分の絶対値を求めます.</summary>
///<param name="value">絶対値を求める値</param>
///<return>各成分の絶対値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Abs( const Vector2& value )
{
    return Vector2(
        fabs( value.x ),
        fabs( value.y )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の絶対値を求めます.</summary>
///<param name="value">絶対値を求める値</param>
///<param name="result">計算結果の格納先</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Abs( const Vector2& value, Vector2& result )
{
    result.x = fabs( value.x );
    result.y = fabs( value.y );
}

//----------------------------------------------------------------------------
///<summary>各成分の最小値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<return>各成分の最小値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Min( const Vector2& a, const Vector2& b )
{
    return Vector2(
        (( a.x < b.x ) ? a.x : b.x ),
        (( a.y < b.y ) ? a.y : b.y )
   );
}

//----------------------------------------------------------------------------
///<summary>各成分の最小値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<param name="result">各成分の最小値を求めた結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Min( const Vector2& a, const Vector2& b, Vector2& result )
{
    result.x = ( a.x < b.x ) ? a.x : b.x;
    result.y = ( a.y < b.y ) ? a.y : b.y;
}

//----------------------------------------------------------------------------
///<summary>各成分の最大値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<return>各成分の最大値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Max( const Vector2& a, const Vector2& b )
{
    return Vector2(
        (( a.x > b.x ) ? a.x : b.x ),
        (( a.y > b.y ) ? a.y : b.y )
    );
}

//----------------------------------------------------------------------------
///<summary>値を指定された範囲内に制限します.</summary>
///<param name="value">クランプする値.</param>
///<param name="a">最小値.</param>
///<param name="b">最大値.</param>
///<return>クランプされた値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Clamp( const Vector2& value, const Vector2& a, const Vector2& b )
{
    register f32 minX = ( b.x < value.x ) ? b.x : value.x;
    register f32 minY = ( b.y < value.y ) ? b.y : value.y;

    return Vector2(
        (( a.x > minX ) ? a.x : minX ),
        (( a.x > minY ) ? a.y : minY )
    );
}

//----------------------------------------------------------------------------
///<summary>値を指定された範囲内に制限します.</summary>
///<param name="value">クランプする値.</param>
///<param name="a">最小値.</param>
///<param name="b">最大値.</param>
///<param name="result">クランプされた値</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Clamp
(
    const Vector2&  value,
    const Vector2&  a,
    const Vector2&  b,
    Vector2&        result
)
{
    result.x = ( b.x < value.x ) ? b.x : value.x;
    result.y = ( b.y < value.y ) ? b.y : value.y;

    result.x = ( a.x > result.x ) ? a.x : result.x;
    result.y = ( a.y > result.y ) ? a.y : result.y;
}

//----------------------------------------------------------------------------
///<summary>指定された値を0～1の範囲に制限します.</summary>
///<param name="value">クランプする値</param>
///<return>クランプされた値</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Saturate( const Vector2& value )
{
    register f32 minX = ( 1.0f < value.x ) ? 1.0f : value.x;
    register f32 minY = ( 1.0f < value.y ) ? 1.0f : value.y;

    return Vector2(
        (( 0.0f > minX ) ? 0.0f : minX ),
        (( 0.0f > minY ) ? 0.0f : minY )
    );
}

//----------------------------------------------------------------------------
///<summary>指定された値を0～1の範囲に制限します.</summary>
///<param name="value">クランプする値</param>
///<return>クランプされた値</return>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Saturate( const Vector2& value, Vector2& result )
{
    result.x = ( 1.0f < value.x ) ? 1.0f : value.x;
    result.y = ( 1.0f < value.y ) ? 1.0f : value.y;

    result.x = ( 0.0f > value.x ) ? 0.0f : result.x;
    result.y = ( 0.0f > value.y ) ? 0.0f : result.y;
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトル間の距離を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector2::Distance( const Vector2& a, const Vector2& b )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    return sqrtf( ( difX * difX ) + ( difY * difY ) );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトル間の距離</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Distance( const Vector2& a, const Vector2&b, f32& result )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    result = sqrtf( ( difX * difX ) + ( difY * difY ) );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離の2乗値を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトル間の距離の2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector2::DistanceSq( const Vector2& a, const Vector2& b )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    return ( difX * difX ) + ( difY * difY );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離の2乗値を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::DistanceSq( const Vector2& a, const Vector2& b, f32& result )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    result = ( difX * difX ) + ( difY * difY );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>ベクトルの内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector2::Dot( const Vector2& a, const Vector2& b )
{
    return ( a.x * b.x ) + ( a.y * b.y );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">ベクトルの内積</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Dot( const Vector2& a, const Vector2& b, f32& result )
{
    result = ( a.x * b.x ) + ( a.y * b.y );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<param name="value">正規化するベクトル</param>
///<return>正規化したベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Normalize( const Vector2& value )
{
    register f32 mag = sqrtf( ( value.x * value.x ) + ( value.y * value.y ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    return Vector2(
        value.x * invMag,
        value.y * invMag
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<param name="value">正規化するベクトル</param>
///<param name="result">正規化されたベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Normalize( const Vector2& value, Vector2& result )
{
    register f32 mag = sqrtf( ( value.x * value.x ) + ( value.y * value.y ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    result.x = value.x * invMag;
    result.y = value.y * invMag;
}

//----------------------------------------------------------------------------
///<summary>ベクトルの正規化を試みます.</summary>
///<param name="value">正規化するベクトル</param>
///<param name="set">長さが0の場合に設定するベクトル</param>
///<return>ベクトルの長さが0でなければ正規化されたベクトル，長さが0の場合はsetを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::SafeNormalize( const Vector2& value, const Vector2& set )
{
    register f32 mag = sqrtf( ( value.x * value.x ) + ( value.y * value.y ) );
    if ( mag > 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        return Vector2(
            value.x * invMag,
            value.y * invMag 
        );
    }
    else
    {
        return Vector2(
            set.x,
            set.y
        );
    }
}

//----------------------------------------------------------------------------
///<summary>ベクトルの正規化を試みます.</summary>
///<param name="value">正規化するベクトル.</param>
///<param name="set">長さが0の場合に設定するベクトル</param>
///<param name="result">ベクトルの長さが0でなければ正規化されたベクトル，長さが0の場合はset</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::SafeNormalize
(
    const Vector2&  value,
    const Vector2&  set,
    Vector2&        result
)
{
    register f32 mag = sqrtf( ( value.x * value.x ) + ( value.y * value.y ) );
    if ( mag != 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        result.x = value.x * invMag;
        result.y = value.y * invMag;
    }
    else
    {
        result.x = set.x;
        result.y = set.y;
    }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(ラジアン)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector2::ComputeCrossingAngleRad( const Vector2& a, const Vector2& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) ) / d;
        if ( c >= 1.0f )
        { return 0.0f; }

        if ( c <= -1.0f )
        { return F_PI; }

        return acosf( c );
    }
    else
    { return 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(ラジアン)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::ComputeCrossingAngleRad
(
    const Vector2&  a,
    const Vector2&  b,
    f32&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0.0f;
            return;
        }

        if ( c <= -1.0f )
        {
            result = F_PI;
            return;
        }

        result = acosf( c );
    }
    else
    { result = 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(度)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector2::ComputeCrossingAngleDeg( const Vector2& a, const Vector2& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) ) / d;
        if ( c >= 1.0f )
        { return 0.0f; }

        if ( c <= -1.0f )
        { return 180.0f; }

        return ASDX_RAD_TO_DEG( acosf( c ) );
    }
    else
    { return 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(度)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::ComputeCrossingAngleDeg
(
    const Vector2&  a,
    const Vector2&  b,
    f32&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0.0f;
            return;
        }

        if ( c <= -1.0f )
        {
            result = 180.0f;
            return;
        }

        result = ASDX_RAD_TO_DEG( acosf( c ) );
    }
    else
    { result = 0.0f; }
}


//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(インデックス角)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16      Vector2::ComputeCrossingAngleIdx( const Vector2& a, const Vector2& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) ) / d;
        if ( c >= 1.0f )
        { return 0; }

        if ( c <= -1.0f )
        { return 32768; }

        return ASDX_RAD_TO_IDX( acosf( c ) );
    }
    else
    { return 0; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(インデックス角)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::ComputeCrossingAngleIdx
(
    const Vector2&  a,
    const Vector2&  b,
    u16&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0;
            return;
        }

        if ( c <= -1.0f )
        {
            result = 32768;
            return;
        }

        result = ASDX_RAD_TO_IDX( acosf( c ) );
    }
    else
    { result = 0; }
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルから、反射ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<return>反射ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Reflect( const Vector2& i, const Vector2& n )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y );
    return Vector2(
        i.x - ( 2.0f * n.x ) * dot,
        i.y - ( 2.0f * n.y ) * dot
    );
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルから、反射ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="result">反射ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Reflect( const Vector2& i, const Vector2& n, Vector2& result )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y );
    result.x = i.x - ( 2.0f * n.x ) * dot;
    result.y = i.y - ( 2.0f * n.y ) * dot;
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルと屈折率から、屈折ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="eta">屈折率</param>
///<return>屈折ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2 Vector2::Refract( const Vector2& i, const Vector2& n, f32 eta )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y );
    register f32 k = 1.0f - eta * eta * ( 1.0f - dot * dot );
    if ( k < 0.f )
    {
        return Vector2( 0.0f, 0.0f );
    }
    register f32 sqrtK = sqrtf(k); 
    return Vector2(
        eta * i.x - ( eta * dot + sqrtK ) * n.x,
        eta * i.y - ( eta * dot + sqrtK ) * n.y
    );
} 

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルと屈折率から、屈折ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="eta">屈折率</param>
///<param name="result">屈折ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Refract( const Vector2& i, const Vector2& n, f32 eta, Vector2& result )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y );
    register f32 k = 1.0f - eta * eta * ( 1.0f - dot * dot );
    if ( k < 0.f )
    {
        result.x = 0.0f;
        result.y = 0.0f;
        return;
    }
    register f32 sqrtK = sqrtf(k); 
    result.x = eta * i.x - ( eta * dot + sqrtK ) * n.x;
    result.y = eta * i.y - ( eta * dot + sqrtK ) * n.y;
}

//----------------------------------------------------------------------------
///<summary>重心座標上の点を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="c">入力ベクトル</param>
///<param name="amount1">重み</param>
///<param name="amount2">重み</param>
///<return>重心座標上の点を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Barycentric
(
    const Vector2&  a,
    const Vector2&  b,
    const Vector2&  c,
    const f32       amount1,
    const f32       amount2
)
{
    return Vector2(
        a.x + ( b.x - a.x ) * amount1 + ( c.x - a.x ) * amount2,
        a.y + ( b.y - a.y ) * amount1 + ( c.y - a.y ) * amount2
    );
}

//----------------------------------------------------------------------------
///<summary>重心座標上の点を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="c">入力ベクトル</param>
///<param name="amount1">重み</param>
///<param name="amount2">重み</param>
///<param name="result">重心座標上の点</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Barycentric
(
    const Vector2&  a,
    const Vector2&  b,
    const Vector2&  c,
    const f32       amount1,
    const f32       amount2,
    Vector2&        result
)
{
    result.x = a.x + ( b.x - a.x ) * amount1 + ( c.x - a.x ) * amount2;
    result.y = a.y + ( b.y - a.y ) * amount1 + ( c.y - a.y ) * amount2;
}

//----------------------------------------------------------------------------
///<summary>エルミートスプライン補間を行います.</summary>
///<param name="a">入力位置ベクトル</param>
///<param name="t1">入力接ベクトル</param>
///<param name="b">入力位置ベクトル</param>
///<param name="t2">入力接ベクトル</param>
///<param name="amount">重み</param>
///<return>エルミートスプライン補間を行った結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Hermite
( 
    const Vector2&  a,
    const Vector2&  t1,
    const Vector2&  b,
    const Vector2&  t2,
    const f32       amount
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    Vector2 result;
    if ( amount == 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
    }
    else if ( amount == 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
    }
    else
    {
        result.x = ( 2.0f * a.x - 2.0f * b.x + t2.x + t1.x ) * c3 + ( 3.0f * b.x - 3.0f * a.x - 2.0f * t1.x - t2.x ) * c3 + t1.x * amount + a.x;
        result.y = ( 2.0f * a.y - 2.0f * b.y + t2.y + t1.y ) * c3 + ( 3.0f * b.y - 3.0f * a.y - 2.0f * t1.y - t2.y ) * c3 + t1.y * amount + a.y;
    }
    return result;
}

//----------------------------------------------------------------------------
///<summary>エルミートスプライン補間を行います.</summary>
///<param name="a">入力位置ベクトル</param>
///<param name="t1">入力接ベクトル</param>
///<param name="b">入力位置ベクトル</param>
///<param name="t2">入力接ベクトル</param>
///<param name="amount">重み</param>
///<param name="result">エルミートスプライン補間を行った結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Hermite
(
    const Vector2&  a,
    const Vector2&  t1,
    const Vector2&  b,
    const Vector2&  t2,
    const f32       amount,
    Vector2&        result
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    if ( amount == 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
    }
    else if ( amount == 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
    }
    else
    {
        result.x = ( 2.0f * a.x - 2.0f * b.x + t2.x + t1.x ) * c3 + ( 3.0f * b.x - 3.0f * a.x - 2.0f * t1.x - t2.x ) * c3 + t1.x * amount + a.x;
        result.y = ( 2.0f * a.y - 2.0f * b.y + t2.y + t1.y ) * c3 + ( 3.0f * b.y - 3.0f * a.y - 2.0f * t1.y - t2.y ) * c3 + t1.y * amount + a.y;
    }
}

//----------------------------------------------------------------------------
///<summary>Catmull-Rom補間を行います.</summary>
///<param name="a">補間の最初の位置</param>
///<param name="b">補間の 2 番目の位置</param>
///<param name="c">補間の 3 番目の位置</param>
///<param name="d">補間の 4 番目の位置</param>
///<param name="amount">加重係数</param>
///<return>Catmull-Rom 補間の結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::CatmullRom
(
    const Vector2&  a,
    const Vector2&  b,
    const Vector2&  c,
    const Vector2&  d,
    const f32       amount
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    return Vector2(
        ( 0.5f * ( 2.0f * b.x + ( c.x - a.x ) * amount + ( 2.0f * a.x - 5.0f * b.x + 4.0f * c.x - d.x ) * c2 + ( 3.0f * b.x - a.x - 3.0f * c.x + d.x ) * c3 ) ),
        ( 0.5f * ( 2.0f * b.y + ( c.y - a.y ) * amount + ( 2.0f * a.y - 5.0f * b.y + 4.0f * c.y - d.y ) * c2 + ( 3.0f * b.y - a.y - 3.0f * c.y + d.y ) * c3 ) )
    );
}

//----------------------------------------------------------------------------
///<summary>Catmull-Rom補間を行います.</summary>
///<param name="a">補間の最初の位置</param>
///<param name="b">補間の 2 番目の位置</param>
///<param name="c">補間の 3 番目の位置</param>
///<param name="d">補間の 4 番目の位置</param>
///<param name="amount">加重係数</param>
///<param name="result">Catmull-Rom 補間の結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Vector2::CatmullRom
(
    const Vector2&  a,
    const Vector2&  b,
    const Vector2&  c,
    const Vector2&  d,
    const f32       amount,
    Vector2&        result
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    result.x = ( 0.5f * ( 2.0f * b.x + ( c.x - a.x ) * amount + ( 2.0f * a.x - 5.0f * b.x + 4.0f * c.x - d.x ) * c2 + ( 3.0f * b.x - a.x - 3.0f * c.x + d.x ) * c3 ) );
    result.y = ( 0.5f * ( 2.0f * b.y + ( c.y - a.y ) * amount + ( 2.0f * a.y - 5.0f * b.y + 4.0f * c.y - d.y ) * c2 + ( 3.0f * b.y - a.y - 3.0f * c.y + d.y ) * c3 ) );
}

//----------------------------------------------------------------------------
///<summary>線形補間を行います.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="amount">重みを示す 0 ～ 1 の範囲の値</param>
///<return>線形補間の結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Lerp( const Vector2& a, const Vector2& b, const f32 amount )
{
    return Vector2(
        a.x + ( b.x - a.x ) * amount,
        a.y + ( b.y - a.y ) * amount
    );
}

//----------------------------------------------------------------------------
///<summary>線形補間を行います.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="amount">重みを示す 0 ～ 1 の範囲の値</param>
///<param name="result">線形補間の結果を返却します</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Lerp
(
    const Vector2&  a,
    const Vector2&  b,
    const f32       amount,
    Vector2&        result
)
{
    result.x = a.x + ( b.x - a.x ) * amount;
    result.y = a.y + ( b.y - a.y ) * amount;
}

//----------------------------------------------------------------------------
///<summary>三次方程式を使用して、2 つの値の間を補間します</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="amount">重み</param>
///<return>補間の結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::SmoothStep( const Vector2& a, const Vector2& b, const f32 amount )
{
    register f32 t = asdx::Clamp( amount, 0.0f, 1.0f );
    register Vector2 zero( 0.0f, 0.0f );
    return Hermite( a, zero, b, zero, t );
}

//----------------------------------------------------------------------------
///<summary>三次方程式を使用して、2 つの値の間を補間します</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="amoutn">重み</param>
///<param name="result">補間の結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::SmoothStep
(
    const Vector2&  a,
    const Vector2&  b,
    const f32       amount,
    Vector2&        result
)
{
    register f32 t = asdx::Clamp( amount, 0.0f, 1.0f );
    register Vector2 zero( 0.0f, 0.0f );
    Hermite( a, zero, b, zero, t, result );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いてベクトルを変換します.</summary>
///<param name="position">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>変換されたベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::Transform( const Vector2& position, const Matrix& matrix )
{
    return Vector2(
        ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + matrix._41,
        ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + matrix._42
    );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いてベクトルを変換します.</summary>
///<param name="position">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">変換されたベクトルを返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::Transform
(
    const Vector2&  position,
    const Matrix&   matrix,
    Vector2&        result
)
{
    result.x = ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + matrix._41;
    result.y = ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + matrix._42;
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いて法線ベクトルを変換します.</summary>
///<param name="normal">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>変換された法線ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::TransformNormal( const Vector2& normal, const Matrix& matrix )
{
    return Vector2(
        ( normal.x * matrix._11 ) + ( normal.y * matrix._21 ),
        ( normal.x * matrix._12 ) + ( normal.y * matrix._22 ) );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いて法線ベクトルを変換します.</summary>
///<param name="normal">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">変換された法線ベクトル.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::TransformNormal
(
    const Vector2&  normal,
    const Matrix&   matrix,
    Vector2&        result
)
{
    result.x = ( normal.x * matrix._11 ) + ( normal.y * matrix._21 );
    result.y = ( normal.x * matrix._12 ) + ( normal.y * matrix._22 );
}

//----------------------------------------------------------------------------
///<summary>指定された行列用いてベクトルを変換し，変換結果をw=1に射影します.</summary>
///<param name="coord">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>行列変換後，w=1に射影されたベクトルを返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector2  Vector2::TransformCoordinate( const Vector2& coord, const Matrix& matrix )
{
    register f32 X = ( coord.x * matrix._11 ) + ( coord.y * matrix._21 ) + matrix._41;
    register f32 Y = ( coord.x * matrix._12 ) + ( coord.y * matrix._22 ) + matrix._42;
    register f32 W = ( coord.x * matrix._14 ) + ( coord.y * matrix._24 ) + matrix._44;
    return Vector2(
        X / W,
        Y / W
    );
}

//----------------------------------------------------------------------------
///<summary>指定された行列用いてベクトルを変換し，変換結果をw=1に射影します.</summary>
///<param name="coord">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">行列変換後，w=1に射影されたベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector2::TransformCoordinate
(
    const Vector2&  coord,
    const Matrix&   matrix,
    Vector2&        result
)
{
    register f32 X = ( coord.x * matrix._11 ) + ( coord.y * matrix._21 ) + matrix._41;
    register f32 Y = ( coord.x * matrix._12 ) + ( coord.y * matrix._22 ) + matrix._42;
    register f32 W = ( coord.x * matrix._14 ) + ( coord.y * matrix._24 ) + matrix._44;
    result.x = X / W;
    result.y = Y / W;
}


//////////////////////////////////////////////////////////////////////////////
// Vector3 class
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<param name="value">乗算されるベクトル.</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3 operator * ( const f32 scalar, const Vector3& value )
{
    return Vector3(
        value.x * scalar,
        value.y * scalar,
        value.z * scalar
    );
}

//----------------------------------------------------------------------------
///<summary>コンストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::Vector3()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="pValues">要素数3の配列</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::Vector3( const f32* pValues )
{
    assert( pValues != 0 );
    x = pValues[ 0 ];
    y = pValues[ 1 ];
    z = pValues[ 2 ];
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
///<param name="nz">Z成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::Vector3( const f32 nx, const f32 ny, const f32 nz )
{
    x = nx;
    y = ny;
    z = nz;
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="value">2次元ベクトル</param>
///<param name="nz">Z成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::Vector3( const Vector2& value, const f32 nz )
{
    x = value.x;
    y = value.y;
    z = nz;
}

//----------------------------------------------------------------------------
///<summary>コピーコンストラクタです.</summary>
///<param name="value">コピー元</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::Vector3( const Vector3& value )
{
    x = value.x;
    y = value.y;
    z = value.z;
}

//----------------------------------------------------------------------------
///<summary>デストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::~Vector3()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>f32*型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::operator f32* () 
{ return &x; }

//----------------------------------------------------------------------------
///<summary>const f32*型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3::operator const f32* () const
{ return &x; }

//----------------------------------------------------------------------------
///<summary>加算代入演算子です.</summary>
///<param name="value">加算する値</param>
///<return>加算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::operator += ( const Vector3& value )
{
    x += value.x;
    y += value.y;
    z += value.z;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>減算代入演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::operator -= ( const Vector3& value )
{
    x -= value.x;
    y -= value.y;
    z -= value.z;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="scalar">乗算するスカラー値</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::operator *= ( const f32 scalar )
{
    x *= scalar;
    y *= scalar;
    z *= scalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>除算代入演算子です.</summary>
///<param name="scalar">除算するスカラー値</param>
///<return>除算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::operator /= ( const f32 scalar )
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    x *= invScalar;
    y *= invScalar;
    z *= invScalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>正符号演算子です.</summary>
///<return>自分自身の値を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::operator + () const
{ return (*this); }

//----------------------------------------------------------------------------
///<summary>負符号演算子です.</summary>
///<return>マイナスにした値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::operator - () const
{ return Vector3( -x, -y, -z ); }

//----------------------------------------------------------------------------
///<summary>加算演算子です.</summary>
///<param name="value">加算する値.</param>
///<return>加算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::operator + ( const Vector3& value ) const
{
    return Vector3( 
        x + value.x,
        y + value.y,
        z + value.z
    );
}

//----------------------------------------------------------------------------
///<summary>減算演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::operator - ( const Vector3& value ) const
{
    return Vector3(
        x - value.x,
        y - value.y,
        z - value.z
    );
}

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<return>スカラー乗算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::operator * ( const f32 scalar ) const
{
    return Vector3(
        x * scalar,
        y * scalar,
        z * scalar
    );
}

//----------------------------------------------------------------------------
///<summary>除算演算子です.</summary>
///<param name="scalar">除算するスカラー値.</param>
///<return>スカラー除算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::operator / ( const f32 scalar ) const
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    return Vector3(
        x * invScalar,
        y * invScalar,
        z * invScalar
    );
}

//----------------------------------------------------------------------------
///<summary>等価演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が等価であればtrue,そうでなければfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Vector3::operator == ( const Vector3& value ) const
{
    return ( x == value.x )
        && ( y == value.y )
        && ( z == value.z );
}

//----------------------------------------------------------------------------
///<summary>非等価演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が非等価であればtrue，そうでなければfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Vector3::operator != ( const Vector3& value ) const
{
    return ( x != value.x )
        || ( y != value.y )
        || ( z != value.z );
}

//----------------------------------------------------------------------------
///<summary>代入演算子です.</summary>
///<param name="value">代入する値.</param>
///<return>代入結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::operator = ( const Vector3& value )
{
    x = value.x;
    y = value.y;
    z = value.z;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルの長さを求めます.</summary>
///<return>ベクトルの長さを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector3::Length() const
{
    return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの長さの2乗値を求めます.</summary>
///<return>ベクトルの長さの2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector3::LengthSq() const
{
    return ( ( x * x ) + ( y * y ) + ( z * z ) );
}

//----------------------------------------------------------------------------
///<summary>単位ベクトルを求めます.</summary>
///<return>単位ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::UnitVector() const
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) );
    assert( mag != 0.0f );
    register f32 invMag = 1.0f / mag;
    return Vector3(
        x * invMag,
        y * invMag,
        z * invMag
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<return>ベクトルを正規化した結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::Normalize()
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) );
    assert( mag != 0.0f );
    register f32 invMag = 1.0f / mag;
    x *= invMag;
    y *= invMag;
    z *= invMag;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルを安全に正規化します.</summary>
///<param name="value">長さが0の場合に設定する値.</param>
///<return>ベクトルの長さが0の場合はvalueを返却,そうでないときは正規化した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3&    Vector3::SafeNormalize( const Vector3& value ) 
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) );
    if ( mag != 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        x *= invMag;
        y *= invMag;
        z *= invMag;
    }
    else
    {
        x = value.x;
        y = value.y;
        z = value.z;
    }
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="value">入力ベクトル</param>
///<return>ベクトルの内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector3::Dot( const Vector3& value ) const
{ return ( x * value.x ) + ( y * value.y ) + ( z * value.z ); }

//----------------------------------------------------------------------------
///<summary>ベクトルの外積を求めます.</summary>
///<param name="value">入力ベクトル</param>
///<return>ベクトルの外積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3     Vector3::Cross( const Vector3& value ) const
{
    return Vector3(
        ( y * value.z ) - ( z * value.y ),
        ( z * value.x ) - ( x * value.z ),
        ( x * value.y ) - ( y * value.x )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の値を設定します.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
///<param name="nz">Z成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void        Vector3::Set( const f32 nx, const f32 ny, const f32 nz )
{
    x = nx;
    y = ny;
    z = nz;
}



//////////////////////////////////////////////////////////////////////////////
// Vector3 Methods
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>各成分の絶対値を求めます.</summary>
///<param name="value">絶対値を求める値</param>
///<return>各成分の絶対値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Abs( const Vector3& value )
{
    return Vector3(
        fabs( value.x ),
        fabs( value.y ),
        fabs( value.z )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の絶対値を求めます.</summary>
///<param name="value">絶対値を求める値</param>
///<param name="result">計算結果の格納先</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Abs( const Vector3& value, Vector3& result )
{
    result.x = fabs( value.x );
    result.y = fabs( value.y );
    result.z = fabs( value.z );
}

//----------------------------------------------------------------------------
///<summary>各成分の最小値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<return>各成分の最小値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Min( const Vector3& a, const Vector3& b )
{
    return Vector3(
        (( a.x < b.x ) ? a.x : b.x ),
        (( a.y < b.y ) ? a.y : b.y ),
        (( a.z < b.z ) ? a.z : b.z )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の最小値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<param name="result">各成分の最小値を求めた結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Min( const Vector3& a, const Vector3& b, Vector3& result )
{
    result.x = ( a.x < b.x ) ? a.x : b.x;
    result.y = ( a.y < b.y ) ? a.y : b.y;
    result.z = ( a.z < b.z ) ? a.z : b.z;
}

//----------------------------------------------------------------------------
///<summary>各成分の最大値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<return>各成分の最大値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Max( const Vector3& a, const Vector3& b )
{
    return Vector3(
        (( a.x > b.x ) ? a.x : b.x ),
        (( a.y > b.y ) ? a.y : b.y ),
        (( a.z > b.z ) ? a.z : b.z )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の最大値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<param name="result">各成分の最大値を求めた結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Vector3::Max( const Vector3& a, const Vector3& b, Vector3& result )
{
    result.x = ( a.x > b.x ) ? a.x : b.x;
    result.y = ( a.y > b.y ) ? a.y : b.y;
    result.z = ( a.z > b.z ) ? a.z : b.z;
}

//----------------------------------------------------------------------------
///<summary>値を指定された範囲内に制限します.</summary>
///<param name="value">クランプする値.</param>
///<param name="a">最小値.</param>
///<param name="b">最大値.</param>
///<return>クランプされた値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Clamp( const Vector3& value, const Vector3& a, const Vector3& b )
{
    register f32 minX = ( b.x < value.x ) ? b.x : value.x;
    register f32 minY = ( b.y < value.y ) ? b.y : value.y;
    register f32 minZ = ( b.z < value.z ) ? b.z : value.z;

    return Vector3(
        (( a.x > minX ) ? a.x : minX ),
        (( a.x > minY ) ? a.y : minY ),
        (( a.z > minZ ) ? a.z : minZ )
    );
}

//----------------------------------------------------------------------------
///<summary>値を指定された範囲内に制限します.</summary>
///<param name="value">クランプする値.</param>
///<param name="a">最小値.</param>
///<param name="b">最大値.</param>
///<param name="result">クランプされた値</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Clamp
(
    const Vector3&  value,
    const Vector3&  a,
    const Vector3&  b,
    Vector3&        result
)
{
    result.x = ( b.x < value.x ) ? b.x : value.x;
    result.y = ( b.y < value.y ) ? b.y : value.y;
    result.z = ( b.z < value.z ) ? b.z : value.z;

    result.x = ( a.x > result.x ) ? a.x : result.x;
    result.y = ( a.y > result.y ) ? a.y : result.y;
    result.z = ( a.z > result.z ) ? a.z : result.z;
}

//----------------------------------------------------------------------------
///<summary>指定された値を0～1の範囲に制限します.</summary>
///<param name="value">クランプする値</param>
///<return>クランプされた値</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Saturate( const Vector3& value )
{
    register f32 minX = ( 1.0f < value.x ) ? 1.0f : value.x;
    register f32 minY = ( 1.0f < value.y ) ? 1.0f : value.y;
    register f32 minZ = ( 1.0f < value.z ) ? 1.0f : value.z;

    return Vector3(
        (( 0.0f > minX ) ? 0.0f : minX ),
        (( 0.0f > minY ) ? 0.0f : minY ),
        (( 0.0f > minZ ) ? 0.0f : minZ )
    );
}

//----------------------------------------------------------------------------
///<summary>指定された値を0～1の範囲に制限します.</summary>
///<param name="value">クランプする値</param>
///<return>クランプされた値</return>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Saturate( const Vector3& value, Vector3& result )
{
    result.x = ( 1.0f < value.x ) ? 1.0f : value.x;
    result.y = ( 1.0f < value.y ) ? 1.0f : value.y;
    result.z = ( 1.0f < value.z ) ? 1.0f : value.z;

    result.x = ( 0.0f > value.x ) ? 0.0f : result.x;
    result.y = ( 0.0f > value.y ) ? 0.0f : result.y;
    result.z = ( 0.0f > value.z ) ? 0.0f : result.z;
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトル間の距離を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector3::Distance( const Vector3& a, const Vector3& b )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    return sqrtf( ( difX * difX ) + ( difY * difY ) + ( difZ * difZ ) );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトル間の距離</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Distance( const Vector3& a, const Vector3&b, f32& result )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    result = sqrtf( ( difX * difX ) + ( difY * difY ) + ( difZ * difZ ) );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離の2乗値を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトル間の距離の2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector3::DistanceSq( const Vector3& a, const Vector3& b )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    return ( difX * difX ) + ( difY * difY ) + ( difZ * difZ );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離の2乗値を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::DistanceSq( const Vector3& a, const Vector3& b, f32& result )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    result = ( difX * difX ) + ( difY * difY ) + ( difZ * difZ );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>ベクトルの内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector3::Dot( const Vector3& a, const Vector3& b )
{
    return ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">ベクトルの内積</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Dot( const Vector3& a, const Vector3& b, f32& result )
{
    result = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z *  b.z );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの外積を求めます.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<return>ベクトルの外積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Cross( const Vector3& a, const Vector3& b )
{
    return Vector3(
        ( a.y * b.z ) - ( a.z * b.y ),
        ( a.z * b.x ) - ( a.x * b.z ),
        ( a.x * b.y ) - ( a.y * b.x )
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの外積を求めます.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="result">ベクトルの外積.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Cross( const Vector3& a, const Vector3& b, Vector3& result )
{
    result.x = ( a.y * b.z ) - ( a.z * b.y );
    result.y = ( a.z * b.x ) - ( a.x * b.z );
    result.z = ( a.x * b.y ) - ( a.y * b.x );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<param name="value">正規化するベクトル</param>
///<return>正規化したベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Normalize( const Vector3& value )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y ) 
                            + ( value.z * value.z ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    return Vector3(
        value.x * invMag,
        value.y * invMag,
        value.z * invMag 
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<param name="value">正規化するベクトル</param>
///<param name="result">正規化されたベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Normalize( const Vector3& value, Vector3& result )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    result.x = value.x * invMag;
    result.y = value.y * invMag;
    result.z = value.z * invMag;
}

//----------------------------------------------------------------------------
///<summary>ベクトルの正規化を試みます.</summary>
///<param name="value">正規化するベクトル</param>
///<param name="set">長さが0の場合に設定するベクトル</param>
///<return>ベクトルの長さが0でなければ正規化されたベクトル，長さが0の場合はsetを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::SafeNormalize( const Vector3& value, const Vector3& set )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z ) );
    if ( mag > 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        return Vector3(
            value.x * invMag,
            value.y * invMag,
            value.z * invMag
        );
    }
    else
    {
        return Vector3(
            set.x,
            set.y,
            set.z 
        );
    }
}

//----------------------------------------------------------------------------
///<summary>ベクトルの正規化を試みます.</summary>
///<param name="value">正規化するベクトル.</param>
///<param name="set">長さが0の場合に設定するベクトル</param>
///<param name="result">ベクトルの長さが0でなければ正規化されたベクトル，長さが0の場合はset</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::SafeNormalize
(
    const Vector3&  value,
    const Vector3&  set,
    Vector3&        result
)
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z ) );
    if ( mag != 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        result.x = value.x * invMag;
        result.y = value.y * invMag;
        result.z = value.z * invMag;
    }
    else
    {
        result.x = set.x;
        result.y = set.y;
        result.z = set.z;
    }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(ラジアン)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector3::ComputeCrossingAngleRad( const Vector3& a, const Vector3& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) ) / d;
        if ( c >= 1.0f )
        { return 0.0f; }

        if ( c <= -1.0f )
        { return F_PI; }

        return acosf( c );
    }
    else
    { return 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(ラジアン)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::ComputeCrossingAngleRad
(
    const Vector3&  a,
    const Vector3&  b,
    f32&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0.0f;
            return;
        }

        if ( c <= -1.0f )
        {
            result = F_PI;
            return;
        }

        result = acosf( c );
    }
    else
    { result = 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(度)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector3::ComputeCrossingAngleDeg( const Vector3& a, const Vector3& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) ) / d;
        if ( c >= 1.0f )
        { return 0.0f; }

        if ( c <= -1.0f )
        { return 180.0f; }

        return ASDX_RAD_TO_DEG( acosf( c ) );
    }
    else
    { return 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(度)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::ComputeCrossingAngleDeg
(
    const Vector3&  a,
    const Vector3&  b,
    f32&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0.0f;
            return;
        }

        if ( c <= -1.0f )
        {
            result = 180.0f;
            return;
        }

        result = ASDX_RAD_TO_DEG( acosf( c ) );
    }
    else
    { result = 0.0f; }
}


//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(インデックス角)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16      Vector3::ComputeCrossingAngleIdx( const Vector3& a, const Vector3& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) ) / d;
        if ( c >= 1.0f )
        { return 0; }

        if ( c <= -1.0f )
        { return 32768; }

        return ASDX_RAD_TO_IDX( acosf( c ) );
    }
    else
    { return 0; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(インデックス角)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::ComputeCrossingAngleIdx
( 
    const Vector3&  a,
    const Vector3&  b,
    u16&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0;
            return;
        }

        if ( c <= -1.0f )
        {
            result = 32768;
            return;
        }

        result = ASDX_RAD_TO_IDX( acosf( c ) );
    }
    else
    { result = 0; }
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルから、反射ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<return>反射ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Reflect( const Vector3& i, const Vector3& n )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
    return Vector3(
        i.x - ( 2.0f * n.x ) * dot,
        i.y - ( 2.0f * n.y ) * dot,
        i.z - ( 2.0f * n.z ) * dot
    );
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルから、反射ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="result">反射ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Reflect( const Vector3& i, const Vector3& n, Vector3& result )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
    result.x = i.x - ( 2.0f * n.x ) * dot;
    result.y = i.y - ( 2.0f * n.y ) * dot;
    result.z = i.z - ( 2.0f * n.z ) * dot;
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルと屈折率から、屈折ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="eta">屈折率</param>
///<return>屈折ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Refract( const Vector3& i, const Vector3& n, f32 eta )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
    register f32 k = 1.0f - eta * eta * ( 1.0f - dot * dot );
    if ( k < 0.f )
    {
        return Vector3( 0.0f, 0.0f, 0.0f );
    }
    register f32 sqrtK = sqrtf(k); 
    return Vector3(
        eta * i.x - ( eta * dot + sqrtK ) * n.x,
        eta * i.y - ( eta * dot + sqrtK ) * n.y,
        eta * i.z - ( eta * dot + sqrtK ) * n.z
    );
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルと屈折率から、屈折ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="eta">屈折率</param>
///<param name="result">屈折ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Refract( const Vector3& i, const Vector3& n, f32 eta, Vector3& result )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
    register f32 k = 1.0f - eta * eta * ( 1.0f - dot * dot );
    if ( k < 0.f )
    {
        result.x = 0.0f;
        result.y = 0.0f;
        result.z = 0.0f;
        return;
    }
    register f32 sqrtK = sqrtf(k); 
    result.x = eta * i.x - ( eta * dot + sqrtK ) * n.x;
    result.y = eta * i.y - ( eta * dot + sqrtK ) * n.y;
    result.z = eta * i.z - ( eta * dot + sqrtK ) * n.z;
}

//----------------------------------------------------------------------------
///<summary>重心座標上の点を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="c">入力ベクトル</param>
///<param name="amount1">重み</param>
///<param name="amount2">重み</param>
///<return>重心座標上の点を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Barycentric
(
    const Vector3&  a,
    const Vector3&  b,
    const Vector3&  c,
    const f32       amount1,
    const f32       amount2
)
{
    return Vector3(
        a.x + ( b.x - a.x ) * amount1 + ( c.x - a.x ) * amount2,
        a.y + ( b.y - a.y ) * amount1 + ( c.y - a.y ) * amount2,
        a.z + ( b.z - a.z ) * amount1 + ( c.z - a.z ) * amount2 
    );
}

//----------------------------------------------------------------------------
///<summary>重心座標上の点を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="c">入力ベクトル</param>
///<param name="amount1">重み</param>
///<param name="amount2">重み</param>
///<param name="result">重心座標上の点</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Barycentric
(
    const Vector3&  a,
    const Vector3&  b,
    const Vector3&  c,
    const f32       amount1,
    const f32       amount2,
    Vector3&        result
)
{
    result.x = a.x + ( b.x - a.x ) * amount1 + ( c.x - a.x ) * amount2;
    result.y = a.y + ( b.y - a.y ) * amount1 + ( c.y - a.y ) * amount2;
    result.z = a.z + ( b.z - a.z ) * amount1 + ( c.z - a.z ) * amount2;
}

//----------------------------------------------------------------------------
///<summary>エルミートスプライン補間を行います.</summary>
///<param name="a">入力位置ベクトル</param>
///<param name="t1">入力接ベクトル</param>
///<param name="b">入力位置ベクトル</param>
///<param name="t2">入力接ベクトル</param>
///<param name="amount">重み</param>
///<return>エルミートスプライン補間を行った結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Hermite
(
    const Vector3&  a,
    const Vector3&  t1,
    const Vector3&  b,
    const Vector3&  t2,
    const f32       amount
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    Vector3 result;
    if ( amount == 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
        result.z = a.z;
    }
    else if ( amount == 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
        result.z = b.z;
    }
    else
    {
        result.x = ( 2.0f * a.x - 2.0f * b.x + t2.x + t1.x ) * c3 + ( 3.0f * b.x - 3.0f * a.x - 2.0f * t1.x - t2.x ) * c3 + t1.x * amount + a.x;
        result.y = ( 2.0f * a.y - 2.0f * b.y + t2.y + t1.y ) * c3 + ( 3.0f * b.y - 3.0f * a.y - 2.0f * t1.y - t2.y ) * c3 + t1.y * amount + a.y;
        result.z = ( 2.0f * a.z - 2.0f * b.z + t2.z + t1.z ) * c3 + ( 3.0f * b.z - 3.0f * a.z - 2.0f * t1.z - t2.z ) * c3 + t1.z * amount + a.z;
    }
    return result;
}

//----------------------------------------------------------------------------
///<summary>エルミートスプライン補間を行います.</summary>
///<param name="a">入力位置ベクトル</param>
///<param name="t1">入力接ベクトル</param>
///<param name="b">入力位置ベクトル</param>
///<param name="t2">入力接ベクトル</param>
///<param name="amount">重み</param>
///<param name="result">エルミートスプライン補間を行った結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Hermite
(
    const Vector3&  a,
    const Vector3&  t1,
    const Vector3&  b,
    const Vector3&  t2,
    const f32       amount,
    Vector3&        result
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    if ( amount == 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
        result.z = a.z;
    }
    else if ( amount == 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
        result.z = b.z;
    }
    else
    {
        result.x = ( 2.0f * a.x - 2.0f * b.x + t2.x + t1.x ) * c3 + ( 3.0f * b.x - 3.0f * a.x - 2.0f * t1.x - t2.x ) * c3 + t1.x * amount + a.x;
        result.y = ( 2.0f * a.y - 2.0f * b.y + t2.y + t1.y ) * c3 + ( 3.0f * b.y - 3.0f * a.y - 2.0f * t1.y - t2.y ) * c3 + t1.y * amount + a.y;
        result.z = ( 2.0f * a.z - 2.0f * b.z + t2.z + t1.z ) * c3 + ( 3.0f * b.z - 3.0f * a.z - 2.0f * t1.z - t2.z ) * c3 + t1.z * amount + a.z;
    }
}

//----------------------------------------------------------------------------
///<summary>Catmull-Rom補間を行います.</summary>
///<param name="a">補間の最初の位置</param>
///<param name="b">補間の 2 番目の位置</param>
///<param name="c">補間の 3 番目の位置</param>
///<param name="d">補間の 4 番目の位置</param>
///<param name="amount">加重係数</param>
///<return>Catmull-Rom 補間の結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::CatmullRom
(
    const Vector3&  a,
    const Vector3&  b,
    const Vector3&  c,
    const Vector3&  d,
    const f32       amount
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    return Vector3(
        ( 0.5f * ( 2.0f * b.x + ( c.x - a.x ) * amount + ( 2.0f * a.x - 5.0f * b.x + 4.0f * c.x - d.x ) * c2 + ( 3.0f * b.x - a.x - 3.0f * c.x + d.x ) * c3 ) ),
        ( 0.5f * ( 2.0f * b.y + ( c.y - a.y ) * amount + ( 2.0f * a.y - 5.0f * b.y + 4.0f * c.y - d.y ) * c2 + ( 3.0f * b.y - a.y - 3.0f * c.y + d.y ) * c3 ) ),
        ( 0.5f * ( 2.0f * b.z + ( c.z - a.z ) * amount + ( 2.0f * a.z - 5.0f * b.z + 4.0f * c.z - d.z ) * c2 + ( 3.0f * b.z - a.z - 3.0f * c.z + d.z ) * c3 ) )
    );
}

//----------------------------------------------------------------------------
///<summary>Catmull-Rom補間を行います.</summary>
///<param name="a">補間の最初の位置</param>
///<param name="b">補間の 2 番目の位置</param>
///<param name="c">補間の 3 番目の位置</param>
///<param name="d">補間の 4 番目の位置</param>
///<param name="amount">加重係数</param>
///<param name="result">Catmull-Rom 補間の結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Vector3::CatmullRom
(
    const Vector3&  a,
    const Vector3&  b,
    const Vector3&  c,
    const Vector3&  d,
    const f32       amount,
    Vector3&        result
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    result.x = ( 0.5f * ( 2.0f * b.x + ( c.x - a.x ) * amount + ( 2.0f * a.x - 5.0f * b.x + 4.0f * c.x - d.x ) * c2 + ( 3.0f * b.x - a.x - 3.0f * c.x + d.x ) * c3 ) );
    result.y = ( 0.5f * ( 2.0f * b.y + ( c.y - a.y ) * amount + ( 2.0f * a.y - 5.0f * b.y + 4.0f * c.y - d.y ) * c2 + ( 3.0f * b.y - a.y - 3.0f * c.y + d.y ) * c3 ) );
    result.z = ( 0.5f * ( 2.0f * b.z + ( c.z - a.z ) * amount + ( 2.0f * a.z - 5.0f * b.z + 4.0f * c.z - d.z ) * c2 + ( 3.0f * b.z - a.z - 3.0f * c.z + d.z ) * c3 ) );
}

//----------------------------------------------------------------------------
///<summary>線形補間を行います.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="amount">重みを示す 0 ～ 1 の範囲の値</param>
///<return>線形補間の結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Lerp( const Vector3& a, const Vector3& b, const f32 amount )
{
    return Vector3(
        a.x + ( b.x - a.x ) * amount,
        a.y + ( b.y - a.y ) * amount,
        a.z + ( b.z - a.z ) * amount
    );
}

//----------------------------------------------------------------------------
///<summary>線形補間を行います.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="amount">重みを示す 0 ～ 1 の範囲の値</param>
///<param name="result">線形補間の結果を返却します</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Lerp
(
    const Vector3&  a,
    const Vector3&  b,
    const f32       amount,
    Vector3&        result
)
{
    result.x = a.x + ( b.x - a.x ) * amount;
    result.y = a.y + ( b.y - a.y ) * amount;
    result.z = a.z + ( b.z - a.z ) * amount;
}

//----------------------------------------------------------------------------
///<summary>三次方程式を使用して、2 つの値の間を補間します</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="amount">重み</param>
///<return>補間の結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::SmoothStep( const Vector3& a, const Vector3& b, const f32 amount )
{
    register f32 t = asdx::Clamp( amount, 0.0f, 1.0f );
    register Vector3 zero( 0.0f, 0.0f, 0.0f );
    return Hermite( a, zero, b, zero, t );
}

//----------------------------------------------------------------------------
///<summary>三次方程式を使用して、2 つの値の間を補間します</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="amoutn">重み</param>
///<param name="result">補間の結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::SmoothStep
(
    const Vector3&  a,
    const Vector3&  b,
    const f32       amount,
    Vector3&        result
)
{
    register f32 t = asdx::Clamp( amount, 0.0f, 1.0f );
    register Vector3 zero( 0.0f, 0.0f, 0.0f );
    Hermite( a, zero, b, zero, t, result );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いてベクトルを変換します.</summary>
///<param name="position">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>変換されたベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::Transform( const Vector3& position, const Matrix& matrix )
{
    return Vector3(
        ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + ( position.z * matrix._31 ) + matrix._41,
        ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + ( position.z * matrix._32 ) + matrix._42,
        ( position.x * matrix._13 ) + ( position.y * matrix._23 ) + ( position.z * matrix._33 ) + matrix._43
    );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いてベクトルを変換します.</summary>
///<param name="position">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">変換されたベクトルを返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::Transform
(
    const Vector3&  position,
    const Matrix&   matrix,
    Vector3&        result
)
{
    result.x = ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + ( position.z * matrix._31 ) + matrix._41;
    result.y = ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + ( position.z * matrix._32 ) + matrix._42;
    result.z = ( position.x * matrix._13 ) + ( position.y * matrix._23 ) + ( position.z * matrix._33 ) + matrix._43;
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いて法線ベクトルを変換します.</summary>
///<param name="normal">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>変換された法線ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::TransformNormal( const Vector3& normal, const Matrix& matrix )
{
    return Vector3(
        ( normal.x * matrix._11 ) + ( normal.y * matrix._21 ) + ( normal.z * matrix._31 ),
        ( normal.x * matrix._12 ) + ( normal.y * matrix._22 ) + ( normal.z * matrix._32 ),
        ( normal.x * matrix._13 ) + ( normal.y * matrix._23 ) + ( normal.z * matrix._33 )
    );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いて法線ベクトルを変換します.</summary>
///<param name="normal">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">変換された法線ベクトル.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::TransformNormal
(
    const Vector3&  normal,
    const Matrix&   matrix,
    Vector3&        result
)
{
    result.x = ( normal.x * matrix._11 ) + ( normal.y * matrix._21 ) + ( normal.z * matrix._31 );
    result.y = ( normal.x * matrix._12 ) + ( normal.y * matrix._22 ) + ( normal.z * matrix._32 );
    result.z = ( normal.x * matrix._13 ) + ( normal.y * matrix._23 ) + ( normal.z * matrix._33 );
}

//----------------------------------------------------------------------------
///<summary>指定された行列用いてベクトルを変換し，変換結果をw=1に射影します.</summary>
///<param name="coord">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>行列変換後，w=1に射影されたベクトルを返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::TransformCoordinate( const Vector3& coord, const Matrix& matrix )
{
    register f32 X = ( coord.x * matrix._11 ) + ( coord.y * matrix._21 ) + ( coord.z * matrix._31 ) + matrix._41;
    register f32 Y = ( coord.x * matrix._12 ) + ( coord.y * matrix._22 ) + ( coord.z * matrix._32 ) + matrix._42;
    register f32 Z = ( coord.x * matrix._13 ) + ( coord.y * matrix._23 ) + ( coord.z * matrix._33 ) + matrix._43;
    register f32 W = ( coord.x * matrix._14 ) + ( coord.y * matrix._24 ) + ( coord.z * matrix._34 ) + matrix._44;
    assert( W != 0.0f );
    return Vector3(
        X / W,
        Y / W,
        Z / W
    );
}

//----------------------------------------------------------------------------
///<summary>指定された行列用いてベクトルを変換し，変換結果をw=1に射影します.</summary>
///<param name="coord">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">行列変換後，w=1に射影されたベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::TransformCoordinate
(
    const Vector3&  coord,
    const Matrix&   matrix,
    Vector3&        result
)
{
    register f32 X = ( coord.x * matrix._11 ) + ( coord.y * matrix._21 ) + ( coord.z * matrix._31 ) + matrix._41;
    register f32 Y = ( coord.x * matrix._12 ) + ( coord.y * matrix._22 ) + ( coord.z * matrix._32 ) + matrix._42;
    register f32 Z = ( coord.x * matrix._13 ) + ( coord.y * matrix._23 ) + ( coord.z * matrix._33 ) + matrix._43;
    register f32 W = ( coord.x * matrix._14 ) + ( coord.y * matrix._24 ) + ( coord.z * matrix._34 ) + matrix._44;
    assert( W != 0.0f );
    result.x = X / W;
    result.y = Y / W;
    result.z = Z / W;
}

//---------------------------------------------------------------------------
///<summary>法線ベクトルを求めます.</summary>
///<param name="p1">三角形を構成する点.</param>
///<param name="p2">三角形を構成する点.</param>
///<param name="p3">三角形を構成する点.</param>
///<return>法線ベクトルを返却します.</return>
//---------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::ComputeNormal
(
    const Vector3&  p1,
    const Vector3&  p2,
    const Vector3&  p3
)
{
    register Vector3 a( p2.x - p1.x, p2.y - p1.y, p2.z - p1.z );
    register Vector3 b( p3.x - p1.x, p3.y - p1.y, p3.z - p1.z );

    return Vector3(
        ( a.y * b.z ) - ( a.z * b.y ),
        ( a.z * b.x ) - ( a.x * b.z ),
        ( a.x * b.y ) - ( a.y * b.x )
    );
}

//---------------------------------------------------------------------------
///<summary>法線ベクトルを求めます.</summary>
///<param name="p1">三角形を構成する点.</param>
///<param name="p2">三角形を構成する点.</param>
///<param name="p3">三角形を構成する点.</param>
///<param name="result">法線ベクトル</param>
//---------------------------------------------------------------------------
ASDX_INLINE
void     Vector3::ComputeNormal
(
    const Vector3&  p1,
    const Vector3&  p2,
    const Vector3&  p3,
    Vector3&        result
)
{
    register Vector3 a( p2.x - p1.x, p2.y - p1.y, p2.z - p1.z );
    register Vector3 b( p3.x - p1.x, p3.y - p1.y, p3.z - p1.z );

    result.x = ( a.y * b.z ) - ( a.z * b.y );
    result.y = ( a.z * b.x ) - ( a.x * b.z );
    result.z = ( a.x * b.y ) - ( a.y * b.x );
}

//---------------------------------------------------------------------------
///<summary>四角形の法線ベクトルを求めます.</summary>
///<param name="p1">四角形を構成する点.</param>
///<param name="p2">四角形を構成する点.</param>
///<param name="p3">四角形を構成する点.</param>
///<param name="p4">四角形を構成する点.</param>
///<return>法線ベクトルを返却します.</return>
//---------------------------------------------------------------------------
ASDX_INLINE
Vector3  Vector3::ComputeQuadNormal
(
    const Vector3&  p1,
    const Vector3&  p2,
    const Vector3&  p3,
    const Vector3&  p4
)
{
    Vector3 result;
    register Vector3 n1a = ComputeNormal( p1, p2, p3 );
    register Vector3 n1b = ComputeNormal( p1, p3, p4 );
    register Vector3 n2a = ComputeNormal( p2, p3, p4 );
    register Vector3 n2b = ComputeNormal( p2, p4, p1 );
    if ( Vector3::Dot( n1a, n1b ) > Vector3::Dot( n2a, n2b ) )
    {
        result = n1a + n1b;
        result.Normalize();
    }
    else
    {
        result = n2a + n2b;
        result.Normalize();
    }
    return result;
}

//---------------------------------------------------------------------------
///<summary>四角形の法線ベクトルを求めます.</summary>
///<param name="p1">四角形を構成する点.</param>
///<param name="p2">四角形を構成する点.</param>
///<param name="p3">四角形を構成する点.</param>
///<param name="p4">四角形を構成する点.</param>
///<param name="result">法線ベクトル.</param>
//---------------------------------------------------------------------------
ASDX_INLINE
void    Vector3::ComputeQuadNormal
(
    const Vector3&  p1,
    const Vector3&  p2,
    const Vector3&  p3,
    const Vector3&  p4,
    Vector3&        result
)
{
    register Vector3 n1a = ComputeNormal( p1, p2, p3 );
    register Vector3 n1b = ComputeNormal( p1, p3, p4 );
    register Vector3 n2a = ComputeNormal( p2, p3, p4 );
    register Vector3 n2b = ComputeNormal( p2, p4, p1 );
    if ( Vector3::Dot( n1a, n1b ) > Vector3::Dot( n2a, n2b ) )
    {
        result = n1a + n1b;
        result.Normalize();
    }
    else
    {
        result = n2a + n2b;
        result.Normalize();
    }
}

//---------------------------------------------------------------------------
///<summary>スカラー3重積を計算します.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="c">入力ベクトル.</param>
///<return>スカラー3重積の演算結果を返却します.</return>
//---------------------------------------------------------------------------
ASDX_INLINE
f32     Vector3::ScalarTriple
(
    const Vector3& a,
    const Vector3& b,
    const Vector3& c
)
{
    register f32 crossX = ( b.y * c.z ) - ( b.z * c.y );
    register f32 crossY = ( b.z * c.x ) - ( b.x * c.z );
    register f32 crossZ = ( b.x * c.y ) - ( b.y * c.x );

    return ( a.x * crossX ) + ( a.y * crossY ) + ( a.z * crossZ );
}

//---------------------------------------------------------------------------
///<summary>スカラー3重積を計算します.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="c">入力ベクトル.</param>
///<param name="result">スカラー3重積の演算結果.</param>
//---------------------------------------------------------------------------
ASDX_INLINE
void    Vector3::ScalarTriple
(
    const Vector3& a,
    const Vector3& b,
    const Vector3& c,
    f32&           result
)
{
    register f32 crossX = ( b.y * c.z ) - ( b.z * c.y );
    register f32 crossY = ( b.z * c.x ) - ( b.x * c.z );
    register f32 crossZ = ( b.x * c.y ) - ( b.y * c.x );

    result = ( a.x * crossX ) + ( a.y * crossY ) + ( a.z * crossZ );
}

//---------------------------------------------------------------------------
///<summary>ベクトル3重積を計算します.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="c">入力ベクトル.</param>
///<return>ベクトル3重積の演算結果を返却します.</return>
//---------------------------------------------------------------------------
ASDX_INLINE
Vector3 Vector3::VectorTriple
(
    const Vector3& a,
    const Vector3& b,
    const Vector3& c
)
{
    register f32 crossX = ( b.y * c.z ) - ( b.z * c.y );
    register f32 crossY = ( b.z * c.x ) - ( b.x * c.z );
    register f32 crossZ = ( b.x * c.y ) - ( b.y * c.x );

    return Vector3(
        ( ( a.y * crossZ ) - ( a.z * crossY ) ),
        ( ( a.z * crossX ) - ( a.x * crossZ ) ),
        ( ( a.x * crossY ) - ( a.y * crossX ) )
    );
}

//---------------------------------------------------------------------------
///<summary>ベクトル3重積を計算します.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="c">入力ベクトル.</param>
///<param name="result">ベクトル3重積の演算結果.</param>
//---------------------------------------------------------------------------
ASDX_INLINE
void    Vector3::VectorTriple
(
    const Vector3& a,
    const Vector3& b,
    const Vector3& c,
    Vector3&       result
)
{
    register f32 crossX = ( b.y * c.z ) - ( b.z * c.y );
    register f32 crossY = ( b.z * c.x ) - ( b.x * c.z );
    register f32 crossZ = ( b.x * c.y ) - ( b.y * c.x );

    result.x = ( a.y * crossZ ) - ( a.z * crossY );
    result.y = ( a.z * crossX ) - ( a.x * crossZ );
    result.z = ( a.x * crossY ) - ( a.y * crossX );
}


//////////////////////////////////////////////////////////////////////////////
// Vector4 class
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値</param>
///<param name="value">乗算されるベクトル</param>
///<return>乗算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4 operator * ( const f32 scalar, const Vector4& value )
{
    return Vector4(
        value.x * scalar,
        value.y * scalar,
        value.z * scalar,
        value.w * scalar
    );
}

//----------------------------------------------------------------------------
///<summary>コンストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::Vector4()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="pValues">要素数4の配列</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::Vector4( const f32* pValues )
{
    assert( pValues != 0 );
    x = pValues[ 0 ];
    y = pValues[ 1 ];
    z = pValues[ 2 ];
    w = pValues[ 3 ];
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
///<param name="nz">Z成分</param>
///<param name="nw">W成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::Vector4( const f32 nx, const f32 ny, const f32 nz, const f32 nw )
{
    x = nx;
    y = ny;
    z = nz;
    w = nw;
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="value">2次元ベクトル</param>
///<param name="nz">Z成分</param>
///<param name="nw">W成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::Vector4( const Vector2& value, const f32 nz, const f32 nw )
{
    x = value.x;
    y = value.y;
    z = nz;
    w = nw;
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="value">3次元ベクトル</param>
///<param name="nw">W成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::Vector4( const Vector3& value, const f32 nw )
{
    x = value.x;
    y = value.y;
    z = value.z;
    w = nw;
}

//----------------------------------------------------------------------------
///<summary>コピーコンストラクタです.</summary>
///<param name="value">コピー元の値</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::Vector4( const Vector4& value )
{
    x = value.x;
    y = value.y;
    z = value.z;
    w = value.w;
}

//----------------------------------------------------------------------------
///<summary>デストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::~Vector4()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>f32ポインタ型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::operator f32* () 
{ return &x; }

//----------------------------------------------------------------------------
///<summary>const f32ポインタ型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4::operator const f32* () const
{ return &x; }

//----------------------------------------------------------------------------
///<summary>加算代入演算子です.</summary>
///<param name="value">加算する値</param>
///<return>加算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::operator += ( const Vector4& value )
{
    x += value.x;
    y += value.y;
    z += value.z;
    w += value.w;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>減算代入演算子です.</summary>
///<param name="value">減算する値</param>
///<return>減算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::operator -= ( const Vector4& value )
{
    x -= value.x;
    y -= value.y;
    z -= value.z;
    w -= value.w;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="scalar">乗算するスカラー値</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::operator *= ( const f32 scalar )
{
    x *= scalar;
    y *= scalar;
    z *= scalar;
    w *= scalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>除算代入演算子です.</summary>
///<param name="scalar">除算するスカラー値</param>
///<return>除算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::operator /= ( const f32 scalar )
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    x *= invScalar;
    y *= invScalar;
    z *= invScalar;
    w *= invScalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>正符号演算子です.</summary>
///<return>自分自身の値を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::operator + () const
{ return (*this); }

//----------------------------------------------------------------------------
///<summary>負符号演算子です.</summary>
///<return>マイナスにした値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::operator - () const
{ return Vector4( -x, -y, -z, -w); }

//----------------------------------------------------------------------------
///<summary>加算演算子です.</summary>
///<param name="value">加算する値.</param>
///<return>加算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::operator + ( const Vector4& value ) const
{
    return Vector4( 
        x + value.x,
        y + value.y,
        z + value.z,
        w + value.w
    );
}

//----------------------------------------------------------------------------
///<summary>減算演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::operator - ( const Vector4& value ) const
{
    return Vector4(
        x - value.x,
        y - value.y,
        z - value.z,
        w - value.w 
    );
}

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<return>スカラー乗算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::operator * ( const f32 scalar ) const
{
    return Vector4(
        x * scalar,
        y * scalar,
        z * scalar,
        w * scalar 
    );
}

//----------------------------------------------------------------------------
///<summary>除算演算子です.</summary>
///<param name="scalar">除算するスカラー値.</param>
///<return>スカラー除算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::operator / ( const f32 scalar ) const
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    return Vector4(
        x * invScalar,
        y * invScalar,
        z * invScalar,
        w * invScalar 
    );
}

//----------------------------------------------------------------------------
///<summary>等価演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が等価であればtrue,そうでなければfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Vector4::operator == ( const Vector4& value ) const
{
    return ( x == value.x )
        && ( y == value.y )
        && ( z == value.z )
        && ( w == value.w );
}

//----------------------------------------------------------------------------
///<summary>非等価演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が非等価であればtrue，そうでなければfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Vector4::operator != ( const Vector4& value ) const
{
    return ( x != value.x )
        || ( y != value.y )
        || ( z != value.z )
        || ( w != value.w );
}

//----------------------------------------------------------------------------
///<summary>代入演算子です.</summary>
///<param name="value">代入する値.</param>
///<return>代入結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::operator = ( const Vector4& value )
{
    x = value.x;
    y = value.y;
    z = value.z;
    w = value.w;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルの長さを求めます.</summary>
///<return>ベクトルの長さを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector4::Length() const
{
    return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの長さの2乗値を求めます.</summary>
///<return>ベクトルの長さの2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector4::LengthSq() const
{
    return ( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
}

//----------------------------------------------------------------------------
///<summary>単位ベクトルを求めます.</summary>
///<return>単位ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4     Vector4::UnitVector() const
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    return Vector4(
        x * invMag,
        y * invMag,
        z * invMag,
        w * invMag
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<return>ベクトルを正規化した結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::Normalize()
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    x *= invMag;
    y *= invMag;
    z *= invMag;
    w *= invMag;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルを安全に正規化します.</summary>
///<param name="value">長さが0の場合に設定する値.</param>
///<return>ベクトルの長さが0の場合はvalueを返却,そうでないときは正規化した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4&    Vector4::SafeNormalize( const Vector4& v ) 
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    if ( mag > 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        x *= invMag;
        y *= invMag;
        z *= invMag;
        w *= invMag;
    }
    else
    {
        x = v.x;
        y = v.y;
        z = v.z;
        w = v.w;
    }
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="value">入力ベクトル</param>
///<return>ベクトルの内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Vector4::Dot( const Vector4& value ) const
{ return ( x * value.x ) + ( y * value.y ) + ( z * value.z ) + ( w * value.w ); }

//----------------------------------------------------------------------------
///<summary>各成分の値を設定します.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
///<param name="nz">Z成分</param>
///<param name="nw">W成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void        Vector4::Set( const f32 nx, const f32 ny, const f32 nz, const f32 nw )
{
    x = nx;
    y = ny;
    z = nz;
    w = nw;
}


//////////////////////////////////////////////////////////////////////////////
// Vector4 Methods
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>各成分の絶対値を求めます.</summary>
///<param name="value">絶対値を求める値</param>
///<return>各成分の絶対値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Abs( const Vector4& value )
{
    return Vector4(
        fabs( value.x ),
        fabs( value.y ),
        fabs( value.z ),
        fabs( value.w )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の絶対値を求めます.</summary>
///<param name="value">絶対値を求める値</param>
///<param name="result">計算結果の格納先</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Abs( const Vector4& value, Vector4& result )
{
    result.x = fabs( value.x );
    result.y = fabs( value.y );
    result.z = fabs( value.z );
    result.w = fabs( value.w );
}

//----------------------------------------------------------------------------
///<summary>各成分の最小値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<return>各成分の最小値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Min( const Vector4& a, const Vector4& b )
{
    return Vector4(
        (( a.x < b.x ) ? a.x : b.x ),
        (( a.y < b.y ) ? a.y : b.y ),
        (( a.z < b.z ) ? a.z : b.z ),
        (( a.w < b.w ) ? a.w : b.w )
    );
}

//----------------------------------------------------------------------------
///<summary>各成分の最小値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<param name="result">各成分の最小値を求めた結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Min( const Vector4& a, const Vector4& b, Vector4& result )
{
    result.x = ( a.x < b.x ) ? a.x : b.x;
    result.y = ( a.y < b.y ) ? a.y : b.y;
    result.z = ( a.z < b.z ) ? a.z : b.z;
    result.w = ( a.w < b.w ) ? a.w : b.w;
}

//----------------------------------------------------------------------------
///<summary>各成分の最大値を求めます.</summary>
///<param name="a">比較する値</param>
///<param name="b">比較する値</param>
///<return>各成分の最大値を求め，その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Max( const Vector4& a, const Vector4& b )
{
    return Vector4(
        (( a.x > b.x ) ? a.x : b.x ),
        (( a.y > b.y ) ? a.y : b.y ),
        (( a.z > b.z ) ? a.z : b.z ),
        (( a.w > b.w ) ? a.w : b.w )
    );
}

//----------------------------------------------------------------------------
///<summary>値を指定された範囲内に制限します.</summary>
///<param name="value">クランプする値.</param>
///<param name="a">最小値.</param>
///<param name="b">最大値.</param>
///<return>クランプされた値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Clamp( const Vector4& value, const Vector4& a, const Vector4& b )
{
    register f32 minX = ( b.x < value.x ) ? b.x : value.x;
    register f32 minY = ( b.y < value.y ) ? b.y : value.y;
    register f32 minZ = ( b.z < value.z ) ? b.z : value.z;
    register f32 minW = ( b.w < value.w ) ? b.w : value.w;

    return Vector4(
        (( a.x > minX ) ? a.x : minX ),
        (( a.x > minY ) ? a.y : minY ),
        (( a.z > minZ ) ? a.z : minZ ),
        (( a.w > minW ) ? a.w : minW )
    );
}

//----------------------------------------------------------------------------
///<summary>値を指定された範囲内に制限します.</summary>
///<param name="value">クランプする値.</param>
///<param name="a">最小値.</param>
///<param name="b">最大値.</param>
///<param name="result">クランプされた値</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Clamp
(
    const Vector4&  value,
    const Vector4&  a,
    const Vector4&  b,
    Vector4&        result
)
{
    result.x = ( b.x < value.x ) ? b.x : value.x;
    result.y = ( b.y < value.y ) ? b.y : value.y;
    result.z = ( b.z < value.z ) ? b.z : value.z;
    result.w = ( b.w < value.w ) ? b.w : value.w;

    result.x = ( a.x > result.x ) ? a.x : result.x;
    result.y = ( a.y > result.y ) ? a.y : result.y;
    result.z = ( a.z > result.z ) ? a.z : result.z;
    result.w = ( a.w > result.w ) ? a.w : result.w;
}

//----------------------------------------------------------------------------
///<summary>指定された値を0～1の範囲に制限します.</summary>
///<param name="value">クランプする値</param>
///<return>クランプされた値</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Saturate( const Vector4& value )
{
    register f32 minX = ( 1.0f < value.x ) ? 1.0f : value.x;
    register f32 minY = ( 1.0f < value.y ) ? 1.0f : value.y;
    register f32 minZ = ( 1.0f < value.z ) ? 1.0f : value.z;
    register f32 minW = ( 1.0f < value.w ) ? 1.0f : value.w;

    return Vector4(
        (( 0.0f > minX ) ? 0.0f : minX ),
        (( 0.0f > minY ) ? 0.0f : minY ),
        (( 0.0f > minZ ) ? 0.0f : minZ ),
        (( 0.0f > minW ) ? 0.0f : minW )
    );
}

//----------------------------------------------------------------------------
///<summary>指定された値を0～1の範囲に制限します.</summary>
///<param name="value">クランプする値</param>
///<return>クランプされた値</return>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Saturate( const Vector4& value, Vector4& result )
{
    result.x = ( 1.0f < value.x ) ? 1.0f : value.x;
    result.y = ( 1.0f < value.y ) ? 1.0f : value.y;
    result.z = ( 1.0f < value.z ) ? 1.0f : value.z;
    result.w = ( 1.0f < value.w ) ? 1.0f : value.w;

    result.x = ( 0.0f > value.x ) ? 0.0f : result.x;
    result.y = ( 0.0f > value.y ) ? 0.0f : result.y;
    result.z = ( 0.0f > value.z ) ? 0.0f : result.z;
    result.w = ( 0.0f > value.w ) ? 0.0f : result.w;
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトル間の距離を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector4::Distance( const Vector4& a, const Vector4& b )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    register f32 difW = ( b.w - a.w );
    return sqrtf( ( difX * difX ) + ( difY * difY ) + ( difZ * difZ ) + ( difW * difW ) );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトル間の距離</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Distance( const Vector4& a, const Vector4&b, f32& result )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    register f32 difW = ( b.w - a.w );
    result = sqrtf( ( difX * difX ) + ( difY * difY ) + ( difZ * difZ ) + ( difW * difW ) );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離の2乗値を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトル間の距離の2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector4::DistanceSq( const Vector4& a, const Vector4& b )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    register f32 difW = ( b.w - a.w );
    return ( difX * difX ) + ( difY * difY ) + ( difZ * difZ ) + ( difW * difW );
}

//----------------------------------------------------------------------------
///<summary>2つのベクトル間の距離の2乗値を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::DistanceSq( const Vector4& a, const Vector4& b, f32& result )
{
    register f32 difX = ( b.x - a.x );
    register f32 difY = ( b.y - a.y );
    register f32 difZ = ( b.z - a.z );
    register f32 difW = ( b.w - a.w );
    result = ( difX * difX ) + ( difY * difY ) + ( difZ * difZ ) + ( difW * difW );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>ベクトルの内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector4::Dot( const Vector4& a, const Vector4& b )
{
    return ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w );
}

//----------------------------------------------------------------------------
///<summary>ベクトルの内積を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">ベクトルの内積</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Dot( const Vector4& a, const Vector4& b, f32& result )
{
    result = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z *  b.z ) + ( a.w * b.w );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<param name="value">正規化するベクトル</param>
///<return>正規化したベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Normalize( const Vector4& value )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y ) 
                            + ( value.z * value.z )
                            + ( value.w * value.w ) );
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    return Vector4(
        value.x * invMag,
        value.y * invMag,
        value.z * invMag,
        value.w * invMag
    );
}

//----------------------------------------------------------------------------
///<summary>ベクトルを正規化します.</summary>
///<param name="value">正規化するベクトル</param>
///<param name="result">正規化されたベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Normalize( const Vector4& value, Vector4& result )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ));
    assert( mag > 0.0f );
    register f32 invMag = 1.0f / mag;
    result.x = value.x * invMag;
    result.y = value.y * invMag;
    result.z = value.z * invMag;
    result.w = value.w * invMag;
}

//----------------------------------------------------------------------------
///<summary>ベクトルの正規化を試みます.</summary>
///<param name="value">正規化するベクトル</param>
///<param name="set">長さが0の場合に設定するベクトル</param>
///<return>ベクトルの長さが0でなければ正規化されたベクトル，長さが0の場合はsetを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::SafeNormalize( const Vector4& value, const Vector4& set )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ));
    if ( mag > 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        return Vector4(
            value.x * invMag,
            value.y * invMag,
            value.z * invMag,
            value.w * invMag
        );
    }
    else
    {
        return Vector4(
            set.x,
            set.y,
            set.z,
            set.w
        );
    }
}

//----------------------------------------------------------------------------
///<summary>ベクトルの正規化を試みます.</summary>
///<param name="value">正規化するベクトル.</param>
///<param name="set">長さが0の場合に設定するベクトル</param>
///<param name="result">ベクトルの長さが0でなければ正規化されたベクトル，長さが0の場合はset</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::SafeNormalize
(
    const Vector4&  value,
    const Vector4&  set,
    Vector4&        result
)
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ));
    if ( mag > 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        result.x = value.x * invMag;
        result.y = value.y * invMag;
        result.z = value.z * invMag;
        result.w = value.w * invMag;
    }
    else
    {
        result.x = set.x;
        result.y = set.y;
        result.z = set.z;
        result.w = set.w;
    }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(ラジアン)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector4::ComputeCrossingAngleRad( const Vector4& a, const Vector4& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) + ( a.w * a.w ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) + ( b.w * b.w ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w ) ) / d;
        if ( c >= 1.0f )
        { return 0.0f; }

        if ( c <= -1.0f )
        { return F_PI; }

        return acosf( c );
    }
    else
    { return 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(ラジアン)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::ComputeCrossingAngleRad
(
    const Vector4&  a,
    const Vector4&  b,
    f32&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) + ( a.w * a.w ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) + ( b.w * b.w ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0.0f;
            return;
        }

        if ( c <= -1.0f )
        {
            result = F_PI;
            return;
        }

        result = acosf( c );
    }
    else
    { result = 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(度)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32      Vector4::ComputeCrossingAngleDeg( const Vector4& a, const Vector4& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) + ( a.w * a.w ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) + ( b.w * b.w ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w ) ) / d;
        if ( c >= 1.0f )
        { return 0.0f; }

        if ( c <= -1.0f )
        { return 180.0f; }

        return ASDX_RAD_TO_DEG( acosf( c ) );
    }
    else
    { return 0.0f; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(度)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::ComputeCrossingAngleDeg
(
    const Vector4&  a,
    const Vector4&  b,
    f32&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) + ( a.w * a.w ) ) 
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) + ( b.w * b.w ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0.0f;
            return;
        }

        if ( c <= -1.0f )
        {
            result = 180.0f;
            return;
        }

        result = ASDX_RAD_TO_DEG( acosf( c ) );
    }
    else
    { result = 0.0f; }
}


//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<return>2つのベクトルの交差角(インデックス角)を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
u16      Vector4::ComputeCrossingAngleIdx( const Vector4& a, const Vector4& b )
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) + ( a.w * a.w ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) + ( b.w * b.w ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w ) ) / d;
        if ( c >= 1.0f )
        { return 0; }

        if ( c <= -1.0f )
        { return 32768; }

        return ASDX_RAD_TO_IDX( acosf( c ) );
    }
    else
    { return 0; }
}

//----------------------------------------------------------------------------
///<summary>2つのベクトルの交差角を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="result">2つのベクトルの交差角(インデックス角)を返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::ComputeCrossingAngleIdx
( 
    const Vector4&  a,
    const Vector4&  b,
    u16&            result
)
{
    register f32 d = sqrtf( ( a.x * a.x ) + ( a.y * a.y ) + ( a.z * a.z ) + ( a.w * a.w ) )
                   * sqrtf( ( b.x * b.x ) + ( b.y * b.y ) + ( b.z * b.z ) + ( b.w * b.w ) );
    if ( d > 0.0f )
    {
        register f32 c = ( ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w ) ) / d;
        if ( c >= 1.0f )
        {
            result = 0;
            return;
        }

        if ( c <= -1.0f )
        {
            result = 32768;
            return;
        }

        result = ASDX_RAD_TO_IDX( acosf( c ) );
    }
    else
    { result = 0; }
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルから、反射ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<return>反射ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Reflect( const Vector4& i, const Vector4& n )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
    return Vector4(
        i.x - ( 2.0f * n.x ) * dot,
        i.y - ( 2.0f * n.y ) * dot,
        i.z - ( 2.0f * n.z ) * dot,
        i.w - ( 2.0f * n.w ) * dot
    );
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルから、反射ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="result">反射ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Reflect( const Vector4& i, const Vector4& n, Vector4& result )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
    result.x = i.x - ( 2.0f * n.x ) * dot;
    result.y = i.y - ( 2.0f * n.y ) * dot;
    result.z = i.z - ( 2.0f * n.z ) * dot;
    result.w = i.w - ( 2.0f * n.w ) * dot;
}


//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルと屈折率から、屈折ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="eta">屈折率</param>
///<return>屈折ベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Refract( const Vector4& i, const Vector4& n, f32 eta )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
    register f32 k = 1.0f - eta * eta * ( 1.0f - dot * dot );
    if ( k < 0.f )
    {
        return Vector4( 0.0f, 0.0f, 0.0f, 0.0f );
    }
    register f32 sqrtK = sqrtf(k); 
    return Vector4(
        eta * i.x - ( eta * dot + sqrtK ) * n.x,
        eta * i.y - ( eta * dot + sqrtK ) * n.y,
        eta * i.z - ( eta * dot + sqrtK ) * n.z,
        eta * i.w - ( eta * dot + sqrtK ) * n.w
    );
}

//----------------------------------------------------------------------------
///<summary>指定された法線を持つ表面への入射ベクトルと屈折率から、屈折ベクトルを求めます.</summary>
///<param name="i">入射ベクトル</param>
///<param name="n">法線ベクトル</param>
///<param name="eta">屈折率</param>
///<param name="result">屈折ベクトル</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Refract( const Vector4& i, const Vector4& n, f32 eta, Vector4& result )
{
    register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
    register f32 k = 1.0f - eta * eta * ( 1.0f - dot * dot );
    if ( k < 0.f )
    {
        result.x = 0.0f;
        result.y = 0.0f;
        result.z = 0.0f;
        result.w = 0.0f;
        return;
    }
    register f32 sqrtK = sqrtf(k); 
    result.x = eta * i.x - ( eta * dot + sqrtK ) * n.x;
    result.y = eta * i.y - ( eta * dot + sqrtK ) * n.y;
    result.z = eta * i.z - ( eta * dot + sqrtK ) * n.z;
    result.w = eta * i.w - ( eta * dot + sqrtK ) * n.w;
}

//----------------------------------------------------------------------------
///<summary>重心座標上の点を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="c">入力ベクトル</param>
///<param name="amount1">重み</param>
///<param name="amount2">重み</param>
///<return>重心座標上の点を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Barycentric
(
    const Vector4&  a,
    const Vector4&  b,
    const Vector4&  c,
    const f32       amount1,
    const f32       amount2
)
{
    return Vector4(
        a.x + ( b.x - a.x ) * amount1 + ( c.x - a.x ) * amount2,
        a.y + ( b.y - a.y ) * amount1 + ( c.y - a.y ) * amount2,
        a.z + ( b.z - a.z ) * amount1 + ( c.z - a.z ) * amount2,
        a.w + ( b.w - a.w ) * amount1 + ( c.w - a.w ) * amount2 
    );
}

//----------------------------------------------------------------------------
///<summary>重心座標上の点を求めます.</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="c">入力ベクトル</param>
///<param name="amount1">重み</param>
///<param name="amount2">重み</param>
///<param name="result">重心座標上の点</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Barycentric
(
    const Vector4&  a,
    const Vector4&  b,
    const Vector4&  c,
    const f32       amount1,
    const f32       amount2,
    Vector4&        result
)
{
    result.x = a.x + ( b.x - a.x ) * amount1 + ( c.x - a.x ) * amount2;
    result.y = a.y + ( b.y - a.y ) * amount1 + ( c.y - a.y ) * amount2;
    result.z = a.z + ( b.z - a.z ) * amount1 + ( c.z - a.z ) * amount2;
    result.w = a.w + ( b.w - a.w ) * amount1 + ( c.w - a.w ) * amount2;
}

//----------------------------------------------------------------------------
///<summary>エルミートスプライン補間を行います.</summary>
///<param name="a">入力位置ベクトル</param>
///<param name="t1">入力接ベクトル</param>
///<param name="b">入力位置ベクトル</param>
///<param name="t2">入力接ベクトル</param>
///<param name="amount">重み</param>
///<return>エルミートスプライン補間を行った結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Hermite
(
    const Vector4&  a,
    const Vector4&  t1,
    const Vector4&  b,
    const Vector4&  t2,
    const f32       amount
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    Vector4 result;
    if ( amount == 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
        result.z = a.z;
        result.w = a.w;
    }
    else if ( amount == 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
        result.z = b.z;
        result.w = b.w;
    }
    else
    {
        result.x = ( 2.0f * a.x - 2.0f * b.x + t2.x + t1.x ) * c3 + ( 3.0f * b.x - 3.0f * a.x - 2.0f * t1.x - t2.x ) * c3 + t1.x * amount + a.x;
        result.y = ( 2.0f * a.y - 2.0f * b.y + t2.y + t1.y ) * c3 + ( 3.0f * b.y - 3.0f * a.y - 2.0f * t1.y - t2.y ) * c3 + t1.y * amount + a.y;
        result.z = ( 2.0f * a.z - 2.0f * b.z + t2.z + t1.z ) * c3 + ( 3.0f * b.z - 3.0f * a.z - 2.0f * t1.z - t2.z ) * c3 + t1.z * amount + a.z;
        result.w = ( 2.0f * a.w - 2.0f * b.w + t2.w + t1.w ) * c3 + ( 3.0f * b.w - 3.0f * a.w - 2.0f * t1.w - t2.w ) * c3 + t1.w * amount + a.w;
    }
    return result;
}

//----------------------------------------------------------------------------
///<summary>エルミートスプライン補間を行います.</summary>
///<param name="a">入力位置ベクトル</param>
///<param name="t1">入力接ベクトル</param>
///<param name="b">入力位置ベクトル</param>
///<param name="t2">入力接ベクトル</param>
///<param name="amount">重み</param>
///<param name="result">エルミートスプライン補間を行った結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Hermite
(
    const Vector4&  a,
    const Vector4&  t1,
    const Vector4&  b,
    const Vector4&  t2,
    const f32       amount,
    Vector4&        result
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    if ( amount == 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
        result.z = a.z;
        result.w = a.w;
    }
    else if ( amount == 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
        result.z = b.z;
        result.w = b.w;
    }
    else
    {
        result.x = ( 2.0f * a.x - 2.0f * b.x + t2.x + t1.x ) * c3 + ( 3.0f * b.x - 3.0f * a.x - 2.0f * t1.x - t2.x ) * c3 + t1.x * amount + a.x;
        result.y = ( 2.0f * a.y - 2.0f * b.y + t2.y + t1.y ) * c3 + ( 3.0f * b.y - 3.0f * a.y - 2.0f * t1.y - t2.y ) * c3 + t1.y * amount + a.y;
        result.z = ( 2.0f * a.z - 2.0f * b.z + t2.z + t1.z ) * c3 + ( 3.0f * b.z - 3.0f * a.z - 2.0f * t1.z - t2.z ) * c3 + t1.z * amount + a.z;
        result.w = ( 2.0f * a.w - 2.0f * b.w + t2.w + t1.w ) * c3 + ( 3.0f * b.w - 3.0f * a.w - 2.0f * t1.w - t2.w ) * c3 + t1.w * amount + a.w;
    }
}

//----------------------------------------------------------------------------
///<summary>Catmull-Rom補間を行います.</summary>
///<param name="a">補間の最初の位置</param>
///<param name="b">補間の 2 番目の位置</param>
///<param name="c">補間の 3 番目の位置</param>
///<param name="d">補間の 4 番目の位置</param>
///<param name="amount">加重係数</param>
///<return>Catmull-Rom 補間の結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::CatmullRom
(
    const Vector4&  a,
    const Vector4&  b,
    const Vector4&  c,
    const Vector4&  d,
    const f32       amount
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    return Vector4(
        ( 0.5f * ( 2.0f * b.x + ( c.x - a.x ) * amount + ( 2.0f * a.x - 5.0f * b.x + 4.0f * c.x - d.x ) * c2 + ( 3.0f * b.x - a.x - 3.0f * c.x + d.x ) * c3 ) ),
        ( 0.5f * ( 2.0f * b.y + ( c.y - a.y ) * amount + ( 2.0f * a.y - 5.0f * b.y + 4.0f * c.y - d.y ) * c2 + ( 3.0f * b.y - a.y - 3.0f * c.y + d.y ) * c3 ) ),
        ( 0.5f * ( 2.0f * b.z + ( c.z - a.z ) * amount + ( 2.0f * a.z - 5.0f * b.z + 4.0f * c.z - d.z ) * c2 + ( 3.0f * b.z - a.z - 3.0f * c.z + d.z ) * c3 ) ),
        ( 0.5f * ( 2.0f * b.w + ( c.w - a.w ) * amount + ( 2.0f * a.w - 5.0f * b.w + 4.0f * c.w - d.w ) * c2 + ( 3.0f * b.w - a.w - 3.0f * c.w + d.w ) * c3 ) )
    );
}

//----------------------------------------------------------------------------
///<summary>Catmull-Rom補間を行います.</summary>
///<param name="a">補間の最初の位置</param>
///<param name="b">補間の 2 番目の位置</param>
///<param name="c">補間の 3 番目の位置</param>
///<param name="d">補間の 4 番目の位置</param>
///<param name="amount">加重係数</param>
///<param name="result">Catmull-Rom 補間の結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Vector4::CatmullRom
(
    const Vector4&  a,
    const Vector4&  b,
    const Vector4&  c,
    const Vector4&  d,
    const f32       amount,
    Vector4&        result
)
{
    register f32 c2 = amount * amount;
    register f32 c3 = c2 * amount;

    result.x = ( 0.5f * ( 2.0f * b.x + ( c.x - a.x ) * amount + ( 2.0f * a.x - 5.0f * b.x + 4.0f * c.x - d.x ) * c2 + ( 3.0f * b.x - a.x - 3.0f * c.x + d.x ) * c3 ) );
    result.y = ( 0.5f * ( 2.0f * b.y + ( c.y - a.y ) * amount + ( 2.0f * a.y - 5.0f * b.y + 4.0f * c.y - d.y ) * c2 + ( 3.0f * b.y - a.y - 3.0f * c.y + d.y ) * c3 ) );
    result.z = ( 0.5f * ( 2.0f * b.z + ( c.z - a.z ) * amount + ( 2.0f * a.z - 5.0f * b.z + 4.0f * c.z - d.z ) * c2 + ( 3.0f * b.z - a.z - 3.0f * c.z + d.z ) * c3 ) );
    result.w = ( 0.5f * ( 2.0f * b.w + ( c.w - a.w ) * amount + ( 2.0f * a.w - 5.0f * b.w + 4.0f * c.w - d.w ) * c2 + ( 3.0f * b.w - a.w - 3.0f * c.w + d.w ) * c3 ) );
}

//----------------------------------------------------------------------------
///<summary>線形補間を行います.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="amount">重みを示す 0 ～ 1 の範囲の値</param>
///<return>線形補間の結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Lerp( const Vector4& a, const Vector4& b, const f32 amount )
{
    return Vector4(
        a.x + ( b.x - a.x ) * amount,
        a.y + ( b.y - a.y ) * amount,
        a.z + ( b.z - a.z ) * amount,
        a.w + ( b.w - a.w ) * amount
    );
}

//----------------------------------------------------------------------------
///<summary>線形補間を行います.</summary>
///<param name="a">入力ベクトル.</param>
///<param name="b">入力ベクトル.</param>
///<param name="amount">重みを示す 0 ～ 1 の範囲の値</param>
///<param name="result">線形補間の結果を返却します</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Lerp
(
    const Vector4&  a,
    const Vector4&  b,
    const f32       amount,
    Vector4&        result
)
{
    result.x = a.x + ( b.x - a.x ) * amount;
    result.y = a.y + ( b.y - a.y ) * amount;
    result.z = a.z + ( b.z - a.z ) * amount;
    result.w = a.w + ( b.w - a.w ) * amount;
}

//----------------------------------------------------------------------------
///<summary>三次方程式を使用して、2 つの値の間を補間します</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="amount">重み</param>
///<return>補間の結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::SmoothStep( const Vector4& a, const Vector4& b, const f32 amount )
{
    register f32 t = asdx::Clamp( amount, 0.0f, 1.0f );
    register Vector4 zero( 0.0f, 0.0f, 0.0f, 0.0f );
    return Hermite( a, zero, b, zero, t );
}

//----------------------------------------------------------------------------
///<summary>三次方程式を使用して、2 つの値の間を補間します</summary>
///<param name="a">入力ベクトル</param>
///<param name="b">入力ベクトル</param>
///<param name="amoutn">重み</param>
///<param name="result">補間の結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::SmoothStep
(
    const Vector4&  a,
    const Vector4&  b,
    const f32       amount,
    Vector4&        result
)
{
    register f32 t = asdx::Clamp( amount, 0.0f, 1.0f );
    register Vector4 zero( 0.0f, 0.0f, 0.0f, 0.0f );
    Hermite( a, zero, b, zero, t, result );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いてベクトルを変換します.</summary>
///<param name="position">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<return>変換されたベクトルを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Vector4  Vector4::Transform( const Vector4& position, const Matrix& matrix )
{
    return Vector4(
        ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + ( position.z * matrix._31 ) + ( position.w * matrix._41 ),
        ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + ( position.z * matrix._32 ) + ( position.w * matrix._42 ),
        ( position.x * matrix._13 ) + ( position.y * matrix._23 ) + ( position.z * matrix._33 ) + ( position.w * matrix._43 ),
        ( position.x * matrix._14 ) + ( position.y * matrix._24 ) + ( position.z * matrix._34 ) + ( position.w * matrix._44 )
    );
}

//----------------------------------------------------------------------------
///<summary>指定された行列を用いてベクトルを変換します.</summary>
///<param name="position">入力ベクトル</param>
///<param name="matrix">変換行列</param>
///<param name="result">変換されたベクトルを返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void     Vector4::Transform
(
    const Vector4&  position,
    const Matrix&   matrix,
    Vector4&        result
)
{
    result.x = ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + ( position.z * matrix._31 ) + ( position.w * matrix._41 );
    result.y = ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + ( position.z * matrix._32 ) + ( position.w * matrix._42 );
    result.z = ( position.x * matrix._13 ) + ( position.y * matrix._23 ) + ( position.z * matrix._33 ) + ( position.w * matrix._43 );
    result.w = ( position.x * matrix._14 ) + ( position.y * matrix._24 ) + ( position.z * matrix._34 ) + ( position.w * matrix._44 );
}



//////////////////////////////////////////////////////////////////////////////
// Matrix class
//////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<param name="value">乗算される行列.</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix operator * ( const f32 scalar, const Matrix& value )
{
    return Matrix(
        value._11 * scalar,
        value._12 * scalar,
        value._13 * scalar,
        value._14 * scalar,

        value._21 * scalar,
        value._22 * scalar,
        value._23 * scalar,
        value._24 * scalar,

        value._31 * scalar,
        value._32 * scalar,
        value._33 * scalar,
        value._34 * scalar,

        value._41 * scalar,
        value._42 * scalar,
        value._43 * scalar,
        value._44 * scalar
    );
}

//------------------------------------------------------------------------------
///<summary>コンストラクタです.</summary>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::Matrix()
{ /* DO_NOTHING */ }

//------------------------------------------------------------------------------
///<summary>引数付きコンストラクタです</summary>
///<param name="pValues">要素数16の配列</param>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::Matrix( const f32* pValues )
{
    assert( pValues != 0 );
    memcpy( m, pValues, sizeof( f32 ) * 16 );
}

//------------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="m11">1行1列の値.</param>
///<param name="m12">1行2列の値.</param>
///<param name="m13">1行3列の値.</param>
///<param name="m14">1行4列の値.</param>
///<param name="m21">2行1列の値.</param>
///<param name="m22">2行2列の値.</param>
///<param name="m23">2行3列の値.</param>
///<param name="m24">2行4列の値.</param>
///<param name="m31">3行1列の値.</param>
///<param name="m32">3行2列の値.</param>
///<param name="m33">3行3列の値.</param>
///<param name="m34">3行4列の値.</param>
///<param name="m41">4行1列の値.</param>
///<param name="m42">4行2列の値.</param>
///<param name="m43">4行3列の値.</param>
///<param name="m44">4行4列の値.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::Matrix
(
    const f32 m11,
    const f32 m12,
    const f32 m13,
    const f32 m14,

    const f32 m21,
    const f32 m22,
    const f32 m23,
    const f32 m24,

    const f32 m31,
    const f32 m32,
    const f32 m33,
    const f32 m34,
    
    const f32 m41,
    const f32 m42,
    const f32 m43,
    const f32 m44
)
{
    _11 = m11;
    _12 = m12;
    _13 = m13;
    _14 = m14;

    _21 = m21;
    _22 = m22;
    _23 = m23;
    _24 = m24;

    _31 = m31;
    _32 = m32;
    _33 = m33;
    _34 = m34;

    _41 = m41;
    _42 = m42;
    _43 = m43;
    _44 = m44;
}

//------------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="v0">1行目に設定する値.</param>
///<param name="v1">2行目に設定する値.</param>
///<param name="v2">3行目に設定する値.</param>
///<param name="v3">4行目に設定する値.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::Matrix
(
    const Vector4& v0,
    const Vector4& v1,
    const Vector4& v2,
    const Vector4& v3
)
{
    v[ 0 ].x = v0.x;
    v[ 0 ].y = v0.y;
    v[ 0 ].z = v0.z;
    v[ 0 ].w = v0.w;

    v[ 1 ].x = v1.x;
    v[ 1 ].y = v1.y;
    v[ 1 ].z = v1.z;
    v[ 1 ].w = v1.w;

    v[ 2 ].x = v2.x;
    v[ 2 ].y = v2.y;
    v[ 2 ].z = v2.z;
    v[ 2 ].w = v2.w;

    v[ 3 ].x = v3.x;
    v[ 3 ].y = v3.y;
    v[ 3 ].z = v3.z;
    v[ 3 ].w = v3.w;
}

//------------------------------------------------------------------------------
///<summary>コピーコンストラクタです.</summary>
///<param name="value">コピー元の値.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::Matrix( const Matrix& value )
{ memcpy( m, value.m, sizeof( f32 ) * 16 ); }

//------------------------------------------------------------------------------
///<summary>デストラクタです.</summary>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::~Matrix()
{ /* DO_NOTHING */ }

//------------------------------------------------------------------------------
///<summary>f32*型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::operator f32* ()
{ return &_11; }

//------------------------------------------------------------------------------
///<summary>const f32*型への演算子です.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix::operator const f32* () const
{ return &_11; }

//------------------------------------------------------------------------------
///<summary>インデクサです.</summary>
///<param name="row">行番号</param>
///<param name="col">列番号</param>
///<return>指定された行番号と列番号に対応する要素を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
f32&    Matrix::operator() ( u32 row, u32 col )
{ return m[ row ][ col ]; }

//------------------------------------------------------------------------------
///<summary>インデクサです(const版>.</summary>
///<param name="row">行番号</param>
///<param name="col">列番号</param>
///<return>指定された行番号と列番号に対応する要素を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
const f32&     Matrix::operator() ( u32 row, u32 col ) const
{ return m[ row ][ col ]; }

//------------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="value">乗算する行列.</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix& Matrix::operator *= ( const Matrix& value )
{
    f32 tmp[ 16 ];
    tmp[  0 ] = ( _11 * value._11 ) + ( _12 * value._21 ) + ( _13 * value._31 ) + ( _14 * value._41 );
    tmp[  1 ] = ( _11 * value._12 ) + ( _12 * value._22 ) + ( _13 * value._32 ) + ( _14 * value._42 );
    tmp[  2 ] = ( _11 * value._13 ) + ( _12 * value._23 ) + ( _13 * value._33 ) + ( _14 * value._43 );
    tmp[  3 ] = ( _11 * value._14 ) + ( _12 * value._24 ) + ( _13 * value._34 ) + ( _14 * value._44 );

    tmp[  4 ] = ( _21 * value._11 ) + ( _22 * value._21 ) + ( _23 * value._31 ) + ( _24 * value._41 );
    tmp[  5 ] = ( _21 * value._12 ) + ( _22 * value._22 ) + ( _23 * value._32 ) + ( _24 * value._42 );
    tmp[  6 ] = ( _21 * value._13 ) + ( _22 * value._23 ) + ( _23 * value._33 ) + ( _24 * value._43 );
    tmp[  7 ] = ( _21 * value._14 ) + ( _22 * value._24 ) + ( _23 * value._34 ) + ( _24 * value._44 );

    tmp[  8 ] = ( _31 * value._11 ) + ( _32 * value._21 ) + ( _33 * value._31 ) + ( _34 * value._41 );
    tmp[  9 ] = ( _31 * value._12 ) + ( _32 * value._22 ) + ( _33 * value._32 ) + ( _34 * value._42 );
    tmp[ 10 ] = ( _31 * value._13 ) + ( _32 * value._23 ) + ( _33 * value._33 ) + ( _34 * value._43 );
    tmp[ 11 ] = ( _31 * value._14 ) + ( _32 * value._24 ) + ( _33 * value._34 ) + ( _34 * value._44 );

    tmp[ 12 ] = ( _41 * value._11 ) + ( _42 * value._21 ) + ( _43 * value._31 ) + ( _44 * value._41 );
    tmp[ 13 ] = ( _41 * value._12 ) + ( _42 * value._22 ) + ( _43 * value._32 ) + ( _44 * value._42 );
    tmp[ 14 ] = ( _41 * value._13 ) + ( _42 * value._23 ) + ( _43 * value._33 ) + ( _44 * value._43 );
    tmp[ 15 ] = ( _41 * value._14 ) + ( _42 * value._24 ) + ( _43 * value._34 ) + ( _44 * value._44 );

    memcpy( m, tmp, sizeof( f32 ) * 16 );

    return (*this);
}

//------------------------------------------------------------------------------
///<summary>加算代入演算子です.</summary>
///<param name="value">加算する行列</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix& Matrix::operator += ( const Matrix& value )
{
    _11 += value._11;
    _12 += value._12;
    _13 += value._13;
    _14 += value._14;

    _21 += value._21;
    _22 += value._22;
    _23 += value._23;
    _24 += value._24;

    _31 += value._31;
    _32 += value._32;
    _33 += value._33;
    _34 += value._34;

    _41 += value._41;
    _42 += value._42;
    _43 += value._43;
    _44 += value._44;

    return (*this);
}

//------------------------------------------------------------------------------
///<summary>減算代入演算子です.</summary>
///<param name="value">減算する行列</param>
///<return>減算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix& Matrix::operator -= ( const Matrix& value )
{
    _11 -= value._11;
    _12 -= value._12;
    _13 -= value._13;
    _14 -= value._14;

    _21 -= value._21;
    _22 -= value._22;
    _23 -= value._23;
    _24 -= value._24;

    _31 -= value._31;
    _32 -= value._32;
    _33 -= value._33;
    _34 -= value._34;

    _41 -= value._41;
    _42 -= value._42;
    _43 -= value._43;
    _44 -= value._44;

    return (*this);
}

//------------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix& Matrix::operator *= ( const f32 scalar )
{
    _11 *= scalar;
    _12 *= scalar;
    _13 *= scalar;
    _14 *= scalar;

    _21 *= scalar;
    _22 *= scalar;
    _23 *= scalar;
    _24 *= scalar;

    _31 *= scalar;
    _32 *= scalar;
    _33 *= scalar;
    _34 *= scalar;

    _41 *= scalar;
    _42 *= scalar;
    _43 *= scalar;
    _44 *= scalar;

    return (*this);
}

//------------------------------------------------------------------------------
///<summary>除算代入演算子です.</summary>
///<param name="scalar">除算するスカラー値.</param>
///<return>除算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix& Matrix::operator /= ( const f32 scalar )
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    _11 *= invScalar;
    _12 *= invScalar;
    _13 *= invScalar;
    _14 *= invScalar;

    _21 *= invScalar;
    _22 *= invScalar;
    _23 *= invScalar;
    _24 *= invScalar;

    _31 *= invScalar;
    _32 *= invScalar;
    _33 *= invScalar;
    _34 *= invScalar;

    _41 *= invScalar;
    _42 *= invScalar;
    _43 *= invScalar;
    _44 *= invScalar;

    return (*this);
}

//------------------------------------------------------------------------------
///<summary>正符号演算子です.</summary>
///<return>自分自身の値を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator + () const
{ return (*this); }

//------------------------------------------------------------------------------
///<summary>負符号演算子です.</summary>
///<return>各成分にマイナスを付けた値を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator - () const
{
    return Matrix(
        -_11, -_12, -_13, -_14,
        -_21, -_22, -_23, -_24,
        -_31, -_32, -_33, -_34,
        -_41, -_42, -_43, -_44 );
}

//------------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="value">乗算する値</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator * ( const Matrix& value ) const
{
    return Matrix(
        ( _11 * value._11 ) + ( _12 * value._21 ) + ( _13 * value._31 ) + ( _14 * value._41 ),
        ( _11 * value._12 ) + ( _12 * value._22 ) + ( _13 * value._32 ) + ( _14 * value._42 ),
        ( _11 * value._13 ) + ( _12 * value._23 ) + ( _13 * value._33 ) + ( _14 * value._43 ),
        ( _11 * value._14 ) + ( _12 * value._24 ) + ( _13 * value._34 ) + ( _14 * value._44 ),

        ( _21 * value._11 ) + ( _22 * value._21 ) + ( _23 * value._31 ) + ( _24 * value._41 ),
        ( _21 * value._12 ) + ( _22 * value._22 ) + ( _23 * value._32 ) + ( _24 * value._42 ),
        ( _21 * value._13 ) + ( _22 * value._23 ) + ( _23 * value._33 ) + ( _24 * value._43 ),
        ( _21 * value._14 ) + ( _22 * value._24 ) + ( _23 * value._34 ) + ( _24 * value._44 ),

        ( _31 * value._11 ) + ( _32 * value._21 ) + ( _33 * value._31 ) + ( _34 * value._41 ),
        ( _31 * value._12 ) + ( _32 * value._22 ) + ( _33 * value._32 ) + ( _34 * value._42 ),
        ( _31 * value._13 ) + ( _32 * value._23 ) + ( _33 * value._33 ) + ( _34 * value._43 ),
        ( _31 * value._14 ) + ( _32 * value._24 ) + ( _33 * value._34 ) + ( _34 * value._44 ),

        ( _41 * value._11 ) + ( _42 * value._21 ) + ( _43 * value._31 ) + ( _44 * value._41 ),
        ( _41 * value._12 ) + ( _42 * value._22 ) + ( _43 * value._32 ) + ( _44 * value._42 ),
        ( _41 * value._13 ) + ( _42 * value._23 ) + ( _43 * value._33 ) + ( _44 * value._43 ),
        ( _41 * value._14 ) + ( _42 * value._24 ) + ( _43 * value._34 ) + ( _44 * value._44 )
    );
}

//------------------------------------------------------------------------------
///<summary>加算演算子です.</summary>
///<param name="value">加算する値.</param>
///<return>加算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator + ( const Matrix& value ) const
{
    return Matrix(
        _11 + value._11,
        _12 + value._12,
        _13 + value._13,
        _14 + value._14,

        _21 + value._21,
        _22 + value._22,
        _23 + value._23,
        _24 + value._24,

        _31 + value._31,
        _32 + value._32,
        _33 + value._33,
        _34 + value._34,
        
        _41 + value._41,
        _42 + value._42,
        _43 + value._43,
        _44 + value._44 
    );
}

//------------------------------------------------------------------------------
///<summary>減算演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator - ( const Matrix& value ) const
{
    return Matrix(
        _11 - value._11,
        _12 - value._12,
        _13 - value._13,
        _14 - value._14,

        _21 - value._21,
        _22 - value._22,
        _23 - value._23,
        _24 - value._24,

        _31 - value._31,
        _32 - value._32,
        _33 - value._33,
        _34 - value._34,
        
        _41 - value._41,
        _42 - value._42,
        _43 - value._43,
        _44 - value._44 
    );
}

//------------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値.</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator * ( const f32 scalar ) const
{
    return Matrix(
        _11 * scalar,
        _12 * scalar,
        _13 * scalar,
        _14 * scalar,

        _21 * scalar,
        _22 * scalar,
        _23 * scalar,
        _24 * scalar,

        _31 * scalar,
        _32 * scalar,
        _33 * scalar,
        _34 * scalar,

        _41 * scalar,
        _42 * scalar,
        _43 * scalar,
        _44 * scalar
    );
}

//------------------------------------------------------------------------------
///<summary>除算演算子です.</summary>
///<param name="scalar">除算するスカラー値.</param>
///<return>除算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix Matrix::operator / ( const f32 scalar ) const
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;

    return Matrix(
        _11 * invScalar,
        _12 * invScalar,
        _13 * invScalar,
        _14 * invScalar,

        _21 * invScalar,
        _22 * invScalar,
        _23 * invScalar,
        _24 * invScalar,

        _31 * invScalar,
        _32 * invScalar,
        _33 * invScalar,
        _34 * invScalar,

        _41 * invScalar,
        _42 * invScalar,
        _43 * invScalar,
        _44 * invScalar
    );
}

//------------------------------------------------------------------------------
///<summary>代入演算子です.</summary>
///<param name="value">代入する値</param>
///<return>代入結果を返却します</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix& Matrix::operator = ( const Matrix& value )
{
    memcpy( m, value.m, sizeof( f32 ) * 16 );
    return (*this);
}

//------------------------------------------------------------------------------
///<summary>等価比較演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が等価であればture, 非等価であればfalseを返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
bool Matrix::operator == ( const Matrix& value ) const
{ return ( memcmp( m, value.m, sizeof( f32 ) * 16 ) == 0 ) ? true : false; }

//------------------------------------------------------------------------------
///<summary>非等価比較演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>値が非等価であればtrue, 等価であればtrueを返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
bool Matrix::operator != ( const Matrix& value ) const
{ return ( memcmp( m, value.m, sizeof( 32 ) * 16 ) != 0 ) ? true : false; }

//------------------------------------------------------------------------------
///<summary>行列式を求めます.</summary>
///<return>行列式の値を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
f32 Matrix::Determinant() const
{
    return (
        _11*_22*_33*_44 + _11*_23*_34*_42 +
        _11*_24*_32*_43 + _12*_21*_34*_43 +
        _12*_23*_31*_44 + _12*_24*_33*_41 +
        _13*_21*_32*_44 + _13*_22*_34*_41 +
        _13*_24*_31*_42 + _14*_21*_33*_42 +
        _14*_22*_31*_43 + _14*_23*_32*_41 -
        _11*_22*_34*_43 - _11*_23*_32*_44 -
        _11*_24*_33*_42 - _12*_21*_33*_44 -
        _12*_23*_34*_41 - _12*_24*_31*_43 -
        _13*_21*_34*_42 - _13*_22*_31*_44 -
        _13*_24*_32*_41 - _14*_21*_32*_43 -
        _14*_22*_33*_41 - _14*_23*_31*_42
    );
}

//------------------------------------------------------------------------------
///<summary>単位行列化します.</summary>
//------------------------------------------------------------------------------
ASDX_INLINE
void Matrix::Identity()
{
    _11 = _22 = _33 = _44 = 1.0f;

    _12 = _13 = _14 =
    _21 = _23 = _24 =
    _31 = _32 = _34 =
    _41 = _42 = _43 = 0.0f;
}

//-------------------------------------------------------------------------------
///<summary>平行移動成分を取得します.</summary>
///<return>平行移動成分を返却します.</return>
//-------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetTranslate() const
{ return Vector3( _41, _42, _43 ); }

//------------------------------------------------------------------------------
///<summary>拡大・縮小成分を取得します.</summary>
///<return>拡大・縮小成分を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetScale() const
{ 
    return Vector3(
        sqrtf( ( _11 * _11 ) + ( _12 * _12 ) + ( _13 * _13 ) ),
        sqrtf( ( _21 * _21 ) + ( _22 * _22 ) + ( _23 * _23 ) ),
        sqrtf( ( _31 * _31 ) + ( _32 * _32 ) + ( _33 * _33 ) )
    );
}

//------------------------------------------------------------------------------
///<summary>ローカル座標のX軸方向を求めます</summary>
///<return>ローカル座標のX軸方向を返却します</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetDirectionX() const
{
    register f32 dist = sqrtf( ( _11 * _11 ) + ( _12 * _12 ) * ( _13 * _13 ) );
    if ( dist > 0.0f )
    {
        register f32 invDist = 1.0f / dist;
        return Vector3( 
            _11 * invDist,
            _12 * invDist,
            _13 * invDist );
    }
    return Vector3( _11, _12, _13 );
}

//------------------------------------------------------------------------------
///<summary>ローカル座標のY軸方向を求めます</summary>
///<return>ローカル座標のY軸方向を返却します</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetDirectionY() const
{
    register f32 dist = sqrtf( ( _21 * _21 ) + ( _22 * _22 ) * ( _23 * _23 ) );
    if ( dist > 0.0f )
    {
        register f32 invDist = 1.0f / dist;
        return Vector3(
            _21 * invDist,
            _22 * invDist,
            _23 * invDist );
    }
    return Vector3( _21, _22, _23 );
}

//------------------------------------------------------------------------------
///<summary>ローカル座標のZ軸方向を求めます</summary>
///<return>ローカル座標のZ軸方向を返却します</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetDirectionZ() const
{
    register f32 dist = sqrtf( ( _31 * _31 ) + ( _32 * _32 ) * ( _33 * _33 ) );
    if ( dist > 0.0f )
    {
        register f32 invDist = 1.0f / dist;
        return Vector3( 
            _31 * invDist,
            _32 * invDist,
            _33 * invDist );
    }
    return Vector3( _31, _32, _33 );
}


////////////////////////////////////////////////////////////////////////////////
// Matrix Methods
////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------
///<summary>単位行列にします.</summary>
///<param name="value">単位行列にする値.</param>
///<return>単位行列化した結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE 
Matrix  Matrix::Identity( Matrix& value )
{
    value._11 = value._22 = value._33 = value._44 = 1.0f;

    value._12 = value._13 = value._14 =
    value._21 = value._23 = value._24 =
    value._31 = value._32 = value._34 =
    value._41 = value._42 = value._43 = 0.0f;

    return value;
}

//------------------------------------------------------------------------------
///<summary>単位行列であるか判定します.</summary>
///<param name="value">判定する値</param>
///<return>単位行列であればtrue, 非単位行列であればfalseを返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
bool    Matrix::IsIdentity( const Matrix& value )
{
    return ( ( value._11 == 1.0f )
          && ( value._12 == 0.0f )
          && ( value._13 == 0.0f )
          && ( value._14 == 0.0f )

          && ( value._21 == 0.0f )
          && ( value._22 == 1.0f )
          && ( value._23 == 0.0f )
          && ( value._24 == 0.0f )

          && ( value._31 == 0.0f )
          && ( value._32 == 0.0f )
          && ( value._33 == 1.0f )
          && ( value._34 == 0.0f )

          && ( value._41 == 0.0f )
          && ( value._42 == 0.0f )
          && ( value._43 == 0.0f )
          && ( value._44 == 1.0f )
    );
}

//------------------------------------------------------------------------------
///<summary>行列を転置します.</summary>
///<param name="value">転置する行列</param>
///<return>行列を転置した結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::Transpose( const Matrix& value )
{
    return Matrix(
        value._11, value._21, value._31, value._41,
        value._12, value._22, value._32, value._42,
        value._13, value._23, value._33, value._43,
        value._14, value._24, value._34, value._44 
    );
}

//------------------------------------------------------------------------------
///<summary>行列を転置します.</summary>
///<param name="value">転置する行列</param>
///<param name="result">転置された行列</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::Transpose( const Matrix& value, Matrix& result )
{
    result._11 = value._11;
    result._12 = value._21;
    result._13 = value._31;
    result._14 = value._41;

    result._21 = value._12;
    result._22 = value._22;
    result._23 = value._32;
    result._24 = value._42;

    result._31 = value._13;
    result._32 = value._23;
    result._33 = value._33;
    result._34 = value._43;

    result._41 = value._14;
    result._42 = value._24;
    result._43 = value._34;
    result._44 = value._44;
}

//------------------------------------------------------------------------------
///<summary>行列同士を乗算します.</summary>
///<param name="a">入力行列</param>
///<param name="b">入力行列</param>
///<return>乗算結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::Multiply( const Matrix& a, const Matrix& b )
{
    Matrix result;

    result._11 = ( a._11 * b._11 ) + ( a._12 * b._21 ) + ( a._13 * b._31 ) + ( a._14 * b._41 );
    result._12 = ( a._11 * b._12 ) + ( a._12 * b._22 ) + ( a._13 * b._32 ) + ( a._14 * b._42 );
    result._13 = ( a._11 * b._13 ) + ( a._12 * b._23 ) + ( a._13 * b._33 ) + ( a._14 * b._43 );
    result._14 = ( a._11 * b._14 ) + ( a._12 * b._24 ) + ( a._13 * b._34 ) + ( a._14 * b._44 );

    result._21 = ( a._21 * b._11 ) + ( a._22 * b._21 ) + ( a._23 * b._31 ) + ( a._24 * b._41 );
    result._22 = ( a._21 * b._12 ) + ( a._22 * b._22 ) + ( a._23 * b._32 ) + ( a._24 * b._42 );
    result._23 = ( a._21 * b._13 ) + ( a._22 * b._23 ) + ( a._23 * b._33 ) + ( a._24 * b._43 );
    result._24 = ( a._21 * b._14 ) + ( a._22 * b._24 ) + ( a._23 * b._34 ) + ( a._24 * b._44 );

    result._31 = ( a._31 * b._11 ) + ( a._32 * b._21 ) + ( a._33 * b._31 ) + ( a._34 * b._41 );
    result._32 = ( a._31 * b._12 ) + ( a._32 * b._22 ) + ( a._33 * b._32 ) + ( a._34 * b._42 );
    result._33 = ( a._31 * b._13 ) + ( a._32 * b._23 ) + ( a._33 * b._33 ) + ( a._34 * b._43 );
    result._34 = ( a._31 * b._14 ) + ( a._32 * b._24 ) + ( a._33 * b._34 ) + ( a._34 * b._44 );

    result._41 = ( a._41 * b._11 ) + ( a._42 * b._21 ) + ( a._43 * b._31 ) + ( a._44 * b._41 );
    result._42 = ( a._41 * b._12 ) + ( a._42 * b._22 ) + ( a._43 * b._32 ) + ( a._44 * b._42 );
    result._43 = ( a._41 * b._13 ) + ( a._42 * b._23 ) + ( a._43 * b._33 ) + ( a._44 * b._43 );
    result._44 = ( a._41 * b._14 ) + ( a._42 * b._24 ) + ( a._43 * b._34 ) + ( a._44 * b._44 );

    return result;
}

//------------------------------------------------------------------------------
///<summary>行列同士を乗算します.</summary>
///<param name="a">入力行列.</param>
///<param name="b">入力行列.</param>
///<param name="result">乗算結果.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::Multiply( const Matrix& a, const Matrix& b, Matrix& result )
{
    result._11 = ( a._11 * b._11 ) + ( a._12 * b._21 ) + ( a._13 * b._31 ) + ( a._14 * b._41 );
    result._12 = ( a._11 * b._12 ) + ( a._12 * b._22 ) + ( a._13 * b._32 ) + ( a._14 * b._42 );
    result._13 = ( a._11 * b._13 ) + ( a._12 * b._23 ) + ( a._13 * b._33 ) + ( a._14 * b._43 );
    result._14 = ( a._11 * b._14 ) + ( a._12 * b._24 ) + ( a._13 * b._34 ) + ( a._14 * b._44 );

    result._21 = ( a._21 * b._11 ) + ( a._22 * b._21 ) + ( a._23 * b._31 ) + ( a._24 * b._41 );
    result._22 = ( a._21 * b._12 ) + ( a._22 * b._22 ) + ( a._23 * b._32 ) + ( a._24 * b._42 );
    result._23 = ( a._21 * b._13 ) + ( a._22 * b._23 ) + ( a._23 * b._33 ) + ( a._24 * b._43 );
    result._24 = ( a._21 * b._14 ) + ( a._22 * b._24 ) + ( a._23 * b._34 ) + ( a._24 * b._44 );

    result._31 = ( a._31 * b._11 ) + ( a._32 * b._21 ) + ( a._33 * b._31 ) + ( a._34 * b._41 );
    result._32 = ( a._31 * b._12 ) + ( a._32 * b._22 ) + ( a._33 * b._32 ) + ( a._34 * b._42 );
    result._33 = ( a._31 * b._13 ) + ( a._32 * b._23 ) + ( a._33 * b._33 ) + ( a._34 * b._43 );
    result._34 = ( a._31 * b._14 ) + ( a._32 * b._24 ) + ( a._33 * b._34 ) + ( a._34 * b._44 );

    result._41 = ( a._41 * b._11 ) + ( a._42 * b._21 ) + ( a._43 * b._31 ) + ( a._44 * b._41 );
    result._42 = ( a._41 * b._12 ) + ( a._42 * b._22 ) + ( a._43 * b._32 ) + ( a._44 * b._42 );
    result._43 = ( a._41 * b._13 ) + ( a._42 * b._23 ) + ( a._43 * b._33 ) + ( a._44 * b._43 );
    result._44 = ( a._41 * b._14 ) + ( a._42 * b._24 ) + ( a._43 * b._34 ) + ( a._44 * b._44 );
}

//------------------------------------------------------------------------------
///<summary>スカラー乗算します.</summary>
///<param name="value">入力行列</param>
///<param name="scalar">スカラー値</param>
///<return>スカラー乗算した結果を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::Multiply( const Matrix& value, const f32 scalar )
{
    return Matrix(
        value._11 * scalar,
        value._12 * scalar,
        value._13 * scalar,
        value._14 * scalar,

        value._21 * scalar,
        value._22 * scalar,
        value._23 * scalar,
        value._24 * scalar,

        value._31 * scalar,
        value._32 * scalar,
        value._33 * scalar,
        value._34 * scalar,

        value._41 * scalar,
        value._42 * scalar,
        value._43 * scalar,
        value._44 * scalar 
    );
}

//------------------------------------------------------------------------------
///<summary>スカラー乗算します.</summary>
///<param name="value">入力行列.</param>
///<param name="scalar">スカラー値.</param>
///<param name="result">スカラー乗算した結果.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::Multiply( const Matrix& value, const f32 scalar, Matrix& result )
{
    result._11 = value._11 * scalar;
    result._12 = value._12 * scalar;
    result._13 = value._13 * scalar;
    result._14 = value._14 * scalar;

    result._21 = value._21 * scalar;
    result._22 = value._22 * scalar;
    result._23 = value._23 * scalar;
    result._24 = value._24 * scalar;

    result._31 = value._31 * scalar;
    result._32 = value._32 * scalar;
    result._33 = value._33 * scalar;
    result._34 = value._34 * scalar;

    result._41 = value._41 * scalar;
    result._42 = value._42 * scalar;
    result._43 = value._43 * scalar;
    result._44 = value._44 * scalar;
}

//------------------------------------------------------------------------------
///<summary>行列同士を乗算し、乗算結果を転置します.</summary>
///<param name="a">入力行列.</param>
///<param name="b">入力行列.</param>
///<return>行列同士を乗算し，乗算結果を転置した値を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::MultiplyTranspose( const Matrix& a, const Matrix& b )
{
    Matrix result;

    result._11 = ( a._11 * b._11 ) + ( a._12 * b._21 ) + ( a._13 * b._31 ) + ( a._14 * b._41 );
    result._21 = ( a._11 * b._12 ) + ( a._12 * b._22 ) + ( a._13 * b._32 ) + ( a._14 * b._42 );
    result._31 = ( a._11 * b._13 ) + ( a._12 * b._23 ) + ( a._13 * b._33 ) + ( a._14 * b._43 );
    result._41 = ( a._11 * b._14 ) + ( a._12 * b._24 ) + ( a._13 * b._34 ) + ( a._14 * b._44 );

    result._12 = ( a._21 * b._11 ) + ( a._22 * b._21 ) + ( a._23 * b._31 ) + ( a._24 * b._41 );
    result._22 = ( a._21 * b._12 ) + ( a._22 * b._22 ) + ( a._23 * b._32 ) + ( a._24 * b._42 );
    result._32 = ( a._21 * b._13 ) + ( a._22 * b._23 ) + ( a._23 * b._33 ) + ( a._24 * b._43 );
    result._42 = ( a._21 * b._14 ) + ( a._22 * b._24 ) + ( a._23 * b._34 ) + ( a._24 * b._44 );

    result._13 = ( a._31 * b._11 ) + ( a._32 * b._21 ) + ( a._33 * b._31 ) + ( a._34 * b._41 );
    result._23 = ( a._31 * b._12 ) + ( a._32 * b._22 ) + ( a._33 * b._32 ) + ( a._34 * b._42 );
    result._33 = ( a._31 * b._13 ) + ( a._32 * b._23 ) + ( a._33 * b._33 ) + ( a._34 * b._43 );
    result._43 = ( a._31 * b._14 ) + ( a._32 * b._24 ) + ( a._33 * b._34 ) + ( a._34 * b._44 );

    result._14 = ( a._41 * b._11 ) + ( a._42 * b._21 ) + ( a._43 * b._31 ) + ( a._44 * b._41 );
    result._24 = ( a._41 * b._12 ) + ( a._42 * b._22 ) + ( a._43 * b._32 ) + ( a._44 * b._42 );
    result._34 = ( a._41 * b._13 ) + ( a._42 * b._23 ) + ( a._43 * b._33 ) + ( a._44 * b._43 );
    result._44 = ( a._41 * b._14 ) + ( a._42 * b._24 ) + ( a._43 * b._34 ) + ( a._44 * b._44 );

    return result;
}

//------------------------------------------------------------------------------
///<summary>行列同士を乗算し，乗算結果を転置します.</summary>
///<param name="a">入力行列.</param>
///<param name="b">入力行列.</param>
///<param name="result">行列同士を乗算し，乗算結果を転置した値.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::MultiplyTranspose( const Matrix& a, const Matrix& b, Matrix& result )
{
    result._11 = ( a._11 * b._11 ) + ( a._12 * b._21 ) + ( a._13 * b._31 ) + ( a._14 * b._41 );
    result._21 = ( a._11 * b._12 ) + ( a._12 * b._22 ) + ( a._13 * b._32 ) + ( a._14 * b._42 );
    result._31 = ( a._11 * b._13 ) + ( a._12 * b._23 ) + ( a._13 * b._33 ) + ( a._14 * b._43 );
    result._41 = ( a._11 * b._14 ) + ( a._12 * b._24 ) + ( a._13 * b._34 ) + ( a._14 * b._44 );

    result._12 = ( a._21 * b._11 ) + ( a._22 * b._21 ) + ( a._23 * b._31 ) + ( a._24 * b._41 );
    result._22 = ( a._21 * b._12 ) + ( a._22 * b._22 ) + ( a._23 * b._32 ) + ( a._24 * b._42 );
    result._32 = ( a._21 * b._13 ) + ( a._22 * b._23 ) + ( a._23 * b._33 ) + ( a._24 * b._43 );
    result._42 = ( a._21 * b._14 ) + ( a._22 * b._24 ) + ( a._23 * b._34 ) + ( a._24 * b._44 );

    result._13 = ( a._31 * b._11 ) + ( a._32 * b._21 ) + ( a._33 * b._31 ) + ( a._34 * b._41 );
    result._23 = ( a._31 * b._12 ) + ( a._32 * b._22 ) + ( a._33 * b._32 ) + ( a._34 * b._42 );
    result._33 = ( a._31 * b._13 ) + ( a._32 * b._23 ) + ( a._33 * b._33 ) + ( a._34 * b._43 );
    result._43 = ( a._31 * b._14 ) + ( a._32 * b._24 ) + ( a._33 * b._34 ) + ( a._34 * b._44 );

    result._14 = ( a._41 * b._11 ) + ( a._42 * b._21 ) + ( a._43 * b._31 ) + ( a._44 * b._41 );
    result._24 = ( a._41 * b._12 ) + ( a._42 * b._22 ) + ( a._43 * b._32 ) + ( a._44 * b._42 );
    result._34 = ( a._41 * b._13 ) + ( a._42 * b._23 ) + ( a._43 * b._33 ) + ( a._44 * b._43 );
    result._44 = ( a._41 * b._14 ) + ( a._42 * b._24 ) + ( a._43 * b._34 ) + ( a._44 * b._44 );
}

//------------------------------------------------------------------------------
///<summary>逆行列を求めます.</summary>
///<param name="value">逆行列を求める値</param>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::Invert( const Matrix& value )
{
    Matrix result;
    register float det = value.Determinant();
    assert( det != 0.0f );
    register float invDet = 1.0f / det;

    result._11 = ( value._22 * value._33 * value._44 ) + ( value._23 * value._34 * value._42 ) + ( value._24 * value._32 * value._43 )
               - ( value._22 * value._34 * value._43 ) - ( value._23 * value._32 * value._44 ) - ( value._24 * value._33 * value._42 );
    result._12 = ( value._12 * value._34 * value._43 ) + ( value._13 * value._32 * value._44 ) + ( value._14 * value._33 * value._42 )
               - ( value._12 * value._33 * value._44 ) - ( value._13 * value._34 * value._42 ) - ( value._14 * value._32 * value._43 );
    result._13 = ( value._12 * value._23 * value._44 ) + ( value._13 * value._24 * value._42 ) + ( value._14 * value._22 * value._43 )
               - ( value._12 * value._24 * value._43 ) - ( value._13 * value._22 * value._44 ) - ( value._14 * value._23 * value._42 );
    result._14 = ( value._12 * value._24 * value._33 ) + ( value._13 * value._22 * value._34 ) + ( value._14 * value._23 * value._32 )
               - ( value._12 * value._23 * value._34 ) - ( value._13 * value._24 * value._32 ) - ( value._14 * value._22 * value._33 );

    result._21 = ( value._21 * value._34 * value._43 ) + ( value._23 * value._31 * value._44 ) + ( value._24 * value._33 * value._41 )
               - ( value._21 * value._33 * value._44 ) - ( value._23 * value._34 * value._41 ) - ( value._24 * value._31 * value._43 );
    result._22 = ( value._11 * value._33 * value._44 ) + ( value._13 * value._34 * value._41 ) + ( value._14 * value._31 * value._43 )
               - ( value._11 * value._34 * value._43 ) - ( value._13 * value._31 * value._44 ) - ( value._14 * value._33 * value._41 );
    result._23 = ( value._11 * value._24 * value._43 ) + ( value._13 * value._21 * value._44 ) + ( value._14 * value._23 * value._41 )
               - ( value._11 * value._23 * value._44 ) - ( value._13 * value._24 * value._41 ) - ( value._14 * value._21 * value._43 );
    result._24 = ( value._11 * value._23 * value._34 ) + ( value._13 * value._24 * value._31 ) + ( value._14 * value._21 * value._33 )
               - ( value._11 * value._24 * value._33 ) - ( value._13 * value._21 * value._34 ) - ( value._14 * value._23 * value._31 );

    result._31 = ( value._21 * value._32 * value._44 ) + ( value._22 * value._34 * value._41 ) + ( value._24 * value._31 * value._42 )
               - ( value._21 * value._34 * value._42 ) - ( value._22 * value._31 * value._44 ) - ( value._24 * value._32 * value._41 );
    result._32 = ( value._11 * value._34 * value._42 ) + ( value._12 * value._31 * value._44 ) + ( value._14 * value._32 * value._41 )
               - ( value._11 * value._32 * value._44 ) - ( value._12 * value._34 * value._41 ) - ( value._14 * value._31 * value._42 );
    result._33 = ( value._11 * value._22 * value._44 ) + ( value._12 * value._24 * value._41 ) + ( value._14 * value._21 * value._42 )
               - ( value._11 * value._24 * value._42 ) - ( value._12 * value._21 * value._44 ) - ( value._14 * value._22 * value._41 );
    result._34 = ( value._11 * value._24 * value._32 ) + ( value._12 * value._21 * value._34 ) + ( value._14 * value._22 * value._31 )
               - ( value._11 * value._22 * value._34 ) - ( value._12 * value._24 * value._31 ) - ( value._14 * value._21 * value._32 );

    result._41 = ( value._21 * value._33 * value._42 ) + ( value._22 * value._31 * value._43 ) + ( value._23 * value._32 * value._41 )
               - ( value._21 * value._32 * value._43 ) - ( value._22 * value._33 * value._41 ) - ( value._23 * value._31 * value._42 );
    result._42 = ( value._11 * value._32 * value._43 ) + ( value._12 * value._33 * value._41 ) + ( value._13 * value._31 * value._42 )
               - ( value._11 * value._33 * value._42 ) - ( value._12 * value._31 * value._43 ) - ( value._13 * value._32 * value._41 );
    result._43 = ( value._11 * value._23 * value._42 ) + ( value._12 * value._21 * value._43 ) + ( value._13 * value._22 * value._41 )
               - ( value._11 * value._22 * value._43 ) - ( value._12 * value._23 * value._41 ) - ( value._13 * value._21 * value._42 );
    result._44 = ( value._11 * value._22 * value._33 ) + ( value._12 * value._23 * value._31 ) + ( value._13 * value._21 * value._32 )
               - ( value._11 * value._23 * value._32 ) - ( value._12 * value._21 * value._33 ) - ( value._13 * value._22 * value._31 );

    result._11 *= invDet;
    result._12 *= invDet;
    result._13 *= invDet;
    result._14 *= invDet;

    result._21 *= invDet;
    result._22 *= invDet;
    result._23 *= invDet;
    result._24 *= invDet;

    result._31 *= invDet;
    result._32 *= invDet;
    result._33 *= invDet;
    result._34 *= invDet;

    result._41 *= invDet;
    result._42 *= invDet;
    result._43 *= invDet;
    result._44 *= invDet;

    return result;
}

//------------------------------------------------------------------------------
///<summary>逆行列を求めます.</summary>
///<param name="value">逆行列を求める値.</param>
///<param name="result">逆行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::Invert( const Matrix& value, Matrix& result )
{
    register float det = value.Determinant();
    assert( det != 0.0f );
    register float invDet = 1.0f / det;

    result._11 = ( value._22 * value._33 * value._44 ) + ( value._23 * value._34 * value._42 ) + ( value._24 * value._32 * value._43 )
               - ( value._22 * value._34 * value._43 ) - ( value._23 * value._32 * value._44 ) - ( value._24 * value._33 * value._42 );
    result._12 = ( value._12 * value._34 * value._43 ) + ( value._13 * value._32 * value._44 ) + ( value._14 * value._33 * value._42 )
               - ( value._12 * value._33 * value._44 ) - ( value._13 * value._34 * value._42 ) - ( value._14 * value._32 * value._43 );
    result._13 = ( value._12 * value._23 * value._44 ) + ( value._13 * value._24 * value._42 ) + ( value._14 * value._22 * value._43 )
               - ( value._12 * value._24 * value._43 ) - ( value._13 * value._22 * value._44 ) - ( value._14 * value._23 * value._42 );
    result._14 = ( value._12 * value._24 * value._33 ) + ( value._13 * value._22 * value._34 ) + ( value._14 * value._23 * value._32 )
               - ( value._12 * value._23 * value._34 ) - ( value._13 * value._24 * value._32 ) - ( value._14 * value._22 * value._33 );

    result._21 = ( value._21 * value._34 * value._43 ) + ( value._23 * value._31 * value._44 ) + ( value._24 * value._33 * value._41 )
               - ( value._21 * value._33 * value._44 ) - ( value._23 * value._34 * value._41 ) - ( value._24 * value._31 * value._43 );
    result._22 = ( value._11 * value._33 * value._44 ) + ( value._13 * value._34 * value._41 ) + ( value._14 * value._31 * value._43 )
               - ( value._11 * value._34 * value._43 ) - ( value._13 * value._31 * value._44 ) - ( value._14 * value._33 * value._41 );
    result._23 = ( value._11 * value._24 * value._43 ) + ( value._13 * value._21 * value._44 ) + ( value._14 * value._23 * value._41 )
               - ( value._11 * value._23 * value._44 ) - ( value._13 * value._24 * value._41 ) - ( value._14 * value._21 * value._43 );
    result._24 = ( value._11 * value._23 * value._34 ) + ( value._13 * value._24 * value._31 ) + ( value._14 * value._21 * value._33 )
               - ( value._11 * value._24 * value._33 ) - ( value._13 * value._21 * value._34 ) - ( value._14 * value._23 * value._31 );

    result._31 = ( value._21 * value._32 * value._44 ) + ( value._22 * value._34 * value._41 ) + ( value._24 * value._31 * value._42 )
               - ( value._21 * value._34 * value._42 ) - ( value._22 * value._31 * value._44 ) - ( value._24 * value._32 * value._41 );
    result._32 = ( value._11 * value._34 * value._42 ) + ( value._12 * value._31 * value._44 ) + ( value._14 * value._32 * value._41 )
               - ( value._11 * value._32 * value._44 ) - ( value._12 * value._34 * value._41 ) - ( value._14 * value._31 * value._42 );
    result._33 = ( value._11 * value._22 * value._44 ) + ( value._12 * value._24 * value._41 ) + ( value._14 * value._21 * value._42 )
               - ( value._11 * value._24 * value._42 ) - ( value._12 * value._21 * value._44 ) - ( value._14 * value._22 * value._41 );
    result._34 = ( value._11 * value._24 * value._32 ) + ( value._12 * value._21 * value._34 ) + ( value._14 * value._22 * value._31 )
               - ( value._11 * value._22 * value._34 ) - ( value._12 * value._24 * value._31 ) - ( value._14 * value._21 * value._32 );

    result._41 = ( value._21 * value._33 * value._42 ) + ( value._22 * value._31 * value._43 ) + ( value._23 * value._32 * value._41 )
               - ( value._21 * value._32 * value._43 ) - ( value._22 * value._33 * value._41 ) - ( value._23 * value._31 * value._42 );
    result._42 = ( value._11 * value._32 * value._43 ) + ( value._12 * value._33 * value._41 ) + ( value._13 * value._31 * value._42 )
               - ( value._11 * value._33 * value._42 ) - ( value._12 * value._31 * value._43 ) - ( value._13 * value._32 * value._41 );
    result._43 = ( value._11 * value._23 * value._42 ) + ( value._12 * value._21 * value._43 ) + ( value._13 * value._22 * value._41 )
               - ( value._11 * value._22 * value._43 ) - ( value._12 * value._23 * value._41 ) - ( value._13 * value._21 * value._42 );
    result._44 = ( value._11 * value._22 * value._33 ) + ( value._12 * value._23 * value._31 ) + ( value._13 * value._21 * value._32 )
               - ( value._11 * value._23 * value._32 ) - ( value._12 * value._21 * value._33 ) - ( value._13 * value._22 * value._31 );

    result._11 *= invDet;
    result._12 *= invDet;
    result._13 *= invDet;
    result._14 *= invDet;

    result._21 *= invDet;
    result._22 *= invDet;
    result._23 *= invDet;
    result._24 *= invDet;

    result._31 *= invDet;
    result._32 *= invDet;
    result._33 *= invDet;
    result._34 *= invDet;

    result._41 *= invDet;
    result._42 *= invDet;
    result._43 *= invDet;
    result._44 *= invDet;
}

//------------------------------------------------------------------------------
///<summary>四元数から行列を生成します.</summary>
///<param name="value">入力四元数.</param>
///<return>四元数から生成された行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateFromQuaternion( const Quaternion& value )
{
    Matrix result;

    result._11 = 1.0f - 2.0f * ( value.y * value.y + value.z * value.z );
    result._12 = 2.0f * ( value.x * value.y + value.w * value.z );
    result._13 = 2.0f * ( value.x * value.z - value.w * value.y );
    result._14 = 0.0f;

    result._21 = 2.0f * ( value.x * value.y - value.w * value.z );
    result._22 = 1.0f - 2.0f * ( value.x * value.x + value.z * value.z );
    result._23 = 2.0f * ( value.y * value.z + value.w * value.x );
    result._24 = 0.0f;

    result._31 = 2.0f * ( value.x * value.z + value.w * value.y );
    result._32 = 2.0f * ( value.y * value.w - value.w * value.x );
    result._33 = 1.0f - 2.0f * ( value.x * value.x + value.y * value.y );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;

    return result;
}

//------------------------------------------------------------------------------
///<summary>四元数から行列を生成します.</summary>
///<param name="value">入力四元数</param>
///<param name="result">四元数から生成された行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateFromQuaternion( const Quaternion& value, Matrix& result )
{
    result._11 = 1.0f - 2.0f * ( value.y * value.y + value.z * value.z );
    result._12 = 2.0f * ( value.x * value.y + value.w * value.z );
    result._13 = 2.0f * ( value.x * value.z - value.w * value.y );
    result._14 = 0.0f;

    result._21 = 2.0f * ( value.x * value.y - value.w * value.z );
    result._22 = 1.0f - 2.0f * ( value.x * value.x + value.z * value.z );
    result._23 = 2.0f * ( value.y * value.z + value.w * value.x );
    result._24 = 0.0f;

    result._31 = 2.0f * ( value.x * value.z + value.w * value.y );
    result._32 = 2.0f * ( value.y * value.w - value.w * value.x );
    result._33 = 1.0f - 2.0f * ( value.x * value.x + value.y * value.y );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>拡大縮小行列を生成します.</summary>
///<param name="scale">拡大縮小値.</param>
///<return>拡大縮小行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateScale( const f32 value )
{
    return Matrix(
        value,   0.0f,    0.0f,   0.0f,
        0.0f,   value,    0.0f,   0.0f,
        0.0f,    0.0f,   value,   0.0f,
        0.0f,    0.0f,    0.0f,   1.0f 
    );
}

//------------------------------------------------------------------------------
///<summary>拡大縮小行列を生成します.</summary>
///<param name="value">拡大縮小値.</param>
///<param name="result">拡大縮小行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateScale( const f32 value, Matrix& result )
{
    result._11 = value;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = value;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = value;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>拡大縮小行列を生成します.</summary>
///<param name="sx">X成分の拡大縮小値.</param>
///<param name="sy">Y成分の拡大縮小値.</param>
///<param name="sz">Z成分の拡大縮小値.</param>
///<return>拡大縮小行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateScale( const f32 sx, const f32 sy, const f32 sz )
{
    return Matrix(
        sx,     0.0f,   0.0f,   0.0f,
        0.0f,     sy,   0.0f,   0.0f,
        0.0f,   0.0f,     sz,   0.0f,
        0.0f,   0.0f,   0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>拡大縮小行列を生成します.</summary>
///<param name="sx">X成分の拡大縮小値.</param>
///<param name="sy">Y成分の拡大縮小値.</param>
///<param name="sz">Z成分の拡大縮小値.</param>
///<param name="result">拡大縮小行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateScale( const f32 sx, const f32 sy, const f32 sz, Matrix& result )
{
    result._11 = sx;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = sy;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = sz;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>拡大縮小行列を生成します.</summary>
///<param name="value">拡大縮小値.</param>
///<return>拡大縮小行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateScale( const Vector3& value )
{
    return Matrix(
        value.x,      0.0f,      0.0f,   0.0f,
           0.0f,   value.y,      0.0f,   0.0f,
           0.0f,      0.0f,   value.z,   0.0f,
           0.0f,      0.0f,      0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>拡大縮小行列を生成します.</summary>
///<param name="value">拡大縮小値.</param>
///<param name="result">拡大縮小行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateScale( const Vector3& value, Matrix& result )
{
    result._11 = value.x;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = value.y;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = value.z;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>平行移動行列を生成します.</summary>
///<param name="tx">X成分の平行移動値.</param>
///<param name="ty">Y成分の平行移動値.</param>
///<param name="tz">Z成分の平行移動値.</param>
///<return>平行移動行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateTranslation( const f32 tx, const f32 ty, const f32 tz )
{
    return Matrix(
        1.0f,   0.0f,   0.0f,   0.0f,
        0.0f,   1.0f,   0.0f,   0.0f,
        0.0f,   0.0f,   1.0f,   0.0f,
          tx,     ty,     tz,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>平行移動行列を生成します.</summary>
///<param name="tx">X成分の平行移動値.</param>
///<param name="ty">Y成分の平行移動値.</param>
///<param name="tz">Z成分の平行移動値.</param>
///<param name="result">平行移動行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateTranslation( const f32 tx, const f32 ty, const f32 tz, Matrix& result )
{
    result._11 = 1.0f;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = 1.0f;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f;
    result._34 = 0.0f;

    result._41 = tx;
    result._42 = ty;
    result._43 = tz;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>平行移動行列をを生成します</summary>
///<param name="value">平行移動値.</param>
///<return>平行移動行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateTranslation( const Vector3& value )
{
    return Matrix(
           1.0f,   0.0f,    0.0f,    0.0f,
           0.0f,   1.0f,    0.0f,    0.0f,
           0.0f,   0.0f,    1.0f,    0.0f,
        value.x, value.y, value.z,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>平行移動行列を生成します.</summary>
///<param name="value">平行移動値.</param>
///<param name="result">平行移動行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateTranslation( const Vector3& value, Matrix& result )
{
    result._11 = 1.0f;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = 1.0f;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f;
    result._34 = 0.0f;

    result._41 = value.x;
    result._42 = value.y;
    result._43 = value.z;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>X軸回りの回転行列を生成します.</summary>
///<param name="value">角度(ラジアン).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationXRad( const f32 value )
{
    return Matrix(
        1.0f,              0.0f,               0.0f,    0.0f,
        0.0f,   CosRad( value ),    SinRad( value ),    0.0f,
        0.0f,  -SinRad( value ),    CosRad( value ),    0.0f,
        0.0f,              0.0f,               0.0f,    1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>X軸回りの回転行列を生成します.</summary>
///<param name="value">角度(ラジアン).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationXRad( const f32 value, Matrix& result )
{
    result._11 = 1.0f;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = CosRad( value );
    result._23 = SinRad( value );
    result._24 = 0.0f;

    result._31 =  0.0f;
    result._32 = -SinRad( value );
    result._33 =  CosRad( value );
    result._34 =  0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>X軸回りの回転行列を生成します.</summary>
///<param name="value">角度(度).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationXDeg( const f32 value )
{
    return Matrix(
        1.0f,              0.0f,               0.0f,    0.0f,
        0.0f,   CosDeg( value ),    SinDeg( value ),    0.0f,
        0.0f,  -SinDeg( value ),    CosDeg( value ),    0.0f,
        0.0f,              0.0f,               0.0f,    1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>X軸回りの回転行列を生成します.</summary>
///<param name="value">角度(度).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationXDeg( const f32 value, Matrix& result )
{
    result._11 = 1.0f;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = CosDeg( value );
    result._23 = SinDeg( value );
    result._24 = 0.0f;

    result._31 =  0.0f;
    result._32 = -SinDeg( value );
    result._33 =  CosDeg( value );
    result._34 =  0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>X軸回りの回転行列を生成します.</summary>
///<param name="value">角度(インデックス角).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationXIdx( const u16 value )
{
    return Matrix(
        1.0f,              0.0f,               0.0f,    0.0f,
        0.0f,   CosIdx( value ),    SinIdx( value ),    0.0f,
        0.0f,  -SinIdx( value ),    CosIdx( value ),    0.0f,
        0.0f,              0.0f,               0.0f,    1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>X軸回りの回転行列を生成します.</summary>
///<param name="value">角度(インデックス角).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationXIdx( const u16 value, Matrix& result )
{
    result._11 = 1.0f;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = CosIdx( value );
    result._23 = SinIdx( value );
    result._24 = 0.0f;

    result._31 =  0.0f;
    result._32 = -SinIdx( value );
    result._33 =  CosIdx( value );
    result._34 =  0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>Y軸回りの回転行列を生成します.</summary>
///<param name="value">角度(ラジアン).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationYRad( const f32 value )
{
    return Matrix(
        CosRad( value ),    0.0f,   -SinRad( value ),   0.0f,
                   0.0f,    1.0f,               0.0f,   0.0f,
        SinRad( value ),    0.0f,    CosRad( value ),   0.0f,
                   0.0f,    0.0f,               0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>Y軸回りの回転行列を生成します.</summary>
///<param name="value">角度(ラジアン).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationYRad( const f32 value, Matrix& result )
{
    result._11 =  CosRad( value );
    result._12 =  0.0f;
    result._13 = -SinRad( value );
    result._14 =  0.0f;

    result._21 = 0.0f;
    result._22 = 1.0f;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = SinRad( value );
    result._32 = 0.0f;
    result._33 = CosRad( value );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>Y軸回りの回転行列を生成します.</summary>
///<param name="value">角度(度).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationYDeg( const f32 value )
{
    return Matrix(
        CosDeg( value ),    0.0f,   -SinDeg( value ),   0.0f,
                   0.0f,    1.0f,               0.0f,   0.0f,
        SinDeg( value ),    0.0f,    CosDeg( value ),   0.0f,
                   0.0f,    0.0f,               0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>Y軸回りの回転行列を生成します.</summary>
///<param name="value">角度(度).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationYDeg( const f32 value, Matrix& result )
{
    result._11 =  CosDeg( value );
    result._12 =  0.0f;
    result._13 = -SinDeg( value );
    result._14 =  0.0f;

    result._21 = 0.0f;
    result._22 = 1.0f;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = SinDeg( value );
    result._32 = 0.0f;
    result._33 = CosDeg( value );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>Y軸回りの回転行列を生成します.</summary>
///<param name="value">角度(インデックス角).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationYIdx( const u16 value )
{
    return Matrix(
        CosIdx( value ),    0.0f,   -SinIdx( value ),   0.0f,
                   0.0f,    1.0f,               0.0f,   0.0f,
        SinIdx( value ),    0.0f,    CosIdx( value ),   0.0f,
                   0.0f,    0.0f,               0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>Y軸回りの回転行列を生成します.</summary>
///<param name="value">角度(インデックス角).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationYIdx( const u16 value, Matrix& result )
{
    result._11 =  CosIdx( value );
    result._12 =  0.0f;
    result._13 = -SinIdx( value );
    result._14 =  0.0f;

    result._21 = 0.0f;
    result._22 = 1.0f;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = SinIdx( value );
    result._32 = 0.0f;
    result._33 = CosIdx( value );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>Z軸回りの回転行列を生成します.</summary>
///<param name="value">角度(ラジアン).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationZRad( const f32 value )
{
    return Matrix(
         CosRad( value ),   SinRad( value ),    0.0f,   0.0f,
        -SinRad( value ),   CosRad( value ),    0.0f,   0.0f,
                    0.0f,              0.0f,    1.0f,   0.0f,
                    0.0f,              0.0f,    0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>Z軸回りの回転行列を生成します.</summary>
///<param name="value">角度(ラジアン).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationZRad( const f32 value, Matrix& result )
{
    result._11 = CosRad( value );
    result._12 = SinRad( value );
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = -SinRad( value );
    result._22 =  CosRad( value );
    result._23 =  0.0f;
    result._24 =  0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>Z軸回りの回転行列を生成します.</summary>
///<param name="value">角度(度).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationZDeg( const f32 value )
{
    return Matrix(
         CosDeg( value ),   SinDeg( value ),    0.0f,   0.0f,
        -SinDeg( value ),   CosDeg( value ),    0.0f,   0.0f,
                    0.0f,              0.0f,    1.0f,   0.0f,
                    0.0f,              0.0f,    0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>Z軸回りの回転行列を生成します.</summary>
///<param name="value">角度(度).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationZDeg( const f32 value, Matrix& result )
{
    result._11 = CosDeg( value );
    result._12 = SinDeg( value );
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = -SinDeg( value );
    result._22 =  CosDeg( value );
    result._23 =  0.0f;
    result._24 =  0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>Z軸回りの回転行列を生成します.</summary>
///<param name="value">角度(インデックス角).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationZIdx( const u16 value )
{
    return Matrix(
         CosIdx( value ),   SinIdx( value ),    0.0f,   0.0f,
        -SinIdx( value ),   CosIdx( value ),    0.0f,   0.0f,
                    0.0f,              0.0f,    1.0f,   0.0f,
                    0.0f,              0.0f,    0.0f,   1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>Z軸回りの回転行列を生成します.</summary>
///<param name="value">角度(インデックス角).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationZIdx( const u16 value, Matrix& result )
{
    result._11 = CosIdx( value );
    result._12 = SinIdx( value );
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = -SinIdx( value );
    result._22 =  CosIdx( value );
    result._23 =  0.0f;
    result._24 =  0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>指定された軸と角度から回転行列を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="rad">角度(ラジアン).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateFromAxisAngleRad( const Vector3& axis, const f32 rad )
{
    Matrix result;

    register f32 sine   = SinRad( rad );
    register f32 cosine = CosRad( rad );
    register f32 a      = 1.0f -cosine;
    register f32 ab     = axis.x * axis.y * a;
    register f32 bc     = axis.y * axis.z * a;
    register f32 ca     = axis.z * axis.x * a;
    register f32 tx     = axis.x * axis.x;
    register f32 ty     = axis.y * axis.y;
    register f32 tz     = axis.z * axis.z;

    result._11 = tx + cosine * ( 1.0f - tx );
    result._12 = ab + axis.z * sine;
    result._13 = ca - axis.y * sine;
    result._14 = 0.0f;

    result._21 = ab - axis.z * sine;
    result._22 = ty + cosine * ( 1.0f - ty );
    result._23 = bc + axis.x * sine;
    result._24 = 0.0f;

    result._31 = ca + axis.y * sine;
    result._32 = bc - axis.x * sine;
    result._33 = tz + cosine * ( 1.0f - tz );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;

    return result;
}

//------------------------------------------------------------------------------
///<summary>指定された軸と角度から回転行列を生成します.</summary>
///<param name="axis">回転軸.</param>
///<param name="rad">角度(ラジアン).</param>
///<param name="result">回転行列</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateFromAxisAngleRad( const Vector3& axis, const f32 rad, Matrix& result )
{
    f32 sine, cosine;
    SinCosRad( &sine, &cosine, rad );
    register f32 a      = 1.0f -cosine;
    register f32 ab     = axis.x * axis.y * a;
    register f32 bc     = axis.y * axis.z * a;
    register f32 ca     = axis.z * axis.x * a;
    register f32 tx     = axis.x * axis.x;
    register f32 ty     = axis.y * axis.y;
    register f32 tz     = axis.z * axis.z;

    result._11 = tx + cosine * ( 1.0f - tx );
    result._12 = ab + axis.z * sine;
    result._13 = ca - axis.y * sine;
    result._14 = 0.0f;

    result._21 = ab - axis.z * sine;
    result._22 = ty + cosine * ( 1.0f - ty );
    result._23 = bc + axis.x * sine;
    result._24 = 0.0f;

    result._31 = ca + axis.y * sine;
    result._32 = bc - axis.x * sine;
    result._33 = tz + cosine * ( 1.0f - tz );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;

}

//------------------------------------------------------------------------------
///<summary>指定された軸と角度から回転行列を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="deg">角度(度).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateFromAxisAngleDeg( const Vector3& axis, const f32 deg )
{
    Matrix result;

    f32 sine, cosine;
    SinCosDeg( &sine, &cosine, deg );
    register f32 a      = 1.0f -cosine;
    register f32 ab     = axis.x * axis.y * a;
    register f32 bc     = axis.y * axis.z * a;
    register f32 ca     = axis.z * axis.x * a;
    register f32 tx     = axis.x * axis.x;
    register f32 ty     = axis.y * axis.y;
    register f32 tz     = axis.z * axis.z;

    result._11 = tx + cosine * ( 1.0f - tx );
    result._12 = ab + axis.z * sine;
    result._13 = ca - axis.y * sine;
    result._14 = 0.0f;

    result._21 = ab - axis.z * sine;
    result._22 = ty + cosine * ( 1.0f - ty );
    result._23 = bc + axis.x * sine;
    result._24 = 0.0f;

    result._31 = ca + axis.y * sine;
    result._32 = bc - axis.x * sine;
    result._33 = tz + cosine * ( 1.0f - tz );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;

    return result;
}

//------------------------------------------------------------------------------
///<summary>指定された軸と角度から回転行列を生成します.</summary>
///<param name="axis">回転軸.</param>
///<param name="deg">角度(度).</param>
///<param name="result">回転行列</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateFromAxisAngleDeg( const Vector3& axis, const f32 deg, Matrix& result )
{
    f32 sine, cosine;
    SinCosDeg( &sine, &cosine, deg );
    register f32 a      = 1.0f -cosine;
    register f32 ab     = axis.x * axis.y * a;
    register f32 bc     = axis.y * axis.z * a;
    register f32 ca     = axis.z * axis.x * a;
    register f32 tx     = axis.x * axis.x;
    register f32 ty     = axis.y * axis.y;
    register f32 tz     = axis.z * axis.z;

    result._11 = tx + cosine * ( 1.0f - tx );
    result._12 = ab + axis.z * sine;
    result._13 = ca - axis.y * sine;
    result._14 = 0.0f;

    result._21 = ab - axis.z * sine;
    result._22 = ty + cosine * ( 1.0f - ty );
    result._23 = bc + axis.x * sine;
    result._24 = 0.0f;

    result._31 = ca + axis.y * sine;
    result._32 = bc - axis.x * sine;
    result._33 = tz + cosine * ( 1.0f - tz );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>指定された軸と角度から回転行列を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="idx">角度(インデックス角).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateFromAxisAngleIdx( const Vector3& axis, const u16 idx )
{
    Matrix result;

    f32 sine, cosine;
    SinCosIdx( &sine, &cosine, idx );
    register f32 a      = 1.0f -cosine;
    register f32 ab     = axis.x * axis.y * a;
    register f32 bc     = axis.y * axis.z * a;
    register f32 ca     = axis.z * axis.x * a;
    register f32 tx     = axis.x * axis.x;
    register f32 ty     = axis.y * axis.y;
    register f32 tz     = axis.z * axis.z;

    result._11 = tx + cosine * ( 1.0f - tx );
    result._12 = ab + axis.z * sine;
    result._13 = ca - axis.y * sine;
    result._14 = 0.0f;

    result._21 = ab - axis.z * sine;
    result._22 = ty + cosine * ( 1.0f - ty );
    result._23 = bc + axis.x * sine;
    result._24 = 0.0f;

    result._31 = ca + axis.y * sine;
    result._32 = bc - axis.x * sine;
    result._33 = tz + cosine * ( 1.0f - tz );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;

    return result;
}

//------------------------------------------------------------------------------
///<summary>指定された軸と角度から回転行列を生成します.</summary>
///<param name="axis">回転軸.</param>
///<param name="idx">角度(インデックス角).</param>
///<param name="result">回転行列</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateFromAxisAngleIdx( const Vector3& axis, const u16 idx, Matrix& result )
{
    f32 sine, cosine;
    SinCosIdx( &sine, &cosine, idx );
    register f32 a      = 1.0f -cosine;
    register f32 ab     = axis.x * axis.y * a;
    register f32 bc     = axis.y * axis.z * a;
    register f32 ca     = axis.z * axis.x * a;
    register f32 tx     = axis.x * axis.x;
    register f32 ty     = axis.y * axis.y;
    register f32 tz     = axis.z * axis.z;

    result._11 = tx + cosine * ( 1.0f - tx );
    result._12 = ab + axis.z * sine;
    result._13 = ca - axis.y * sine;
    result._14 = 0.0f;

    result._21 = ab - axis.z * sine;
    result._22 = ty + cosine * ( 1.0f - ty );
    result._23 = bc + axis.x * sine;
    result._24 = 0.0f;

    result._31 = ca + axis.y * sine;
    result._32 = bc - axis.x * sine;
    result._33 = tz + cosine * ( 1.0f - tz );
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = 0.0f;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から回転行列を生成します.</summary>
///<param name="yaw">ヨー角(ラジアン).</param>
///<param name="pitch">ピッチ角(ラジアン).</param>
///<param name="roll">ロール角(ラジアン).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationYawPitchRollRad( const f32 yaw, const f32 pitch, const f32 roll )
{
    Quaternion quaternion = Quaternion::CreateFromYawPitchRollRad( yaw, pitch, roll );
    return Matrix::CreateFromQuaternion( quaternion );
}

//------------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から回転行列を生成します.</summary>
///<param name="yaw">ヨー角(ラジアン).</param>
///<param name="pitch">ピッチ角(ラジアン).</param>
///<param name="roll">ロール角(ラジアン).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationYawPitchRollRad( const f32 yaw, const f32 pitch, const f32 roll, Matrix& result )
{
    Quaternion quaternion;
    Quaternion::CreateFromYawPitchRollRad( yaw, pitch, roll, quaternion );
    Matrix::CreateFromQuaternion( quaternion, result );
}

//------------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から回転行列を生成します.</summary>
///<param name="yaw">ヨー角(度).</param>
///<param name="pitch">ピッチ角(度).</param>
///<param name="roll">ロール角(度).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationYawPitchRollDeg( const f32 yaw, const f32 pitch, const f32 roll )
{
    Quaternion quaternion = Quaternion::CreateFromYawPitchRollDeg( yaw, pitch, roll );
    return Matrix::CreateFromQuaternion( quaternion );
}

//------------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から回転行列を生成します.</summary>
///<param name="yaw">ヨー角(度).</param>
///<param name="pitch">ピッチ角(度).</param>
///<param name="roll">ロール角(度).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationYawPitchRollDeg( const f32 yaw, const f32 pitch, const f32 roll, Matrix& result )
{
    Quaternion quaternion;
    Quaternion::CreateFromYawPitchRollDeg( yaw, pitch, roll, quaternion );
    Matrix::CreateFromQuaternion( quaternion, result );
}

//------------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から回転行列を生成します.</summary>
///<param name="yaw">ヨー角(インデックス角).</param>
///<param name="pitch">ピッチ角(インデックス角).</param>
///<param name="roll">ロール角(インデックス角).</param>
///<return>回転行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateRotationYawPitchRollIdx( const u16 yaw, const u16 pitch, const u16 roll )
{
    Quaternion quaternion = Quaternion::CreateFromYawPitchRollIdx( yaw, pitch, roll );
    return Matrix::CreateFromQuaternion( quaternion );
}

//------------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から回転行列を生成します.</summary>
///<param name="yaw">ヨー角(インデックス角).</param>
///<param name="pitch">ピッチ角(インデックス角).</param>
///<param name="roll">ロール角(インデックス角).</param>
///<param name="result">回転行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateRotationYawPitchRollIdx( const u16 yaw, const u16 pitch, const u16 roll, Matrix& result )
{
    Quaternion quaternion;
    Quaternion::CreateFromYawPitchRollIdx( yaw, pitch, roll, quaternion );
    Matrix::CreateFromQuaternion( quaternion, result );
}

//------------------------------------------------------------------------------
///<summary>ビュー行列を生成します.</summary>
///<param name="position">カメラ位置.</param>
///<param name="target">注視点.</param>
///<param name="upward">上向きベクトル.</param>
///<return>ビュー行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateLookAt
(
    const Vector3& position,
    const Vector3& target,
    const Vector3& upward
)
{
    Vector3 zAxis(
        position.x - target.x,
        position.y - target.y,
        position.z - target.z );
    zAxis.Normalize();

    Vector3 xAxis = Vector3::Cross( upward, zAxis );
    xAxis.Normalize();

    Vector3 yAxis = Vector3::Cross( xAxis, xAxis );
    yAxis.Normalize();

    return Matrix(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0.0f,

        xAxis.y,
        yAxis.y,
        zAxis.y,
        0.0f,

        xAxis.z,
        yAxis.z,
        zAxis.z,
        0.0f,

        -Vector3::Dot( xAxis, position ),
        -Vector3::Dot( yAxis, position ),
        -Vector3::Dot( zAxis, position ),
        1.0f );
}

//------------------------------------------------------------------------------
///<summary>ビュー行列を生成します.</summary>
///<param name="position">カメラ位置.</param>
///<param name="target">注視点.</param>
///<param name="upward">上向きベクトル.</param>
///<param name="result">ビュー行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateLookAt
(
    const Vector3& position,
    const Vector3& target, 
    const Vector3& upward,
    Matrix& result
)
{
    Vector3 zAxis(
        position.x - target.x,
        position.y - target.y,
        position.z - target.z );
    zAxis.Normalize();

    Vector3 xAxis = Vector3::Cross( upward, zAxis );
    xAxis.Normalize();

    Vector3 yAxis = Vector3::Cross( xAxis, xAxis );
    yAxis.Normalize();

    result._11 = xAxis.x;
    result._12 = yAxis.x;
    result._13 = zAxis.x;
    result._14 = 0.0f;

    result._21 = xAxis.y;
}

//------------------------------------------------------------------------------
///<summary>透視投影行列を生成します.</summary>
///<param name="width">ビューボリュームの幅.</param>
///<param name="height">ビューボリュームの高さ.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>透視投影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreatePerspective
(
    const f32 width,
    const f32 height,
    const f32 nearClip,
    const f32 farClip
)
{
    register f32 diff = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( diff   != 0.0f );
    register f32 invDiff = 1.0f / diff;

    return Matrix(
        2.0f * nearClip / width,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        2.0f * nearClip / height,
        0.0f,
        0.0f,

        0.0f,
        0.0f,
        farClip * invDiff,
        ( nearClip * farClip ) / invDiff,

        0.0f,
        0.0f,
        -1.0f,
        0.0f
    );
}

//------------------------------------------------------------------------------
///<summary>透視投影行列を生成します.</summary>
///<param name="width">ビューボリュームの幅.</param>
///<param name="height">ビューボリュームの高さ.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="reuslt">透視投影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreatePerspective
(
    const f32 width,
    const f32 height,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 diff = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( diff   != 0.0f );
    register f32 invDiff = 1.0f / diff;

    result._11 = 2.0f * nearClip / width;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = 2.0f * nearClip / height;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = farClip * invDiff;
    result._34 = ( nearClip * farClip ) / invDiff;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = -1.0f;
    result._44 = 0.0f;
}

//------------------------------------------------------------------------------
///<summary>視野角に基づいて透視投影行列を生成します.</summary>
///<param name="fieldOfView">視野角(ラジアン).</param>
///<param name="aspectRatio">アスペクト比.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>透視投影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreatePerspectiveFieldOfViewRad
(
    const f32 fieldOfView,
    const f32 aspectRatio,
    const f32 nearClip,
    const f32 farClip
)
{
    register f32 diff = nearClip - farClip;
    register f32 tanFov = TanRad( fieldOfView * 0.5f );
    assert( aspectRatio != 0.0f );
    assert( diff        != 0.0f );
    assert( tanFov      != 0.0f );
    register f32 yScale  = 1.0f / tanFov;
    register f32 xScale  = yScale / aspectRatio;
    register f32 invDiff = 1.0f / diff;

    return Matrix(
        xScale,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        yScale,
        0.0f,
        0.0f,

        0.0f,
        0.0f,
        nearClip * invDiff,
        -1.0f,

        0.0f,
        0.0f,
        ( nearClip * farClip ) * invDiff,
        0.0f
    );
}

//------------------------------------------------------------------------------
///<summary>視野角に基づいて透視投影行列を生成します.</summary>
///<param name="fieldOfView">視野角(ラジアン).</param>
///<param name="aspectRatio">アスペクト比.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="result">透視投影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreatePerspectiveFieldOfViewRad
(
    const f32 fieldOfView,
    const f32 aspectRatio,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 diff = nearClip - farClip;
    register f32 tanFov = TanRad( fieldOfView * 0.5f );
    assert( aspectRatio != 0.0f );
    assert( diff        != 0.0f );
    assert( tanFov      != 0.0f );
    register f32 yScale  = 1.0f / tanFov;
    register f32 xScale  = yScale / aspectRatio;
    register f32 invDiff = 1.0f / diff;

    result._11 = xScale;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = yScale;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = nearClip * invDiff;
    result._34 = -1.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = ( nearClip * farClip ) * invDiff;
    result._44 = 0.0f;
}

//------------------------------------------------------------------------------
///<summary>視野角に基づいて透視投影行列を生成します.</summary>
///<param name="fieldOfView">視野角(度).</param>
///<param name="aspectRatio">アスペクト比.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>透視投影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreatePerspectiveFieldOfViewDeg
(
    const f32 fieldOfView,
    const f32 aspectRatio,
    const f32 nearClip,
    const f32 farClip
)
{
    register f32 diff = nearClip - farClip;
    register f32 tanFov = TanDeg( fieldOfView * 0.5f );
    assert( aspectRatio != 0.0f );
    assert( diff        != 0.0f );
    assert( tanFov      != 0.0f );
    register f32 yScale  = 1.0f / tanFov;
    register f32 xScale  = yScale / aspectRatio;
    register f32 invDiff = 1.0f / diff;

    return Matrix(
        xScale,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        yScale,
        0.0f,
        0.0f,

        0.0f,
        0.0f,
        nearClip * invDiff,
        -1.0f,

        0.0f,
        0.0f,
        ( nearClip * farClip ) * invDiff,
        0.0f
    );
}

//------------------------------------------------------------------------------
///<summary>視野角に基づいて透視投影行列を生成します.</summary>
///<param name="fieldOfView">視野角(度).</param>
///<param name="aspectRatio">アスペクト比.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="result">透視投影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreatePerspectiveFieldOfViewDeg
(
    const f32 filedOfView,
    const f32 aspectRatio,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 diff = nearClip - farClip;
    register f32 tanFov = TanDeg( filedOfView * 0.5f );
    assert( aspectRatio != 0.0f );
    assert( diff        != 0.0f );
    assert( tanFov      != 0.0f );
    register f32 yScale  = 1.0f / tanFov;
    register f32 xScale  = yScale / aspectRatio;
    register f32 invDiff = 1.0f / diff;

    result._11 = xScale;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = yScale;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = nearClip * invDiff;
    result._34 = -1.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = ( nearClip * farClip ) * invDiff;
    result._44 = 0.0f;
}

//------------------------------------------------------------------------------
///<summary>視野角に基づいて透視投影行列を生成します.</summary>
///<param name="fieldOfView">視野角(インデックス角).</param>
///<param name="aspectRatio">アスペクト比.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>透視投影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreatePerspectiveFieldOfViewIdx
( 
    const u16 filedOfView,
    const f32 aspectRatio,
    const f32 nearClip,
    const f32 farClip
)
{
    register f32 diff = nearClip - farClip;
    register f32 tanFov = TanIdx( filedOfView / 2 );
    assert( aspectRatio != 0.0f );
    assert( diff        != 0.0f );
    assert( tanFov      != 0.0f );
    register f32 yScale  = 1.0f / tanFov;
    register f32 xScale  = yScale / aspectRatio;
    register f32 invDiff = 1.0f / diff;

    return Matrix(
        xScale,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        yScale,
        0.0f,
        0.0f,

        0.0f,
        0.0f,
        nearClip * invDiff,
        -1.0f,

        0.0f,
        0.0f,
        ( nearClip * farClip ) * invDiff,
        0.0f
    );
}

//------------------------------------------------------------------------------
///<summary>視野角に基づいて透視投影行列を生成します.</summary>
///<param name="fieldOfView">視野角(インデックス角).</param>
///<param name="aspectRatio">アスペクト比.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="result">透視投影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreatePerspectiveFieldOfViewIdx
(
    const u16 filedOfView,
    const f32 aspectRatio,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 diff = nearClip - farClip;
    register f32 tanFov = TanIdx( filedOfView / 2 );
    assert( aspectRatio != 0.0f );
    assert( diff        != 0.0f );
    assert( tanFov      != 0.0f );
    register f32 yScale  = 1.0f / tanFov;
    register f32 xScale  = yScale / aspectRatio;
    register f32 invDiff = 1.0f / diff;

    result._11 = xScale;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = yScale;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = nearClip * invDiff;
    result._34 = -1.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = ( nearClip * farClip ) * invDiff;
    result._44 = 0.0f;
}

//------------------------------------------------------------------------------
///<summary>カスタマイズした透視投影行列を生成します.</summary>
///<param name="left">ビューボリュームの最小X値.</param>
///<param name="right">ビューボリュームの最大X値.</param>
///<param name="bottom">ビューボリュームの最小Y値.</param>
///<param name="top">ビューボリュームの最大Y値.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>透視投影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreatePerspectiveOffcenter
(
     const f32 left,
     const f32 right,
     const f32 bottom,
     const f32 top,
     const f32 nearClip,
     const f32 farClip
)
{
    register f32 width = right - left;
    register f32 height = top - bottom;
    register f32 depth  = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( depth  != 0.0f );
    register f32 invWidth  = 1.0f / width;
    register f32 invHeight = 1.0f / height;
    register f32 invDepth  = 1.0f / depth;

    return Matrix(
        2.0f * nearClip * invWidth,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        2.0f * nearClip * invHeight,
        0.0f,
        0.0f,

        ( left + right ) * invWidth,
        ( top + bottom ) * invHeight,
        farClip * invDepth,
        -1.0f,

        0.0f,
        0.0f,
        nearClip * farClip * invDepth,
        0.0f
    );
}

//------------------------------------------------------------------------------
///<summary>カスタマイズした透視投影行列を生成します.</summary>
///<param name="left">ビューボリュームの最小X値.</param>
///<param name="right">ビューボリュームの最大X値.</param>
///<param name="bottom">ビューボリュームの最小Y値.</param>
///<param name="top">ビューボリュームの最大Y値.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="reuslt">透視投影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreatePerspectiveOffcenter
(
    const f32 left,
    const f32 right,
    const f32 top,
    const f32 bottom,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 width = right - left;
    register f32 height = top - bottom;
    register f32 depth  = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( depth  != 0.0f );
    register f32 invWidth  = 1.0f / width;
    register f32 invHeight = 1.0f / height;
    register f32 invDepth  = 1.0f / depth;

    result._11 = 2.0f * nearClip * invWidth;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = 2.0f * nearClip * invHeight;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = ( left + right ) * invWidth;
    result._32 = ( top + bottom ) * invHeight;
    result._33 = farClip * invDepth;
    result._34 = -1.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = nearClip * farClip * invDepth;
    result._44 = 0.0f;
}

//------------------------------------------------------------------------------
///<summary>正射影行列を生成します.</summary>
///<param name="width">ビューボリュームの幅.</param>
///<param name="height">ビューボリュームの高さ.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>正射影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateOrthographic
(
    const f32 width,
    const f32 height,
    const f32 nearClip,
    const f32 farClip
)
{
    register f32 depth = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( depth  != 0.0f );
    register f32 invDepth = 1.0f / depth;

    return Matrix(
        2.0f / width,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        2.0f / height,
        0.0f,
        0.0f,

        0.0f,
        0.0f,
        1.0f * invDepth,
        0.0f,

        0.0f,
        0.0f,
        nearClip * invDepth,
        1.0f 
    );
}

//------------------------------------------------------------------------------
///<summary>正射影行列を生成します.</summary>
///<param name="width">ビューボリュームの幅.</param>
///<param name="height">ビューボリュームの高さ.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="result">正射影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateOrthographic
(
    const f32 width,
    const f32 height,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 depth = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( depth  != 0.0f );
    register f32 invDepth = 1.0f / depth;

    result._11 = 2.0f / width;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = 2.0f / height;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f * invDepth;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = nearClip * invDepth;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>カスタマイズした正射影行列を生成します.</summary>
///<param name="left">ビューボリュームの最小X値.</param>
///<param name="right">ビューボリュームの最大X値.</param>
///<param name="bottom">ビューボリュームの最小Y値.</param>
///<param name="top">ビューボリュームの最大Y値.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<return>正射影行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::CreateOrthographicOffcenter
(
    const f32 left,
    const f32 right,
    const f32 bottom,
    const f32 top,
    const f32 nearClip,
    const f32 farClip
)
{
    register f32 width  = right - left;
    register f32 height = bottom - top;
    register f32 depth  = farClip - nearClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( depth  != 0.0f );

    register f32 invWidth  = 1.0f / width;
    register f32 invHeight = 1.0f / height;
    register f32 invDepth  = 1.0f / depth;

    return Matrix(
        2.0f * invWidth,
        0.0f,
        0.0f,
        0.0f,

        0.0f,
        2.0f * invHeight,
        0.0f,
        0.0f,

        0.0f,
        0.0f,
        1.0f * invDepth,
        0.0f,

        0.0f,
        0.0f,
        nearClip * invDepth,
        1.0f
    );
}

//------------------------------------------------------------------------------
///<summary>カスタマイズした正射影行列を生成します.</summary>
///<param name="left">ビューボリュームの最小X値.</param>
///<param name="right">ビューボリュームの最大X値.</param>
///<param name="bottom">ビューボリュームの最小Y値.</param>
///<param name="top">ビューボリュームの最大Y値.</param>
///<param name="nearClip">近クリップ平面までの距離.</param>
///<param name="farClip">遠クリップ平面までの距離.</param>
///<param name="result">正射影行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::CreateOrthographicOffcenter
(
    const f32 left,
    const f32 right,
    const f32 bottom,
    const f32 top,
    const f32 nearClip,
    const f32 farClip,
    Matrix& result
)
{
    register f32 width  = right - left;
    register f32 height = bottom - top;
    register f32 depth  = nearClip - farClip;
    assert( width  != 0.0f );
    assert( height != 0.0f );
    assert( depth  != 0.0f );

    register f32 invWidth  = 1.0f / width;
    register f32 invHeight = 1.0f / height;
    register f32 invDepth  = 1.0f / depth;

    result._11 = 2.0f * invWidth;
    result._12 = 0.0f;
    result._13 = 0.0f;
    result._14 = 0.0f;

    result._21 = 0.0f;
    result._22 = 2.0f * invHeight;
    result._23 = 0.0f;
    result._24 = 0.0f;

    result._31 = 0.0f;
    result._32 = 0.0f;
    result._33 = 1.0f * invDepth;
    result._34 = 0.0f;

    result._41 = 0.0f;
    result._42 = 0.0f;
    result._43 = nearClip * invDepth;
    result._44 = 1.0f;
}

//------------------------------------------------------------------------------
///<summary>2つの行列を線形補間します.</summary>
///<param name="a">入力行列.</param>
///<param name="b">入力行列.</param>
///<param name="amount">補間係数.</param>
///<return>線形補間した行列を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Matrix  Matrix::Lerp( const Matrix& a, const Matrix& b, const f32 amount )
{
    register f32 s = 1.0f - amount;
    register f32 t = amount;
    return Matrix(
        ( s * a._11 ) + ( t * b._11 ),
        ( s * a._12 ) + ( t * b._12 ),
        ( s * a._13 ) + ( t * b._13 ),
        ( s * a._14 ) + ( t * b._14 ),

        ( s * a._21 ) + ( t * b._21 ),
        ( s * a._22 ) + ( t * b._22 ),
        ( s * a._23 ) + ( t * b._23 ),
        ( s * a._24 ) + ( t * b._24 ),

        ( s * a._31 ) + ( t * b._31 ),
        ( s * a._32 ) + ( t * b._32 ),
        ( s * a._33 ) + ( t * b._33 ),
        ( s * a._34 ) + ( t * b._34 ),

        ( s * a._41 ) + ( t * b._41 ),
        ( s * a._42 ) + ( t * b._42 ),
        ( s * a._43 ) + ( t * b._43 ),
        ( s * a._44 ) + ( t * b._44 )
    );
}

//------------------------------------------------------------------------------
///<summary>2つの行列を線形補間します.</summary>
///<param name="a">入力行列.</param>
///<param name="b">入力行列.</param>
///<param name="amount">補間係数.</param>
///<param name="result">線形補間した行列.</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::Lerp( const Matrix& a, const Matrix& b, const f32 amount, Matrix& result )
{
    register f32 s = 1.0f - amount;
    register f32 t = amount;

    result._11 = ( s * a._11 ) + ( t * b._11 );
    result._12 = ( s * a._12 ) + ( t * b._12 );
    result._13 = ( s * a._13 ) + ( t * b._13 );
    result._14 = ( s * a._14 ) + ( t * b._14 );

    result._21 = ( s * a._21 ) + ( t * b._21 );
    result._22 = ( s * a._22 ) + ( t * b._22 );
    result._23 = ( s * a._23 ) + ( t * b._23 );
    result._24 = ( s * a._24 ) + ( t * b._24 );

    result._31 = ( s * a._31 ) + ( t * b._31 );
    result._32 = ( s * a._32 ) + ( t * b._32 );
    result._33 = ( s * a._33 ) + ( t * b._33 );
    result._34 = ( s * a._34 ) + ( t * b._34 );

    result._41 = ( s * a._41 ) + ( t * b._41 );
    result._42 = ( s * a._42 ) + ( t * b._42 );
    result._43 = ( s * a._43 ) + ( t * b._43 );
    result._44 = ( s * a._44 ) + ( t * b._44 );
}

//------------------------------------------------------------------------------
///<summary>行列から平行移動成分を取得します</summary>
///<param name="value">入力行列</param>
///<return>平行移動成分を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetTranslate( const Matrix& value )
{ return Vector3( value._41, value._42, value._43 ); }

//------------------------------------------------------------------------------
///<summary>行列から平行移動成分を取得します.</summary>
///<param name="value">入力行列</param>
///<param name="result">平行移動成分</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::GetTranslate( const Matrix& value, Vector3& result )
{
    result.x = value._41;
    result.y = value._42;
    result.z = value._43;
}

//------------------------------------------------------------------------------
///<summary>行列から拡大・縮小成分を取得します.</summary>
///<param name="value">入力行列</param>
///<return>拡大・縮小成分を返却します.</return>
//------------------------------------------------------------------------------
ASDX_INLINE
Vector3 Matrix::GetScale( const Matrix& value )
{
    return Vector3(
        sqrtf( ( value._11 * value._11 ) + ( value._12 * value._12 ) + ( value._13 * value._13 ) ),
        sqrtf( ( value._21 * value._21 ) + ( value._22 * value._22 ) + ( value._23 * value._23 ) ),
        sqrtf( ( value._31 * value._31 ) + ( value._32 * value._32 ) + ( value._33 * value._33 ) )
    );
}

//------------------------------------------------------------------------------
///<summary>行列から拡大・縮小成分を取得します.</summary>
///<param name="value">入力行列</param>
///<param name="result">拡大・縮小成分</param>
//------------------------------------------------------------------------------
ASDX_INLINE
void    Matrix::GetScale( const Matrix& value, Vector3& result )
{
    result.x = sqrtf( ( value._11 * value._11 ) + ( value._12 * value._12 ) + ( value._13 * value._13 ) );
    result.y = sqrtf( ( value._21 * value._21 ) + ( value._22 * value._22 ) + ( value._23 * value._23 ) );
    result.z = sqrtf( ( value._31 * value._31 ) + ( value._32 * value._32 ) + ( value._33 * value._33 ) );
}


////////////////////////////////////////////////////////////////////////////////
// Quaternion class
////////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">乗算するスカラー値</param>
///<param name="value">乗算される四元数.</param>
///<return>乗算結果を返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion operator * ( const f32 scalar, const Quaternion& value )
{
    return Quaternion(
        value.x * scalar,
        value.y * scalar,
        value.z * scalar,
        value.w * scalar );
}

//----------------------------------------------------------------------------
///<summary>コンストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::Quaternion()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="pValues">要素数4の配列</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::Quaternion( const f32* pValues )
{
    assert( pValues != NULL );
    x = pValues[ 0 ];
    y = pValues[ 1 ];
    z = pValues[ 2 ];
    w = pValues[ 3 ];
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="nx">X成分</param>
///<param name="ny">Y成分</param>
///<param name="nz">Z成分</param>
///<param name="nw">W成分</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::Quaternion( const f32 nx, const f32 ny, const f32 nz, const f32 nw )
{
    x = nx;
    y = ny;
    z = nz;
    w = nw;
}

//----------------------------------------------------------------------------
///<summary>引数付きコンストラクタです.</summary>
///<param name="vector">四元数のベクトル要素</param>
///<param name="scalar">四元数の回転要素</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::Quaternion( const Vector3& vector, const f32 scalar )
{
    x = vector.x;
    y = vector.y;
    z = vector.z;
    w = scalar;
}

//----------------------------------------------------------------------------
///<summary>コピーコンストラクタです.</summary>
///<param name="value">コピー元の値.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::Quaternion( const Quaternion& value )
{
    x = value.x;
    y = value.y;
    z = value.z;
    w = value.w;
}

//----------------------------------------------------------------------------
///<summary>デストラクタです.</summary>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::~Quaternion()
{ /* DO_NOTHING */ }

//----------------------------------------------------------------------------
///<summary>f32*型へのキャストです.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::operator f32* () 
{ return &x; }

//----------------------------------------------------------------------------
///<summary>const f32*型へのキャストです.</summary>
///<return>最初の要素へのポインタを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion::operator const f32* () const
{ return &x; }

//----------------------------------------------------------------------------
///<summary>加算代入演算子です.</summary>
///<param name="value">加算する値.</param>
///<return>加算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::operator += ( const Quaternion& value )
{
    x += value.x;
    y += value.y;
    z += value.z;
    w += value.w;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>減算代入演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::operator -= ( const Quaternion& value )
{
    x -= value.x;
    y -= value.y;
    z -= value.z;
    w -= value.w;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="value">乗算する値.</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::operator *= ( const Quaternion& value )
{
    register f32 f12 = ( y * value.z ) - ( z * value.y );
    register f32 f11 = ( z * value.x ) - ( x * value.z );
    register f32 f10 = ( x * value.y ) - ( y * value.x );
    register f32 f09 = ( x * value.x ) + ( y * value.y ) + ( z * value.z );

    register f32 nx = ( x * value.w ) + ( value.x * w ) + f12;
    register f32 ny = ( y * value.w ) + ( value.x * w ) + f11;
    register f32 nz = ( z * value.w ) + ( value.z * w ) + f10;
    register f32 nw = ( w * value.w ) - f09;

    x = nx;
    y = ny;
    z = nz;
    w = nw;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>乗算代入演算子です.</summary>
///<param name="scalar">スカラー乗算する値.</param>
///<return>スカラー乗算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::operator *= ( const f32 scalar )
{
    x *= scalar;
    y *= scalar;
    z *= scalar;
    w *= scalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>除算代入演算子です.</summary>
///<param name="scalar">スカラー除算する値.</param>
///<return>スカラー除算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::operator /= ( const f32 scalar )
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    x *= invScalar;
    y *= invScalar;
    z *= invScalar;
    w *= invScalar;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>正符号演算子です.</summary>
///<return>自分自身の値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator + () const
{ return (*this); }

//----------------------------------------------------------------------------
///<summary>負符号演算子です.</summary>
///<return>各成分の符号を反転した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator - () const
{ return Quaternion( -x, -y, -z, -w ); }

//----------------------------------------------------------------------------
///<summary>加算演算子です.</summary>
///<param name="value">加算する値.</param>
///<return>加算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator + ( const Quaternion& value ) const
{
    return Quaternion(
        x + value.x,
        y + value.y,
        z + value.z,
        w + value.w );
}

//----------------------------------------------------------------------------
///<summary>減算演算子です.</summary>
///<param name="value">減算する値.</param>
///<return>減算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator - ( const Quaternion& value ) const 
{
    return Quaternion(
        x - value.x,
        y - value.y,
        z - value.z,
        w - value.w );
}

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="value">乗算する値.</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator * ( const Quaternion& value ) const
{
    register f32 f12 = ( y * value.z ) - ( z * value.y );
    register f32 f11 = ( z * value.x ) - ( x * value.z );
    register f32 f10 = ( x * value.y ) - ( y * value.x );
    register f32 f09 = ( x * value.x ) + ( y * value.y ) + ( z * value.z );

    return Quaternion(
        ( x * value.w ) + ( value.x * w ) + f12,
        ( y * value.w ) + ( value.x * w ) + f11,
        ( z * value.w ) + ( value.z * w ) + f10,
        ( w * value.w ) - f09 );
}

//----------------------------------------------------------------------------
///<summary>乗算演算子です.</summary>
///<param name="scalar">スカラー乗算する値.</param>
///<return>スカラー乗算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator * ( const f32 scalar ) const
{
    return Quaternion(
        x * scalar,
        y * scalar,
        z * scalar,
        w * scalar );
}

//----------------------------------------------------------------------------
///<summary>除算演算子です.</summary>
///<param name="scalar">スカラー除算する値</param>
///<return>スカラー除算した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::operator / ( const f32 scalar ) const
{
    assert( scalar != 0.0f );
    register f32 invScalar = 1.0f / scalar;
    return Quaternion(
        x * invScalar,
        y * invScalar,
        z * invScalar,
        w * invScalar );
}

//----------------------------------------------------------------------------
///<summary>代入演算子です.</summary>
///<param name="value">代入する値.</param>
///<return>代入結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::operator = ( const Quaternion& value )
{
    x = value.x;
    y = value.y;
    z = value.z;
    w = value.w;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>等価比較演算子です</summary>
///<param name="value">比較する値.</param>
///<return>等価であればtrue, 非等価であればfalseを返却します</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Quaternion::operator == ( const Quaternion& value ) const
{
    return ( x == value.x )
        && ( y == value.y )
        && ( z == value.z )
        && ( w == value.w );
}

//----------------------------------------------------------------------------
///<summary>非等価比較演算子です.</summary>
///<param name="value">比較する値.</param>
///<return>非等価であればtrue, 等価であればtrueを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool        Quaternion::operator != ( const Quaternion& value ) const
{
    return ( x != value.x )
        || ( y != value.y )
        || ( z != value.z )
        || ( w != value.w );
}

//----------------------------------------------------------------------------
///<summary>四元数の長さを求めます.</summary>
///<return>四元数の長さを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Quaternion::Length() const
{ return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) ); }

//----------------------------------------------------------------------------
///<summary>四元数の長さの2乗値を求めます.</summary>
///<return>四元数の長さの2乗値を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Quaternion::LengthSq() const
{ return ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ); }

//----------------------------------------------------------------------------
///<summary>正規化した四元数を求めます.</summary>
///<return>正規化した四元数を求め,その結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::UnitVector() const
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    assert( mag != 0.0f );
    register f32 invMag = 1.0f / mag;
    return Quaternion(
        x * invMag,
        y * invMag,
        z * invMag,
        w * invMag );
}

//----------------------------------------------------------------------------
///<summary>四元数の共役を求めます.</summary>
///<return>共役を求めた結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::Conjugate()
{
    x = -x;
    y = -y;
    z = -z;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>単位四元数化します.</summary>
///<return>単位四元数化した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::Identity()
{
    x = 0.0f;
    y = 0.0f;
    z = 0.0f;
    w = 1.0f;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>逆四元数化します.</summary>
///<return>逆四元数化した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::Inverse()
{
    register f32 magSq = ( x * x ) + ( y * y ) + ( z * z ) + ( w * w );
    assert( magSq != 0.0f );
    register f32 invMagSq = 1.0f / magSq;
    x = -x * invMagSq;
    y = -y * invMagSq;
    z = -z * invMagSq;
    w =  w * invMagSq;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>四元数を正規化します.</summary>
///<return>正規化した四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::Normalize()
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    assert( mag != 0.0f );
    register f32 invMag = 1.0f / mag;
    x *= invMag;
    y *= invMag;
    z *= invMag;
    w *= invMag;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>零除算を考慮して，四元数を正規化を試みます.</summary>
///<param name="value">長さが0の場合に設定する四元数.</param>
///<return>長さが0であればvalue, 0でなければ正規化した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::SafeNormalize( const Quaternion& value )
{
    register f32 mag = sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    if ( mag == 0.0f )
    {
        x = value.x;
        y = value.y;
        z = value.z;
        w = value.w;
    }
    else
    {
        register f32 invMag = 1.0f / mag;
        x *= invMag;
        y *= invMag;
        z *= invMag;
        w *= invMag;
    }
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>四元数を連結します.</summary>
///<param name="value">連結する四元数.</param>
///<return>最初の回転とvalueによる回転を表す四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion& Quaternion::Concatenate( const Quaternion& value )
{
    register f32 nx = (( value.x * w ) + ( x * value.w )) + ( value.y * z ) - ( value.z * y );
    register f32 ny = (( value.y * w ) + ( y * value.w )) + ( value.z * x ) - ( value.x * z );
    register f32 nz = (( value.z * w ) + ( z * value.w )) + ( value.x * y ) - ( value.y * x );
    register f32 nw = ( value.w * w ) - (( value.x * x ) + ( value.y * y )) + ( value.z * z );
    x = nx;
    y = ny;
    z = nz;
    w = nw;
    return (*this);
}

//----------------------------------------------------------------------------
///<summary>内積を求めます.</summary>
///<param name="value">入力四元数</param>
///<return>内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32         Quaternion::Dot( const Quaternion& value ) const
{ return ( x * value.x ) + ( y * value.y ) + ( z * value.z ) + ( w * value.w ); }


//////////////////////////////////////////////////////////////////////////////
// Quaternion Methods
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
///<summary>単位四元数にします.</summary>
///<param name="value">単位四元数化する値.</param>
///<return>単位四元数にした結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Identity( Quaternion& value )
{
    value.x = 0.0f;
    value.y = 0.0f;
    value.z = 0.0f;
    value.w = 1.0f;
}

//----------------------------------------------------------------------------
///<summary>単位四元数かどうかチェックします.</summary>
///<param name="value">チェックする値.</param>
///<return>単位四元数であればtrue, 非単位四元数であればfalseを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
bool    Quaternion::IsIdentity( const Quaternion& value )
{
    return (
        ( value.x == 0.0f )
     && ( value.y == 0.0f )
     && ( value.z == 0.0f )
     && ( value.w == 1.0f )
    );
}

//----------------------------------------------------------------------------
///<summary>四元数同士の乗算を行います.</summary>
///<param name="a">入力四元数</param>
///<param name="b">入力四元数</param>
///<return>乗算結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Multiply( const Quaternion& a, const Quaternion& b )
{
    register f32 X = ( a.y * b.z ) - ( a.z * b.y );
    register f32 Y = ( a.z * b.x ) - ( a.x * b.z );
    register f32 Z = ( a.x * b.y ) - ( a.y * b.x );
    register f32 W = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z );

    return Quaternion(
        ( a.x * b.w ) + ( b.x * a.w ) + X,
        ( a.y * b.w ) + ( b.y * a.w ) + Y,
        ( a.z * b.w ) + ( b.z * a.w ) + Z,
        ( a.w * b.w ) + W
    );
}

//----------------------------------------------------------------------------
///<summary>四元数同士の乗算を行います.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="result">乗算結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Multiply( const Quaternion& a, const Quaternion& b, Quaternion& result )
{
    register f32 X = ( a.y * b.z ) - ( a.z * b.y );
    register f32 Y = ( a.z * b.x ) - ( a.x * b.z );
    register f32 Z = ( a.x * b.y ) - ( a.y * b.x );
    register f32 W = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z );

    result.x = ( a.x * b.w ) + ( b.x * a.w ) + X;
    result.y = ( a.y * b.w ) + ( b.y * a.w ) + Y;
    result.z = ( a.z * b.w ) + ( b.z * a.w ) + Z;
    result.w = ( a.w * b.w ) + W;
}

//----------------------------------------------------------------------------
///<summary>四元数の内積を求めます.</summary>
///<param name="a">入力四元数</param>
///<param name="b">入力四元数</param>
///<return>四元数の内積を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
f32     Quaternion::Dot( const Quaternion& a, const Quaternion& b )
{
    return ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w );
}

//----------------------------------------------------------------------------
///<summary>四元数の内積を求めます.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="result">四元数の内積.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Dot( const Quaternion& a, const Quaternion& b, f32& result )
{
    result = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w );
}

//----------------------------------------------------------------------------
///<summary>四元数の共役を求めます.</summary>
///<param name="value">共役を求めたい四元数.</param>
///<return>四元数の共役を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Conjugate( const Quaternion& value )
{
    return Quaternion( -value.x, -value.y, -value.z, value.w );
}

//----------------------------------------------------------------------------
///<summary>四元数の共役を求めます.</summary>
///<param name="value">共役を求めたい四元数.</param>
///<param name="result">四元数の共役</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Conjugate( const Quaternion& value, Quaternion& result )
{
    result.x = -value.x;
    result.y = -value.y;
    result.z = -value.z;
    result.w = value.w;
}

//----------------------------------------------------------------------------
///<summary>2つの四元数を連結します.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<return>aによる回転とbによる回転を表す四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Concatenate( const Quaternion& a, const Quaternion& b )
{
    return Quaternion(
        (( b.x * a.w ) + ( a.x * b.w )) + ( b.y * a.z ) - ( b.z * a.y ),
        (( b.y * a.w ) + ( a.y * b.w )) + ( b.z * a.x ) - ( b.x * a.z ),
        (( b.z * a.w ) + ( a.z * b.w )) + ( b.x * a.y ) - ( b.y * a.x ),
        ( b.w * a.w ) - (( b.x * a.x ) + ( b.y * a.y )) + ( b.z * a.z )
   );
}

//----------------------------------------------------------------------------
///<summary>2つの四元数を連結します.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="result">aによる回転とbによる回転を表すを四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Concatenate( const Quaternion& a, const Quaternion& b, Quaternion& result )
{
    result.x = (( b.x * a.w ) + ( a.x * b.w )) + ( b.y * a.z ) - ( b.z * a.y );
    result.y = (( b.y * a.w ) + ( a.y * b.w )) + ( b.z * a.x ) - ( b.x * a.z );
    result.z = (( b.z * a.w ) + ( a.z * b.w )) + ( b.x * a.y ) - ( b.y * a.x );
    result.w = ( b.w * a.w ) - (( b.x * a.x ) + ( b.y * a.y )) + ( b.z * a.z );
}

//----------------------------------------------------------------------------
///<summary>四元数を正規化します.</summary>
///<param name="value">入力四元数</param>
///<return>正規化した四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Normalize( const Quaternion& value )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ) );
    assert( mag != 0.0f );

    register f32 invMag = 1.0f / mag;
    return Quaternion(
        value.x * invMag,
        value.y * invMag,
        value.z * invMag,
        value.w * invMag 
    );
}

//----------------------------------------------------------------------------
///<summary>四元数を正規化します.</summary>
///<param name="value">入力四元数.</param>
///<param name="result">四元数を正規化した結果.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Normalize( const Quaternion& value, Quaternion& result )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ) );
    assert( mag != 0.0f );

    register f32 invMag = 1.0f / mag;
    result.x = value.x * invMag;
    result.y = value.y * invMag;
    result.z = value.z * invMag;
    result.w = value.w * invMag;
}

//----------------------------------------------------------------------------
///<summary>零除算を考慮して正規化を試みます.</summary>
///<param name="value">入力四元数.</param>
///<param name="set">長さが0の場合に設定する四元数.</param>
///<return>長さが0でなければ正規化した四元数，長さが0であればsetを返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::SafeNormalize( const Quaternion& value, const Quaternion& set )
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ) );
    if ( mag != 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        return Quaternion(
            value.x * invMag,
            value.y * invMag,
            value.z * invMag,
            value.w * invMag 
        );
    }
    else
    {
        return Quaternion(
            set.x,
            set.y,
            set.z,
            set.w 
        );
    }
}

//----------------------------------------------------------------------------
///<summary>零除算を考慮して正規化を試みます.</summary>
///<param name="value">入力四元数.</param>
///<param name="set">長さが0の場合に設定する四元数.</param>
///<param name="result">長さが0でなければ正規化した四元数，長さが0であればsetを返却します.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::SafeNormalize
(
    const Quaternion& value,
    const Quaternion& set,
    Quaternion& result
)
{
    register f32 mag = sqrtf( ( value.x * value.x )
                            + ( value.y * value.y )
                            + ( value.z * value.z )
                            + ( value.w * value.w ) );
    if ( mag != 0.0f )
    {
        register f32 invMag = 1.0f / mag;
        result.x = value.x * invMag;
        result.y = value.y * invMag;
        result.z = value.z * invMag;
        result.w = value.w * invMag;
    }
    else
    {
        result.x = set.x;
        result.y = set.y;
        result.z = set.z;
        result.w = set.w;
    }
}

//----------------------------------------------------------------------------
///<summary>逆四元数を求めます.</summary>
///<param name="value">入力四元数.</param>
///<return>逆四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Inverse( const Quaternion& value )
{
    register f32 magSq = ( value.x * value.x )
                       + ( value.y * value.y )
                       + ( value.z * value.z )
                       + ( value.w * value.w );
    assert( magSq != 0.0f );
    register f32 invMagSq = 1.0f / magSq;
    return Quaternion(
        -value.x * invMagSq,
        -value.y * invMagSq,
        -value.z * invMagSq,
         value.w * invMagSq
    );
}

//----------------------------------------------------------------------------
///<summary>逆四元数を求めます.</summary>
///<param name="value">入力四元数.</param>
///<param name="result">逆四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Inverse( const Quaternion& value, Quaternion& result )
{
    register f32 magSq = ( value.x * value.x )
                       + ( value.y * value.y )
                       + ( value.z * value.z )
                       + ( value.w * value.w );
    assert( magSq != 0.0f );
    register f32 invMagSq = 1.0f / magSq;
    result.x = -value.x * invMagSq;
    result.y = -value.y * invMagSq;
    result.z = -value.z * invMagSq;
    result.w =  value.w * invMagSq;
}

//----------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から四元数を生成します.</summary>
///<param name="yaw">ヨー角(ラジアン).</param>
///<param name="pitch">ピッチ角(ラジアン).</param>
///<param name="roll">ロール角(ラジアン).</param>
///<return>指定されたヨー・ピッチ・ロール角から生成された四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromYawPitchRollRad
(
    const f32 yaw,
    const f32 pitch,
    const f32 roll
)
{
    f32 sr, cr;
    f32 sp, cp;
    f32 sy, cy;
    SinCosRad( &sr, &cr, roll  * 0.5f );
    SinCosRad( &sp, &cp, pitch * 0.5f );
    SinCosRad( &sy, &cy, yaw   * 0.5f );

    return Quaternion(
        -( sy * sp * cr ) + ( cy * cp * sr ),
         ( cy * sp * cr ) + ( sy * cp * sr ),
        -( cy * sp * sr ) + ( sy * cp * cr ),
         ( cy * cp * cr ) + ( sy * sp * sr )
    );
}

//----------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から四元数を生成します.</summary>
///<param name="yaw">ヨー角(ラジアン).</param>
///<param name="pitch">ピッチ角(ラジアン).</param>
///<param name="roll">ロール角(ラジアン).</param>
///<param name="reslut">指定されたヨー・ピッチ・ロール角から生成された四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromYawPitchRollRad
(
    const f32 yaw,
    const f32 pitch,
    const f32 roll,
    Quaternion& result
)
{
    f32 sr, cr;
    f32 sp, cp;
    f32 sy, cy;
    SinCosRad( &sr, &cr, roll  * 0.5f );
    SinCosRad( &sp, &cp, pitch * 0.5f );
    SinCosRad( &sy, &cy, yaw   * 0.5f );

    result.x = -( sy * sp * cr ) + ( cy * cp * sr );
    result.y =  ( cy * sp * cr ) + ( sy * cp * sr );
    result.z = -( cy * sp * sr ) + ( sy * cp * cr );
    result.w =  ( cy * cp * cr ) + ( sy * sp * sr );
}

//----------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から四元数を生成します.</summary>
///<param name="yaw">ヨー角(度).</param>
///<param name="pitch">ピッチ角(度).</param>
///<param name="roll">ロール角(度).</param>
///<return>指定されたヨー・ピッチ・ロール角から生成された四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromYawPitchRollDeg
(
    const f32 yaw,
    const f32 pitch,
    const f32 roll
)
{
    f32 sr, cr;
    f32 sp, cp;
    f32 sy, cy;
    SinCosDeg( &sr, &cr, roll  * 0.5f );
    SinCosDeg( &sp, &cp, pitch * 0.5f );
    SinCosDeg( &sy, &cy, yaw   * 0.5f );

    return Quaternion(
        -( sy * sp * cr ) + ( cy * cp * sr ),
         ( cy * sp * cr ) + ( sy * cp * sr ),
        -( cy * sp * sr ) + ( sy * cp * cr ),
         ( cy * cp * cr ) + ( sy * sp * sr )
    );
}

//----------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から四元数を生成します.</summary>
///<param name="yaw">ヨー角(度).</param>
///<param name="pitch">ピッチ角(度).</param>
///<param name="roll">ロール角(度).</param>
///<param name="reslut">指定されたヨー・ピッチ・ロール角から生成された四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromYawPitchRollDeg
(
    const f32 yaw,
    const f32 pitch,
    const f32 roll,
    Quaternion& result
)
{
    f32 sr, cr;
    f32 sp, cp;
    f32 sy, cy;
    SinCosDeg( &sr, &cr, roll  * 0.5f );
    SinCosDeg( &sp, &cp, pitch * 0.5f );
    SinCosDeg( &sy, &cy, yaw   * 0.5f );

    result.x = -( sy * sp * cr ) + ( cy * cp * sr );
    result.y =  ( cy * sp * cr ) + ( sy * cp * sr );
    result.z = -( cy * sp * sr ) + ( sy * cp * cr );
    result.w =  ( cy * cp * cr ) + ( sy * sp * sr );
}

//----------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から四元数を生成します.</summary>
///<param name="yaw">ヨー角(インデックス角).</param>
///<param name="pitch">ピッチ角(インデックス角).</param>
///<param name="roll">ロール角(インデックス角).</param>
///<return>指定されたヨー・ピッチ・ロール角から生成された四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromYawPitchRollIdx
(
    const u16 yaw,
    const u16 pitch,
    const u16 roll
)
{
    f32 sr, cr;
    f32 sp, cp;
    f32 sy, cy;
    SinCosIdx( &sr, &cr, roll  / 2 );
    SinCosIdx( &sp, &cp, pitch / 2 );
    SinCosIdx( &sy, &cy, yaw   / 2 );

    return Quaternion(
        -( sy * sp * cr ) + ( cy * cp * sr ),
         ( cy * sp * cr ) + ( sy * cp * sr ),
        -( cy * sp * sr ) + ( sy * cp * cr ),
         ( cy * cp * cr ) + ( sy * sp * sr )
    );
}

//----------------------------------------------------------------------------
///<summary>ヨー・ピッチ・ロール角から四元数を生成します.</summary>
///<param name="yaw">ヨー角(インデックス角).</param>
///<param name="pitch">ピッチ角(インデックス角).</param>
///<param name="roll">ロール角(インデックス角).</param>
///<param name="reslut">指定されたヨー・ピッチ・ロール角から生成された四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromYawPitchRollIdx
(
    const u16 yaw,
    const u16 pitch,
    const u16 roll,
    Quaternion& result
)
{
    f32 sr, cr;
    f32 sp, cp;
    f32 sy, cy;
    SinCosIdx( &sr, &cr, roll  / 2 );
    SinCosIdx( &sp, &cp, pitch / 2 );
    SinCosIdx( &sy, &cy, yaw   / 2 );

    result.x = -( sy * sp * cr ) + ( cy * cp * sr );
    result.y =  ( cy * sp * cr ) + ( sy * cp * sr );
    result.z = -( cy * sp * sr ) + ( sy * cp * cr );
    result.w =  ( cy * cp * cr ) + ( sy * sp * sr );
}

//----------------------------------------------------------------------------
///<summary>指定された軸と角度から四元数を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="rad">回転角(ラジアン)</param>
///<return>指定された軸と角度から生成された四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromAxisAngleRad( const Vector3& axis, const f32 rad )
{
    register f32 halfRad = rad * 0.5f;
    register f32 sinX = SinRad( halfRad );
    return Quaternion(
        axis.x * sinX,
        axis.y * sinX,
        axis.z * sinX,
        CosRad( halfRad )
   );
}

//----------------------------------------------------------------------------
///<summary>指定された軸と角度から四元数を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="rad">回転角(ラジアン)</param>
///<param name="result">指定された軸と角度から生成された四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromAxisAngleRad
(
    const Vector3&  axis,
    const f32       rad,
    Quaternion&     result
)
{
    register f32 halfRad = rad * 0.5f;
    register f32 sinX = SinRad( halfRad );
    result.x = axis.x * sinX;
    result.y = axis.y * sinX;
    result.z = axis.z * sinX;
    result.w = CosRad( halfRad );
}

//----------------------------------------------------------------------------
///<summary>指定された軸と角度から四元数を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="deg">回転角(度)</param>
///<return>指定された軸と角度から生成された四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromAxisAngleDeg( const Vector3& axis, const f32 deg )
{
    register f32 halfDeg = deg * 0.5f;
    register f32 sinX = SinDeg( halfDeg );
    return Quaternion(
        axis.x * sinX,
        axis.y * sinX,
        axis.z * sinX,
        CosDeg( halfDeg )
   );
}

//----------------------------------------------------------------------------
///<summary>指定された軸と角度から四元数を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="deg">回転角(度).</param>
///<param name="result">指定された軸と角度から生成された四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromAxisAngleDeg
(
    const Vector3&  axis,
    const f32       deg,
    Quaternion&     result
)
{
    register f32 halfDeg = deg * 0.5f;
    register f32 sinX = SinDeg( halfDeg );
    result.x = axis.x * sinX;
    result.y = axis.y * sinX;
    result.z = axis.z * sinX;
    result.w = CosDeg( halfDeg );
}

//----------------------------------------------------------------------------
///<summary>指定された軸と角度から四元数を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="idx">回転角(インデックス角)</param>
///<return>指定された軸と角度から生成された四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromAxisAngleIdx( const Vector3& axis, const u16 idx )
{
    register u16 halfIdx = idx / 2;
    register f32 sinX = SinIdx( halfIdx );
    return Quaternion(
        axis.x * sinX,
        axis.y * sinX,
        axis.z * sinX,
        CosIdx( halfIdx )
   );
}

//----------------------------------------------------------------------------
///<summary>指定された軸と角度から四元数を生成します.</summary>
///<param name="axis">回転軸</param>
///<param name="idx">回転角(インデックス角)</param>
///<param name="result">指定された軸と角度から生成された四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromAxisAngleIdx
(
    const Vector3&  axis,
    const u16       idx,
    Quaternion&     result
)
{
    register u16 halfIdx = idx / 2;
    register f32 sinX = SinIdx( halfIdx );
    result.x = axis.x * sinX;
    result.y = axis.y * sinX;
    result.z = axis.z * sinX;
    result.w = CosIdx( halfIdx );
}

//----------------------------------------------------------------------------
///<summary>回転行列から四元数を生成します.</summary>
///<param name="value">回転行列.</param>
///<return>回転行列から生成した四元数を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::CreateFromRotationMatrix( const Matrix& value )
{
    if ( ( value._11 + value._22 + value._33 ) > 0.0f )
    {
        register f32 M1 = sqrtf( value._11 + value._22 + value._33 + 1.0f );
        register f32 W = M1 * 0.5f;
        assert( M1 != 0.0f );
        M1 = 0.5f / M1;
        return Quaternion(
            ( value._23 - value._32 ) * M1,
            ( value._31 - value._13 ) * M1,
            ( value._12 - value._21 ) * M1,
            W 
        );
    }
    if ( ( value._11 >= value._22 ) && ( value._11 >= value._33 ) )
    {
        register f32 M2 = sqrtf( 1.0f + value._11 - value._22 - value._33 );
        assert( M2 != 0.0f );
        register f32 M3 = 0.5f / M2;
        return Quaternion(
            0.5f * M2,
            ( value._12 + value._21 ) * M3,
            ( value._13 + value._31 ) * M3,
            ( value._23 - value._32 ) * M3
        );
    }
    if ( value._22 > value._33 )
    {
        register f32 M4 = sqrtf( 1.0f + value._22 - value._11 - value._33 );
        assert( M4 != 0.0f );
        register f32 M5 = 0.5f / M4;
        return Quaternion(
            ( value._21 + value._12 ) * M5,
            0.5f * M4,
            ( value._32 + value._23 ) * M5,
            ( value._31 - value._13 ) * M5
        );
    }
    register f32 M6 = sqrtf( 1.0f + value._33 - value._11 - value._22 );
    assert( M6 != 0.0f );
    register f32 M7 = 0.5f / M6;
    return Quaternion(
        ( value._31 + value._13 ) * M7,
        ( value._32 + value._23 ) * M7,
        0.5f * M6,
        ( value._12 - value._21 ) * M7
    );
}

//----------------------------------------------------------------------------
///<summary>回転行列から四元数を生成します.</summary>
///<param name="value">回転行列.</param>
///<param name="result">回転行列から生成した四元数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::CreateFromRotationMatrix( const Matrix& value, Quaternion& result )
{
    if ( ( value._11 + value._22 + value._33 ) > 0.0f )
    {
        register f32 M1 = sqrtf( value._11 + value._22 + value._33 + 1.0f );
        register f32 W = M1 * 0.5f;
        assert( M1 != 0.0f );
        M1 = 0.5f / M1;
        result.x = ( value._23 - value._32 ) * M1;
        result.y = ( value._31 - value._13 ) * M1;
        result.z = ( value._12 - value._21 ) * M1;
        result.w = W;
        return;
    }
    if ( ( value._11 >= value._22 ) && ( value._11 >= value._33 ) )
    {
        register f32 M2 = sqrtf( 1.0f + value._11 - value._22 - value._33 );
        assert( M2 != 0.0f );
        register f32 M3 = 0.5f / M2;
        result.x = 0.5f * M2;
        result.y = ( value._12 + value._21 ) * M3;
        result.z = ( value._13 + value._31 ) * M3;
        result.w = ( value._23 - value._32 ) * M3;
        return;
    }
    if ( value._22 > value._33 )
    {
        register f32 M4 = sqrtf( 1.0f + value._22 - value._11 - value._33 );
        assert( M4 != 0.0f );
        register f32 M5 = 0.5f / M4;
        result.x = ( value._21 + value._12 ) * M5;
        result.y = 0.5f * M4;
        result.z = ( value._32 + value._23 ) * M5;
        result.w = ( value._31 - value._13 ) * M5;
        return;
    }
    register f32 M6 = sqrtf( 1.0f + value._33 - value._11 - value._22 );
    assert( M6 != 0.0f );
    register f32 M7 = 0.5f / M6;
    result.x = ( value._31 + value._13 ) * M7;
    result.y = ( value._32 + value._23 ) * M7;
    result.z = 0.5f * M6;
    result.w = ( value._12 - value._21 ) * M7;
}

//----------------------------------------------------------------------------
///<summary>球面線形補間を行います.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="amount">補間係数.</param>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Slerp( const Quaternion& a, const Quaternion& b, const f32 amount )
{
    if ( amount <= 0.0f ) return a;
    if ( amount >= 1.0f ) return b;

    register f32 cosW = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w );
    register f32 ax = a.x;
    register f32 ay = a.y;
    register f32 az = a.z;
    register f32 aw = a.w;

    if ( cosW < 0.0f )
    {
        aw = -aw;
        ax = -ax;
        ay = -ay;
        az = -az;
        cosW -= cosW;
    }

    register f32 k1, k2;
    if ( cosW > 0.9999f )
    {
        k1 = 1.0f - amount;
        k1 = amount;
    }
    else
    {
        register f32 sinW = sqrtf( 1.0f - ( cosW * cosW ) );
        assert( sinW != 0.0f );
        register f32 omega    = ATan2Rad( sinW, cosW );
        register f32 invSinW  = 1.0f / sinW;
        k1 = SinRad( ( 1.0f - amount ) *omega ) * invSinW;
        k2 = SinRad( amount * omega ) * invSinW;
    }
    return Quaternion(
        ( k1 * a.x ) + ( k2 * b.x ),
        ( k1 * a.y ) + ( k2 * b.y ),
        ( k1 * a.z ) + ( k2 * b.z ),
        ( k1 * a.w ) + ( k2 * b.w )
    );
}

//----------------------------------------------------------------------------
///<summary>球面線形補間を行います.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="amount">補間係数.</param>
///<param name="result">球面線形補完した結果</param>
//----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Slerp
(
    const Quaternion& a,
    const Quaternion& b, 
    const f32 amount, 
    Quaternion& result
)
{
    if ( amount <= 0.0f )
    {
        result.x = a.x;
        result.y = a.y;
        result.z = a.z;
        result.w = a.w;
        return;
    }
    if ( amount >= 1.0f )
    {
        result.x = b.x;
        result.y = b.y;
        result.z = b.z;
        result.w = b.w;
        return;
    }

    register f32 cosW = ( a.x * b.x ) + ( a.y * b.y ) + ( a.z * b.z ) + ( a.w * b.w );
    register f32 ax = a.x;
    register f32 ay = a.y;
    register f32 az = a.z;
    register f32 aw = a.w;

    if ( cosW < 0.0f )
    {
        aw = -aw;
        ax = -ax;
        ay = -ay;
        az = -az;
        cosW -= cosW;
    }

    register f32 k1, k2;
    if ( cosW > 0.9999f )
    {
        k1 = 1.0f - amount;
        k1 = amount;
    }
    else
    {
        register f32 sinW = sqrtf( 1.0f - ( cosW * cosW ) );
        assert( sinW != 0.0f );
        register f32 omega    = ATan2Rad( sinW, cosW );
        register f32 invSinW  = 1.0f / sinW;
        k1 = SinRad( ( 1.0f - amount ) *omega ) * invSinW;
        k2 = SinRad( amount * omega ) * invSinW;
    }
    result.x = ( k1 * a.x ) + ( k2 * b.x );
    result.y = ( k1 * a.y ) + ( k2 * b.y );
    result.z = ( k1 * a.z ) + ( k2 * b.z );
    result.w = ( k1 * a.w ) + ( k2 * b.w );
}

//----------------------------------------------------------------------------
///<summary>球面四角形補間を行います.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="c">入力四元数.</param>
///<param name="d">入力四元数.</param>
///<param name="amount">補間係数.</param>
///<return>球面資格系補完した結果を返却します.</return>
//----------------------------------------------------------------------------
ASDX_INLINE
Quaternion  Quaternion::Squad
(
    const Quaternion& a,
    const Quaternion& b,
    const Quaternion& c,
    const Quaternion& d,
    const f32 amount
)
{
    return Slerp(
        Slerp( a, d, amount ),
        Slerp( b, c, amount ),
        2.0f * amount * ( 1.0f - amount )
    );
}

//-----------------------------------------------------------------------------
///<summary>球面四角形補間を行います.</summary>
///<param name="a">入力四元数.</param>
///<param name="b">入力四元数.</param>
///<param name="c">入力四元数.</param>
///<param name="d">入力四元数.</param>
///<param name="amount">補間係数.</param>
///<param name="result">球面資格系補完した結果.</param>
//-----------------------------------------------------------------------------
ASDX_INLINE
void    Quaternion::Squad
(
    const Quaternion& a,
    const Quaternion& b,
    const Quaternion& c,
    const Quaternion& d,
    const f32 amount,
    Quaternion& result
)
{
    Slerp( 
        Slerp( a, d, amount ),
        Slerp( b, d, amount ),
        2.0f * amount * ( 1.0f - amount ),
        result 
    );
}


} // namespace asdx

#endif//__ASDX_MATH_INL__
