//-------------------------------------------------------------------------------------------------
// File : s3dSimd.inl
// Desc : SIMD Module.
// Copyright(c) Project Asura. All right reserved.
//-------------------------------------------------------------------------------------------------
#pragma once


namespace s3d {

///////////////////////////////////////////////////////////////////////////////////////////////////
// Simd4 class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      各成分にスカラー値を設定します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Make(f32 scalar)
{ return _mm_set_ps1( scalar ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルを生成します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Make(f32 x, f32 y, f32 z, f32 w)
{ return _mm_set_ps( w, z, y, x ); }

//-------------------------------------------------------------------------------------------------
//      ロードします.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Load(const Float4& values)
{ return _mm_load_ps(values.v); }

//-------------------------------------------------------------------------------------------------
//      指定先にストアします.
//-------------------------------------------------------------------------------------------------
inline
void S3D_VECAPI Simd4::Store(Float4& value, b128 v)
{ _mm_store_ps(value.v, v); }

//-------------------------------------------------------------------------------------------------
//      X成分を設定します.
//-------------------------------------------------------------------------------------------------
inline
void S3D_VECAPI Simd4::SetX(b128& v, f32 x)
{ v = _mm_insert_ps( v, _mm_set_ss(x), 0x00 ); }

//-------------------------------------------------------------------------------------------------
//      Y成分を設定します.
//-------------------------------------------------------------------------------------------------
inline
void S3D_VECAPI Simd4::SetY(b128& v, f32 y)
{ v = _mm_insert_ps( v, _mm_set_ss(y), 0x10 ); }

//-------------------------------------------------------------------------------------------------
//      Z成分を設定します.
//-------------------------------------------------------------------------------------------------
inline
void S3D_VECAPI Simd4::SetZ(b128& v, f32 z)
{ v = _mm_insert_ps( v, _mm_set_ss(z), 0x20 ); }

//-------------------------------------------------------------------------------------------------
//      W成分を設定します.
//-------------------------------------------------------------------------------------------------
inline
void S3D_VECAPI Simd4::SetW(b128& v, f32 w)
{ v = _mm_insert_ps( v, _mm_set_ss(w), 0x30 ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルのX成分を取得します.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::GetX(b128 v)
{ return _mm_cvtss_f32( v ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルのY成分を取得します.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::GetY(b128 v)
{ return _mm_cvtss_f32(_mm_shuffle_ps( v, v, 0x55 )); }

//-------------------------------------------------------------------------------------------------
//      ベクトルのZ成分を取得します.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::GetZ(b128 v)
{ return _mm_cvtss_f32(_mm_shuffle_ps( v, v, 0xaa )); }

//-------------------------------------------------------------------------------------------------
//      ベクトルのW成分を取得します.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::GetW(b128 v)
{ return _mm_cvtss_f32(_mm_shuffle_ps( v, v, 0xff )); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの大きさを求めます.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::Mag2(b128 v)
{
    auto ret = _mm_dp_ps( v, v, 0x33 );
    return _mm_cvtss_f32( _mm_sqrt_ps( ret ) );
}

//-------------------------------------------------------------------------------------------------
//      ベクトルの大きさを求めます.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::Mag3(b128 v)
{
    auto ret = _mm_dp_ps( v, v, 0x77 );
    return _mm_cvtss_f32( _mm_sqrt_ps( ret ) );
}

//-------------------------------------------------------------------------------------------------
//      ベクトルの大きさを求めます.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::Mag4(b128 v)
{
    auto ret = _mm_dp_ps( v, v, 0xff );
    return _mm_cvtss_f32( _mm_sqrt_ps( ret ) );
}

//-------------------------------------------------------------------------------------------------
//      ベクトルのマイナス値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Neg(b128 v)
{ return _mm_sub_ps(Simd4::Zero, v); }

//-------------------------------------------------------------------------------------------------
//      逆数を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Rcp(b128 v)
{
    // _mm_rcp_ps() だと精度が悪かったので，遅くなるけど使わない.
    return _mm_div_ps(Simd4::One4, v);
}

//-------------------------------------------------------------------------------------------------
//      平方根を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Sqrt(b128 v)
{ return _mm_sqrt_ps(v);; }

//-------------------------------------------------------------------------------------------------
//      単位ベクトルを求めます.
//-------------------------------------------------------------------------------------------------
__inline
b128 S3D_VECAPI Simd4::Unit2(b128 v)
{
    b128 ret;
    ret = _mm_dp_ps( v, v, 0x33 );
    ret = _mm_sqrt_ps( ret );
    ret = _mm_div_ps( v, ret );
    return ret;
}

//-------------------------------------------------------------------------------------------------
//      単位ベクトルを求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Unit3(b128 v)
{
    b128 ret;
    ret = _mm_dp_ps( v, v, 0x77 );
    ret = _mm_sqrt_ps( ret );
    ret = _mm_div_ps( v, ret );
    return ret;
}

//-------------------------------------------------------------------------------------------------
//      単位ベクトルを求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Unit4(b128 v)
{
    b128 ret;
    ret = _mm_dp_ps( v, v, 0xff );
    ret = _mm_sqrt_ps( ret );
    ret = _mm_div_ps( v, ret );
    return ret;
}

//-------------------------------------------------------------------------------------------------
//      符号を取得します(+ : 1.0f, - : -1.0f)
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Sign(b128 v)
{
    auto sign = _mm_and_ps( Simd4::SignMask, v );
    return _mm_or_ps( sign, Simd4::One4 );
}

//-------------------------------------------------------------------------------------------------
//      絶対値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Abs(b128 v)
{ return _mm_andnot_ps( Simd4::SignMask, v ); }

//-------------------------------------------------------------------------------------------------
//      加算演算.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Add(b128 lhs, b128 rhs)
{ return _mm_add_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      減算演算.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Sub(b128 lhs, b128 rhs)
{ return _mm_sub_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      乗算演算
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Mul(b128 lhs, b128 rhs)
{ return _mm_mul_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      除算演算.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Div(b128 lhs, b128 rhs)
{ return _mm_div_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      最大値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Max(b128 lhs, b128 rhs)
{ return _mm_max_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      最小値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Min(b128 lhs, b128 rhs)
{ return _mm_min_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの内積を求めます.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::Dp2(b128 lhs, b128 rhs)
{ return _mm_cvtss_f32( _mm_dp_ps( lhs, rhs, 0x33 ) ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの内積を求めます.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::Dp3(b128 lhs, b128 rhs)
{ return _mm_cvtss_f32( _mm_dp_ps( lhs, rhs, 0x77 ) ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの内積を求めます.
//-------------------------------------------------------------------------------------------------
inline
f32 S3D_VECAPI Simd4::Dp4(b128 lhs, b128 rhs)
{ return _mm_cvtss_f32( _mm_dp_ps( lhs, rhs, 0xff ) ); }

//-------------------------------------------------------------------------------------------------
//      3次元ベクトルの外積を求めます.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Crs(b128 lhs, b128 rhs)
{
    auto r1 = _mm_shuffle_ps(lhs, lhs, 0xc9);
    auto r2 = _mm_shuffle_ps(rhs, rhs, 0xc9);
    auto r3 = _mm_sub_ps(_mm_mul_ps(rhs, r1), _mm_mul_ps(r2, lhs));
    return _mm_shuffle_ps(r3, r3, 0xc9);
}

//-------------------------------------------------------------------------------------------------
//      lhs < rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::CmpLt(b128 lhs, b128 rhs)
{ return _mm_cmplt_ps(lhs, rhs); }

//-------------------------------------------------------------------------------------------------
//      lhs <= rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::CmpLe(b128 lhs, b128 rhs)
{ return _mm_cmple_ps(lhs, rhs); }

//-------------------------------------------------------------------------------------------------
//      lhs == rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::CmpEq(b128 lhs, b128 rhs)
{ return _mm_cmpeq_ps(lhs, rhs); }

//-------------------------------------------------------------------------------------------------
//      lhs != rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::CmpNq(b128 lhs, b128 rhs)
{ return _mm_cmpneq_ps(lhs, rhs); }

//-------------------------------------------------------------------------------------------------
//      lhs >= rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::CmpGe(b128 lhs, b128 rhs)
{ return _mm_cmpge_ps(lhs, rhs); }

//-------------------------------------------------------------------------------------------------
//      lhs > rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::CmpGt(b128 lhs, b128 rhs)
{ return _mm_cmpgt_ps(lhs, rhs); }

//-------------------------------------------------------------------------------------------------
//      マスクビットを取得します.
//-------------------------------------------------------------------------------------------------
inline
int S3D_VECAPI Simd4::Mask(b128 v)
{ return _mm_movemask_ps(v); }

//-------------------------------------------------------------------------------------------------
//      2次元ベクトルを指定行列で変換します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Trs2(b128 lhs, const b128 rhs[4])
{
    auto x = _mm_shuffle_ps( lhs, lhs, 0x00 );
    auto y = _mm_shuffle_ps( lhs, lhs, 0x55 );

    x = _mm_mul_ps( x, rhs[0] );
    y = _mm_mul_ps( y, rhs[1] );

    return _mm_add_ps( _mm_add_ps( x, y ), rhs[3] );
}

//-------------------------------------------------------------------------------------------------
//      3次元ベクトルを指定行列で変換します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Trs3(b128 lhs, const b128 rhs[4])
{
    auto x = _mm_shuffle_ps( lhs, lhs, 0x00 );
    auto y = _mm_shuffle_ps( lhs, lhs, 0x55 );
    auto z = _mm_shuffle_ps( lhs, lhs, 0xaa );

    x = _mm_mul_ps( x, rhs[0] );
    y = _mm_mul_ps( y, rhs[1] );
    z = _mm_mul_ps( z, rhs[2] );

    return _mm_add_ps( _mm_add_ps( x, y ), _mm_add_ps( z, rhs[3] ) );
}

//-------------------------------------------------------------------------------------------------
//      法線ベクトルを指定行列で変換します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::TrsN(b128 lhs, const b128 rhs[4])
{
    auto x = _mm_shuffle_ps( lhs, lhs, 0x00 );
    auto y = _mm_shuffle_ps( lhs, lhs, 0x55 );
    auto z = _mm_shuffle_ps( lhs, lhs, 0xaa );

    x = _mm_mul_ps( x, rhs[0] );
    y = _mm_mul_ps( y, rhs[1] );
    z = _mm_mul_ps( z, rhs[2] );

    return _mm_add_ps( _mm_add_ps( x, y ), z );
}

//-------------------------------------------------------------------------------------------------
//      3次元ベクトルを指定行列で変換し， w = 1 に射影します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::TrsC(b128 lhs, const b128 rhs[4])
{
    auto x = _mm_shuffle_ps( lhs, lhs, 0x00 );
    auto y = _mm_shuffle_ps( lhs, lhs, 0x55 );
    auto z = _mm_shuffle_ps( lhs, lhs, 0xaa );

    x = _mm_mul_ps( x, rhs[0] );
    y = _mm_mul_ps( y, rhs[1] );
    z = _mm_mul_ps( z, rhs[2] );

    auto ret = _mm_add_ps( _mm_add_ps( x, y ), _mm_add_ps( z, rhs[3] ) );
    return _mm_div_ps( ret, _mm_shuffle_ps( ret, ret, 0xff ) );
}

//-------------------------------------------------------------------------------------------------
//      4次元ベクトルを指定行列で変換します.
//-------------------------------------------------------------------------------------------------
inline
b128 S3D_VECAPI Simd4::Trs4(b128 lhs, const b128 rhs[4])
{
    auto x = _mm_shuffle_ps( lhs, lhs, 0x00 );
    auto y = _mm_shuffle_ps( lhs, lhs, 0x55 );
    auto z = _mm_shuffle_ps( lhs, lhs, 0xaa );
    auto w = _mm_shuffle_ps( lhs, lhs, 0xff );

    x = _mm_mul_ps( x, rhs[0] );
    y = _mm_mul_ps( y, rhs[1] );
    z = _mm_mul_ps( z, rhs[2] );
    w = _mm_mul_ps( w, rhs[3] );

    return _mm_add_ps( _mm_add_ps( x, y ), _mm_add_ps( z, w ) );
}

#if S3D_IS_AVX
///////////////////////////////////////////////////////////////////////////////////////////////////
// Simd8 class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      各成分にスカラー値を設定します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Make(f32 scalar)
{ return _mm256_set1_ps(scalar); }

//-------------------------------------------------------------------------------------------------
//      ベクトルを生成します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Make
(
    f32 a, f32 b, f32 c, f32 d,
    f32 e, f32 f, f32 g, f32 h
)
{ return _mm256_set_ps( h, g, f, e, d, c, b, a ); }

//-------------------------------------------------------------------------------------------------
//      指定された値をロードします.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Load(const Float8& value)
{ return _mm256_load_ps(value.v); }

//-------------------------------------------------------------------------------------------------
//      指定先に値を格納します.
//-------------------------------------------------------------------------------------------------
inline
void S3D_VECAPI Simd8::Store(Float8& value, b256 v)
{ _mm256_store_ps(value.v, v); }

//-------------------------------------------------------------------------------------------------
//      ビットマスクを取得します.
//-------------------------------------------------------------------------------------------------
inline
int S3D_VECAPI Simd8::Mask(b256 v)
{ return _mm256_movemask_ps(v); }

//-------------------------------------------------------------------------------------------------
//     ベクトルのマイナス値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Neg(b256 v)
{ return _mm256_sub_ps(Simd8::Zero, v); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの各成分の逆数を求めます.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Rcp(b256 v)
{ return _mm256_div_ps(Simd8::One, v); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの各成分の符号を求めます(+ : 1.0f, - : -1.0f).
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Sign(b256 v)
{
    auto sign = _mm256_and_ps( Simd8::SignMask, v );
    return _mm256_or_ps( sign, Simd8::One );
}

//-------------------------------------------------------------------------------------------------
//      ベクトルの各成分の絶対値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Abs(b256 v)
{ return _mm256_andnot_ps( Simd8::SignMask, v ); }

//-------------------------------------------------------------------------------------------------
//      加算演算.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Add(b256 lhs, b256 rhs)
{ return _mm256_add_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      減算演算.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Sub(b256 lhs, b256 rhs)
{ return _mm256_sub_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      乗算演算.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Mul(b256 lhs, b256 rhs)
{ return _mm256_mul_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      除算演算.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Div(b256 lhs, b256 rhs)
{ return _mm256_div_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの各成分の最大値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Max(b256 lhs, b256 rhs)
{ return _mm256_max_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      ベクトルの各成分の最小値を求めます.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::Min(b256 lhs, b256 rhs)
{ return _mm256_min_ps( lhs, rhs ); }

//-------------------------------------------------------------------------------------------------
//      lhs < rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::CmpLt(b256 lhs, b256 rhs)
{ return _mm256_cmp_ps( lhs, rhs, _CMP_LT_OQ ); }

//-------------------------------------------------------------------------------------------------
//      lhs <= rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::CmpLe(b256 lhs, b256 rhs)
{ return _mm256_cmp_ps( lhs, rhs, _CMP_LE_OQ ); }

//-------------------------------------------------------------------------------------------------
//      lhs == rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::CmpEq(b256 lhs, b256 rhs)
{ return _mm256_cmp_ps( lhs, rhs, _CMP_EQ_OQ ); }

//-------------------------------------------------------------------------------------------------
//      lhs != rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::CmpNq(b256 lhs, b256 rhs)
{ return _mm256_cmp_ps( lhs, rhs, _CMP_NEQ_OQ ); }

//-------------------------------------------------------------------------------------------------
//      lhs >= rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::CmpGe(b256 lhs, b256 rhs)
{ return _mm256_cmp_ps( lhs, rhs, _CMP_GE_OQ ); }

//-------------------------------------------------------------------------------------------------
//      lhs > rhs の比較結果を返します.
//-------------------------------------------------------------------------------------------------
inline
b256 S3D_VECAPI Simd8::CmpGt(b256 lhs, b256 rhs)
{ return _mm256_cmp_ps( lhs, rhs, _CMP_GT_OQ ); }

#endif// S3D_IS_AVX

} // namespace s3d
