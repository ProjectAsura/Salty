//------------------------------------------------------------------------------------------
// File : s3d_math.h.
// Desc : Math Module.
// Copyright(c) Project Asura. All right reserved.
//------------------------------------------------------------------------------------------

#ifndef __S3D_MATH__
#define __S3D_MATH__

//------------------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------------------
#include <s3d_typedef.h>
#include <s3d_rand.h>
#include <cmath>
#include <cfloat>
#include <cassert>


namespace s3d {

//------------------------------------------------------------------------------------------
// Forward Declarations.
//------------------------------------------------------------------------------------------
struct  Vector3;
struct  Ray;


//------------------------------------------------------------------------------------------
// Type Definitions.
//------------------------------------------------------------------------------------------
typedef Vector3 Color;


//------------------------------------------------------------------------------------------
// Constant Values
//------------------------------------------------------------------------------------------
const f32   F_HIT_MAX   = 1e12f;                                  //!< 交差判定上限値.
const f32   F_HIT_MIN   = 0.1f;                                   //!< 交差判定下限値.
const f32   F_PI        = 3.1415926535897932384626433832795f;     //!< πです.
const f32   F_2PI       = 6.283185307179586476925286766559f;      //!< 2πです.
const f32   F_1DIVPI    = 0.31830988618379067153776752674503f;    //!< 1/πです.
const f32   F_1DIV2PI   = 0.15915494309189533576888376337251f;    //!< 1/2πです.
const f32   F_PIDIV2    = 1.5707963267948966192313216916398f;     //!< π/2です.
const f32   F_PIDIV3    = 1.0471975511965977461542144610932f;     //!< π/3です.
const f32   F_PIDIV4    = 0.78539816339744830961566084581988f;    //!< π/4です.
const f32   F_MAX       = 3.402823466e+38F;                       //!< f32型の最大値です.
const f32   F_MIN       = 1.175494351e-38F;                       //!< f32型の最小値です.

template< typename T > S3D_INLINE
s32 Sign( const T val )
{ return ( val > T(0) ) ? 1 : (( val < T(0) ) ? -1 : 0 ); }


//------------------------------------------------------------------------------------------
//! @brief      最大値を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 Max( const f32 a, const f32 b )
{ return ( a > b ) ? a : b; }

//------------------------------------------------------------------------------------------
//! @brief      最小値を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 Min( const f32 a, const f32 b )
{ return ( a < b ) ? a : b; }

//------------------------------------------------------------------------------------------
//! @brief      ラジアンに変換します.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToRad( const f32 deg )
{ return deg * ( F_PI / 180.0f ); }

//------------------------------------------------------------------------------------------
//! @brief      度に変換します.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToDeg( const f32 rad )
{ return rad * ( 180.0f / F_PI ); }

//------------------------------------------------------------------------------------------
//! @brief      非数であるかチェックします.
//------------------------------------------------------------------------------------------
S3D_INLINE
bool IsNan( const f32 value )
{ return ( value != value ); }

//------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SafeSqrt( const f32 value )
{
    if ( value > FLT_EPSILON )
    { return sqrtf( value ); }

    return 0.0f;
}

//------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f64 SafeSqrt( const f64 value )
{
    if ( value > DBL_EPSILON )
    { return sqrt( value ); }

    return 0.0;
}


/////////////////////////////////////////////////////////////////////////////////////////////
// Vector2 structure
/////////////////////////////////////////////////////////////////////////////////////////////
struct Vector2
{
public:
    union
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
        };
        f32 a[2];       //!< 各成分を表す配列です;
    };

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector2()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector2( const f32 nx, const f32 ny )
    : x( nx )
    , y( ny )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector2( const Vector2& value )
    : x( value.x )
    , y( value.y )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      等価演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector2& value ) const
    {
        return ( x == value.x )
            && ( y == value.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      非等価演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector2& value ) const
    {
        return ( x != value.x )
            || ( y != value.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator = ( const Vector2& value )
    {
        x = value.x;
        y = value.y;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator += ( const Vector2& b )
    {
        x += b.x;
        y += b.y;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator -= ( const Vector2& b )
    {
        x -= b.x;
        y -= b.y;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator /= ( const f32 b )
    {
        assert( b != 0.0 );
        x /= b;
        y /= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2  operator + () const
    { return Vector2( x, y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - () const
    { return Vector2( -x, -y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator + (const Vector2 &b) const
    {
        return Vector2(
            x + b.x,
            y + b.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - (const Vector2 &b) const
    { 
        return Vector2(
            x - b.x,
            y - b.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator * (const f32 b) const
    { 
        return Vector2(
            x * b,
            y * b );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator / (const f32 b) const
    {
        assert( b != 0.0 );
        return Vector2(
            x / b,
            y / b );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) ); }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        register f32 mag = sqrtf( x * x + y * y );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        register f32 mag = sqrtf( x * x + y * y );
        if ( mag > 0.0f )
        {
            x /= mag;
            y /= mag;
        }
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 UnitVector (const Vector2 &v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y );
        assert( mag != 0.0 );
        return Vector2(
            v.x / mag,
            v.y / mag );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 SafeUnitVector ( const Vector2& v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y );
        if ( mag > 0.0f )
        {
            return Vector2(
                v.x / mag,
                v.y / mag );
        }
        return v;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Mul (const Vector2 &v1, const Vector2 &v2)
    { 
        return Vector2(
            v1.x * v2.x,
            v1.y * v2.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector2 &v1, const Vector2 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Reflect( const Vector2& i, const Vector2& n )
    {
        register f32 dot = ( n.x * i.x ) + ( n.y * i.y );
        register f32 _2dot = 2.0f * dot;

        return Vector2(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ) );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Min( const Vector2& a, const Vector2& b )
    {
        return Vector2( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Max( const Vector2& a, const Vector2& b )
    {
        return Vector2(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y );
    }
};


////////////////////////////////////////////////////////////////////////////////////////////
// Vector3 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Vector3
{
public:
    union 
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
            f32 z;      //!< Z成分です.
        };
        f32 a[3];       //!< 各成分を表す配列です.
    };

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector3()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector3( const f32 nx, const f32 ny, const f32 nz ) 
    : x( nx )
    , y( ny )
    , z( nz )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector3( const Vector3& value )
    : x( value.x )
    , y( value.y )
    , z( value.z )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector3& b ) const
    {
        return ( x == b.x )
            && ( y == b.y )
            && ( z == b.z );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector3& b ) const
    {
        return ( x != b.x )
            || ( y != b.y )
            || ( z != b.z );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator = ( const Vector3& b )
    {
        x = b.x;
        y = b.y;
        z = b.z;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator += ( const Vector3& b )
    {
        x += b.x;
        y += b.y;
        z += b.z;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator -= ( const Vector3& b )
    {
        x -= b.x;
        y -= b.y;
        z -= b.z;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        z *= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator /= ( const f32 b )
    {
        assert( b != 0.0 );
        x /= b;
        y /= b;
        z /= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3  operator + () const
    { return Vector3( x, y, z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - () const
    { return Vector3( -x, -y, -z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator + (const Vector3 &b) const
    {
        return Vector3(
            x + b.x,
            y + b.y,
            z + b.z);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - (const Vector3 &b) const
    { 
        return Vector3(
            x - b.x,
            y - b.y,
            z - b.z);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator * (const f32 b) const
    { 
        return Vector3(
            x * b,
            y * b,
            z * b);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator / (const f32 b) const
    {
        assert( b != 0.0 );
        return Vector3(
            x / b,
            y / b,
            z / b);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ) + ( z * z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) ); }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        register f32 mag = sqrtf( x * x + y * y + z * z );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
        z /= mag;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        register f32 mag = sqrtf( x * x + y * y + z * z );
        if ( mag > 0.0f )
        {
             x /= mag;
             y /= mag;
             z /= mag;
        }
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 UnitVector (const Vector3 &v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z );
        assert( mag > 0.0f );
        return Vector3(
            v.x / mag,
            v.y / mag,
            v.z / mag );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 SafeUnitVector (const Vector3& v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z );
        if ( mag > 0.0f )
        {
            return Vector3(
                v.x / mag,
                v.y / mag,
                v.z / mag );
        }
        return v;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Mul (const Vector3 &v1, const Vector3 &v2)
    { 
        return Vector3(
            v1.x * v2.x,
            v1.y * v2.y,
            v1.z * v2.z);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector3 &v1, const Vector3 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ) + ( v1.z * v2.z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      外積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Cross (const Vector3 &v1, const Vector3 &v2) 
    {
        return Vector3(
            (v1.y * v2.z) - (v1.z * v2.y),
            (v1.z * v2.x) - (v1.x * v2.z),
            (v1.x * v2.y) - (v1.y * v2.x)
        );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Reflect( const Vector3& i, const Vector3& n )
    {
        register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
        register f32 _2dot = 2.0f * dot;

        return Vector3(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ),
            i.z - ( _2dot * n.z ) );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Min( const Vector3& a, const Vector3& b )
    {
        return Vector3( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y,
            ( a.z < b.z ) ? a.z : b.z );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Max( const Vector3& a, const Vector3& b )
    {
        return Vector3(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y,
            ( a.z > b.z ) ? a.z : b.z );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      法線ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeNormal( const Vector3& a, const Vector3& b, const Vector3& c )
    {
        Vector3 e1 = b - a;
        Vector3 e2 = c - a;
        return Vector3::UnitVector( Vector3::Cross( e1, e2 ) );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      矩形の法線ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeQuadNormal( const Vector3& a, const Vector3& b, const Vector3& c, const Vector3& d )
    {
        Vector3 n1a = ComputeNormal( a, b, c );
        Vector3 n1b = ComputeNormal( a, c, d );
        Vector3 n2a = ComputeNormal( b, c, d );
        Vector3 n2b = ComputeNormal( b, d, c );

        if ( Vector3::Dot( n1a, n1b ) > Vector3::Dot( n2a, n2b ) )
        { return Vector3::UnitVector( n1a + n1b ); }
        else
        { return Vector3::UnitVector( n2a + n2b ); }
    }
};

//------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//------------------------------------------------------------------------------------------
S3D_INLINE 
Vector3 operator * (const f32 f, const Vector3 &v)
{ return v * f; }



////////////////////////////////////////////////////////////////////////////////////////////
// Vector4 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Vector4
{
public:
    union 
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
            f32 z;      //!< Z成分です.
            f32 w;      //!< W成分です.
        };
        f32     a[4];   //!< 各成分を表す配列です.
    #if S3D_IS_SIMD
        b128    v;      //!< パック化された値です.
    #endif//S3D_IS_SIMD
    };

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const f32 nx, const f32 ny, const f32 nz, const f32 nw ) 
  #if S3D_IS_SIMD
    : v( _mm_set_ps( nw, nz, ny, nx ) )
  #else
    : x( nx )
    , y( ny )
    , z( nz )
    , w( nz )
  #endif
    {
        /* DO_NOTHING */
    }

  #if S3D_IS_SIMD
    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const b128 nv )
    : v( nv )
    { /* DO_NOTHING */ }
  #endif//S3D_IS_SIMD

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const Vector4& value )
  #if S3D_IS_SIMD
    : v( value.v )
  #else
    : x( value.x )
    , y( value.y )
    , z( value.z )
    , w( value.w )
  #endif
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector4& b ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_cmpeq_ps( v, b.v );
        return ((_mm_movemask_ps(c) == 0x0f) != 0);
    #else
        return ( x == b.x )
            && ( y == b.y )
            && ( z == b.z )
            && ( w == b.w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector4& b ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_cmpneq_ps( v, b.v );
        return ((_mm_movemask_ps(c)) != 0);
    #else
        return ( x != b.x )
            || ( y != b.y )
            || ( z != b.z )
            || ( w != b.w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator = ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = b.v;
    #else
        x = b.x;
        y = b.y;
        z = b.z;
        w = b.w;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator += ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = _mm_add_ps( v, b.v );
    #else
        x += b.x;
        y += b.y;
        z += b.z;
        w += b.w;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator -= ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = _mm_sub_ps( v, b.v );
    #else
        x -= b.x;
        y -= b.y;
        z -= b.z;
        w -= b.w;
    #endif
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator *= ( const f32 b )
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( b, b, b, b );
        v = _mm_mul_ps( v, c );
    #else
        x *= b;
        y *= b;
        z *= b;
        w *= b;
    #endif
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator /= ( const f32 b )
    {
        assert( b != 0.0 );
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( b, b, b, b );
        v = _mm_div_ps( v, c );
    #else
        x /= b;
        y /= b;
        z /= b;
        w /= b;
    #endif
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4  operator + () const
    {
    #if S3D_IS_SIMD
        return Vector4( v );
    #else
        return Vector4( x, y, z, w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - () const
    {
    #if S3D_IS_SIMD
        b128 z = _mm_setzero_ps();
        return Vector4( _mm_sub_ps( z, v ) );
    #else
        return Vector4( -x, -y, -z, -w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator + (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_add_ps( v, b.v ) );
    #else
        return Vector4(
            x + b.x,
            y + b.y,
            z + b.z,
            w + b.w);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_sub_ps( v, b.v ) );
    #else
        return Vector4(
            x - b.x,
            y - b.y,
            z - b.z,
            w - b.w);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator * (const f32 b) const
    {
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_mul_ps( v, s ) );
    #else
        return Vector4(
            x * b,
            y * b,
            z * b,
            w * b);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator / (const f32 b) const
    {
        assert( b != 0.0 );
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_div_ps( v, s ) );
    #else
        return Vector4(
            x / b,
            y / b,
            z / b,
            w / b);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { 
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        return ( t.x + t.y + t.z + t.w );
    #else
        return ( x * x ) + ( y * y ) + ( z * z ) + ( w * w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        return sqrtf( t.x + t.y + t.z + t.w );
    #else
        return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    #endif
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        assert( mag > 0.0f );
        b128 c = _mm_set1_ps( mag );
        v = _mm_div_ps( v, c );
    #else
        register f32 mag = sqrtf( x * x + y * y + z * z + w * w );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
        z /= mag;
        w /= mag;
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        if ( mag > 0.0f )
        {
            b128 c = _mm_set1_ps( mag );
            v = _mm_div_ps( v, c );
        }
    #else
        register f32 mag = sqrtf( x * x + y * y + z * z + w * w );
        if ( mag > 0.0f )
        {
             x /= mag;
             y /= mag;
             z /= mag;
             w /= mag;
        }
    #endif// S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 UnitVector (const Vector4 &v)
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v.v, v.v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        assert( mag > 0.0f );
        b128 c = _mm_set1_ps( mag );
        return Vector4( _mm_div_ps( v.v, c ) );
    #else
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w );
        assert( mag > 0.0f );
        return Vector4(
            v.x / mag,
            v.y / mag,
            v.z / mag,
            v.w / mag );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 SafeUnitVector (const Vector4& v)
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v.v, v.v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        if ( mag > 0.0f )
        {
            b128 c = _mm_set1_ps( mag );
            return Vector4( _mm_div_ps( v.v, c ) );
        }
    #else
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w );
        if ( mag > 0.0f )
        {
            return Vector4(
                v.x / mag,
                v.y / mag,
                v.z / mag,
                v.w / mag );
        }
    #endif
        return v;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Mul (const Vector4 &v1, const Vector4 &v2)
    { 
    #if S3D_IS_SIMD
        return Vector4( _mm_mul_ps( v1.v, v2.v ) );
    #else
        return Vector4(
            v1.x * v2.x,
            v1.y * v2.y,
            v1.z * v2.z,
            v1.w * v2.w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector4 &v1, const Vector4 &v2) 
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v1.v, v2.v );
        return ( t.x + t.y + t.z + t.w );
    #else
        return ( v1.x * v2.x ) + ( v1.y * v2.y ) + ( v1.z * v2.z ) + ( v1.w * v2.w );
    #endif
    }


    //--------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Reflect( const Vector4& i, const Vector4& n )
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( n.v, i.v );
        register f32 _2dot = 2.0f * ( t.x + t.y + t.z + t.z );
        b128 c = _mm_set1_ps( _2dot );
        b128 b = _mm_mul_ps( c, n.v );
        return Vector4( _mm_sub_ps( i.v, b ) );
    #else
        register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
        register f32 _2dot = 2.0f * dot;

        return Vector4(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ),
            i.z - ( _2dot * n.z ),
            i.w - ( _2dot * n.w ) );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Min( const Vector4& a, const Vector4& b )
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_min_ps( a.v, b.v ) );
    #else
        return Vector4( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y,
            ( a.z < b.z ) ? a.z : b.z,
            ( a.w < b.w ) ? a.w : b.w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Max( const Vector4& a, const Vector4& b )
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_max_ps( a.v, b.v ) );
    #else
        return Vector4(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y,
            ( a.z > b.z ) ? a.z : b.z,
            ( a.w > b.w ) ? a.w : b.w );
    #endif//S3D_IS_SIMD
    }
};

//------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//------------------------------------------------------------------------------------------
S3D_INLINE 
Vector4 operator * (const f32 f, const Vector4 &v)
{
#if S3D_IS_SIMD
    b128 c = _mm_set1_ps( f );
    return Vector4( _mm_mul_ps( c, v.v ) );
#else
    return Vector4(
        f * v.x,
        f * v.y,
        f * v.z,
        f * v.w );
#endif//S3D_IS_SIMD
}


////////////////////////////////////////////////////////////////////////////////////////////
// Ray structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray
{
    Vector3 pos;            //!< 位置座標です.
    Vector3 dir;            //!< 方向ベクトルです.
    Vector3 invDir;         //!< 方向ベクトルの各成分の逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    Ray( const Vector3& p, const Vector3& d )
    { Update( p, d ); }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    Ray( const Ray& value )
    { Update( value.pos, value.dir ); }

    //--------------------------------------------------------------------------------------
    //! @brief      レイを更新します.
    //--------------------------------------------------------------------------------------
    void Update( const Vector3& p, const Vector3& d )
    {
        pos.x = p.x;
        pos.y = p.y;
        pos.z = p.z;

        dir.x = d.x;
        dir.y = d.y;
        dir.z = d.z;

        // ゼロ除算対策.
        //invDir.x = ( dir.x != 0.0f ) ? 1.0f / dir.x : 0.0f;
        //invDir.y = ( dir.y != 0.0f ) ? 1.0f / dir.y : 0.0f;
        //invDir.z = ( dir.z != 0.0f ) ? 1.0f / dir.z : 0.0f;
        invDir.x = 1.0f / dir.x;
        invDir.y = 1.0f / dir.y;
        invDir.z = 1.0f / dir.z;

        sign[0] = ( dir.x > 0.0f ) ? 0 : 1;
        sign[1] = ( dir.y > 0.0f ) ? 0 : 1;
        sign[2] = ( dir.z > 0.0f ) ? 0 : 1;
    }
};

struct RayQuad
{
    b128    pos[3];
    b128    invDir[3];
    s32     sign[3];

    RayQuad( const Ray& ray )
    {
    #if S3D_IS_SIMD
        pos[0] = _mm_set1_ps( ray.pos.x );
        pos[1] = _mm_set1_ps( ray.pos.y );
        pos[2] = _mm_set1_ps( ray.pos.z );

        invDir[0] = _mm_set1_ps( ray.invDir.x );
        invDir[1] = _mm_set1_ps( ray.invDir.y );
        invDir[2] = _mm_set1_ps( ray.invDir.z );
    #else
        pos[0].m128_f32[0] = ray.pos.x;
        pos[0].m128_f32[1] = ray.pos.x;
        pos[0].m128_f32[2] = ray.pos.x;
        pos[0].m128_f32[3] = ray.pos.x;

        pos[1].m128_f32[0] = ray.pos.y;
        pos[1].m128_f32[1] = ray.pos.y;
        pos[1].m128_f32[2] = ray.pos.y;
        pos[1].m128_f32[3] = ray.pos.y;

        pos[2].m128_f32[0] = ray.pos.z;
        pos[2].m128_f32[1] = ray.pos.z;
        pos[2].m128_f32[2] = ray.pos.z;
        pos[2].m128_f32[3] = ray.pos.z;

        invDir[0].m128_f32[0] = ray.invDir.x;
        invDir[0].m128_f32[1] = ray.invDir.x;
        invDir[0].m128_f32[2] = ray.invDir.x;
        invDir[0].m128_f32[3] = ray.invDir.x;

        invDir[1].m128_f32[0] = ray.invDir.y;
        invDir[1].m128_f32[1] = ray.invDir.y;
        invDir[1].m128_f32[2] = ray.invDir.y;
        invDir[1].m128_f32[3] = ray.invDir.y;

        invDir[2].m128_f32[0] = ray.invDir.z;
        invDir[2].m128_f32[1] = ray.invDir.z;
        invDir[2].m128_f32[2] = ray.invDir.z;
        invDir[2].m128_f32[3] = ray.invDir.z;
    #endif
        sign[0] = ray.sign[0];
        sign[1] = ray.sign[1];
        sign[2] = ray.sign[2];
    }

    RayQuad( const RayQuad& rayQuad )
    {
        pos[0] = rayQuad.pos[0];
        pos[1] = rayQuad.pos[1];
        pos[2] = rayQuad.pos[2];

        invDir[0] = rayQuad.invDir[0];
        invDir[1] = rayQuad.invDir[1];
        invDir[2] = rayQuad.invDir[2];

        sign[0] = rayQuad.sign[0];
        sign[1] = rayQuad.sign[1];
        sign[2] = rayQuad.sign[2];
    }
};


} // namespace s3d


#endif//__S3D_MATH__
