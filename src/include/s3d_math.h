//-------------------------------------------------------------------------------------------------
// File : s3d_math.h.
// Desc : Math Module.
// Copyright(c) Project Asura. All right reserved.
//-------------------------------------------------------------------------------------------------
#pragma once

//-------------------------------------------------------------------------------------------------
// Includes
//-------------------------------------------------------------------------------------------------
#include <s3d_typedef.h>
#include <cmath>
#include <cfloat>
#include <cassert>
#include <cstdio>


namespace s3d {

//-------------------------------------------------------------------------------------------------
// Forward Declarations.
//-------------------------------------------------------------------------------------------------
struct  Vector2;
struct  Vector3;
struct  Vector4;
struct  Ray;
struct  Ray4;
struct  Ray8;
struct  Matrix;
struct  BoundingBox;
struct  BoundingBox4;
struct  BoundingBox8;


//-------------------------------------------------------------------------------------------------
// Type Definitions.
//-------------------------------------------------------------------------------------------------
typedef Vector3 Color3;
typedef Vector4 Color4;


//-------------------------------------------------------------------------------------------------
// Constant Values
//-------------------------------------------------------------------------------------------------
const f32   F_HIT_MAX   = 1e12f;                                  //!< 交差判定上限値.
const f32   F_HIT_MIN   = 1e-3f;                                  //!< 交差判定下限値.
const f32   F_PI        = 3.1415926535897932384626433832795f;     //!< πです.
const f32   F_2PI       = 6.283185307179586476925286766559f;      //!< 2πです.
const f32   F_1DIVPI    = 0.31830988618379067153776752674503f;    //!< 1/πです.
const f32   F_1DIV2PI   = 0.15915494309189533576888376337251f;    //!< 1/2πです.
const f32   F_PIDIV2    = 1.5707963267948966192313216916398f;     //!< π/2です.
const f32   F_PIDIV3    = 1.0471975511965977461542144610932f;     //!< π/3です.
const f32   F_PIDIV4    = 0.78539816339744830961566084581988f;    //!< π/4です.
const f32   F_MAX       = 3.402823466e+38F;                       //!< f32型の最大値です.
const f32   F_MIN       = 1.175494351e-38F;                       //!< f32型の最小値です.


//-------------------------------------------------------------------------------------------------
//! @brief      符号を求めます.
//-------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
s32 Sign( const T val )
{ return ( val > T(0) ) ? 1 : (( val < T(0) ) ? -1 : 0 ); }

//-------------------------------------------------------------------------------------------------
//! @brief      最大値を求めます.
//-------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Max( const T a, const T b )
{ return ( a > b ) ? a : b; }

//-------------------------------------------------------------------------------------------------
//! @brief      最小値を求めます.
//-------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Min( const T a, const T b )
{ return ( a < b ) ? a : b; }

//--------------------------------------------------------------------------------------------------
//! @brief      値を指定された範囲内に収めます.
//!
//! @param [in]     value   クランプする値.
//! @param [in]     a       最小値.
//! @param [in]     b       最大値.
//! @return     値をaからbの範囲内に収めた結果を返却します.
//--------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Clamp( T value, T mini, T maxi )
{ return Max( mini, Min( maxi, value ) ); }

//--------------------------------------------------------------------------------------------------
//! @brief      値を0～1に収めます.
//!
//! @param [in]     value   クランプする値.
//! @return     値を0から1の範囲内に収めた結果を返却します.
//--------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Saturate( T value )
{ return Clamp( value, T(0), T(1) ); }

//-------------------------------------------------------------------------------------------------
//! @brief      ラジアンに変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToRad( const f32 deg )
{ return deg * ( F_PI / 180.0f ); }

//-------------------------------------------------------------------------------------------------
//! @brief      度に変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToDeg( const f32 rad )
{ return rad * ( 180.0f / F_PI ); }

//-------------------------------------------------------------------------------------------------
//! @brief      非数であるかチェックします.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
bool IsNan( const f32 value )
{ return ( value != value ); }

//-------------------------------------------------------------------------------------------------
//! @brief      ゼロであるかチェックします.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
bool IsZero( const f32 value )
{ return ( fabs( value ) <= FLT_EPSILON ); }

//-------------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 SafeSqrt( const f32 value )
{
    if ( value > FLT_EPSILON )
    { return sqrtf( value ); }

    return 0.0f;
}

//-------------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f64 SafeSqrt( const f64 value )
{
    if ( value > DBL_EPSILON )
    { return sqrt( value ); }

    return 0.0;
}

//-------------------------------------------------------------------------------------------------
//! @brief      入力のうち下位16ビットを1つのビットごとに分離します
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Part1By1( u32 n )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.323参照 */

    // 入力のうち低いほうの16ビットを1つのビットごとに分離する.
    // n = ----------------fedcba9876543210 : 最初のビットの状態.
    // n = --------fedcba98--------76543210 : (1)の後.
    // n = ----fedc----ba98----7654----3210 : (2)の後.
    // n = --fe--dc--ba--98--76--54--32--10 : (3)の後.
    // n = -f-e-d-c-b-a-9-8-7-6-5-4-3-2-1-0 : (4)の後.
    n = ( n ^ ( n << 8 ) ) & 0x00ff00ff;    // (1)
    n = ( n ^ ( n << 4 ) ) & 0x0f0f0f0f;    // (2)
    n = ( n ^ ( n << 2 ) ) & 0x33333333;    // (3)
    n = ( n ^ ( n << 1 ) ) & 0x55555555;    // (4)

    return n;
}

//-------------------------------------------------------------------------------------------------
//! @brief      入力のうち下位10ビットを2つのビットごとに分離します
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Part1By2( u32 n )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.322参照 */

    // 入力のうち低いほうの10ビットを2つのビットごとに分離する.
    // n = ----------------------9876543210 : 最初のビットの状態.
    // n = ------98----------------76543210 : (1)の後.
    // n = ------98--------7654--------3210 : (2)の後.
    // n = ------98----76----54----32----10 : (3)の後.
    // n = ----9--8--7--6--5--4--3--2--1--0 : (4)の後.
    n = ( n ^ ( n << 16 ) ) & 0xff0000ff;   // (1)
    n = ( n ^ ( n <<  8 ) ) & 0x0300f00f;   // (2)
    n = ( n ^ ( n <<  4 ) ) & 0x030c30c3;   // (3)
    n = ( n ^ ( n <<  2 ) ) & 0x09249249;   // (4)

    return n;
}

//-------------------------------------------------------------------------------------------------
//! @brief      2次元を表すモートンコードを求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Morton2( u32 x, u32 y )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.323参照 */

    // 2つの16ビットの数字を入力として，それらの間にビットを挟み込んで1つの数字にする.
    return ( Part1By1( y ) << 1 )
         + ( Part1By1( x ) << 0 );
}

//-------------------------------------------------------------------------------------------------
//! @brief      3次元を表すモートンコードを求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Morton3( u32 x, u32 y, u32 z )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.322参照 */

    // 3つの10ビットの数字を入力として，それらをビットとして挟み込んで1つの数字にする.
    return ( Part1By2( z ) << 2 ) 
         + ( Part1By2( y ) << 1 )
         + ( Part1By2( x ) << 0 );
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Vector2 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Vector2
{
public:
    union
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
        };
        f32 a[2];       //!< 各成分を表す配列です;
    };

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector2()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector2( const f32 nx, const f32 ny )
    : x( nx )
    , y( ny )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector2( const Vector2& value )
    : x( value.x )
    , y( value.y )
    { /* DO_NOTHING */ }

    S3D_INLINE
    operator float* ()
    { return &x; }

    S3D_INLINE
    operator const float* () const
    { return &x; }

    //---------------------------------------------------------------------------------------------
    //! @brief      等価演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector2& value ) const
    {
        return ( x == value.x )
            && ( y == value.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      非等価演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector2& value ) const
    {
        return ( x != value.x )
            || ( y != value.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator = ( const Vector2& value )
    {
        x = value.x;
        y = value.y;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator += ( const Vector2& b )
    {
        x += b.x;
        y += b.y;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator -= ( const Vector2& b )
    {
        x -= b.x;
        y -= b.y;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator /= ( const f32 b )
    {
        assert( !IsZero( b ) );
        x /= b;
        y /= b;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2  operator + () const
    { return Vector2( x, y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - () const
    { return Vector2( -x, -y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator + (const Vector2 &b) const
    {
        return Vector2(
            x + b.x,
            y + b.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - (const Vector2 &b) const
    { 
        return Vector2(
            x - b.x,
            y - b.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator * (const f32 b) const
    { 
        return Vector2(
            x * b,
            y * b );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator / (const f32 b) const
    {
        assert( !IsZero( b ) );
        return Vector2(
            x / b,
            y / b );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        auto mag = sqrtf( x * x + y * y );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        auto mag = sqrtf( x * x + y * y );
        if ( mag > 0.0f )
        {
            x /= mag;
            y /= mag;
        }
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 UnitVector (const Vector2 &v)
    {
        auto mag = sqrtf( v.x * v.x + v.y * v.y );
        assert( !IsZero( mag ) );
        return Vector2(
            v.x / mag,
            v.y / mag );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 SafeUnitVector ( const Vector2& v)
    {
        auto mag = sqrtf( v.x * v.x + v.y * v.y );
        if ( mag > 0.0f )
        {
            return Vector2(
                v.x / mag,
                v.y / mag );
        }
        return v;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Mul (const Vector2 &v1, const Vector2 &v2)
    { 
        return Vector2(
            v1.x * v2.x,
            v1.y * v2.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector2 &v1, const Vector2 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Reflect( const Vector2& i, const Vector2& n )
    {
        auto dot = ( n.x * i.x ) + ( n.y * i.y );
        auto _2dot = 2.0f * dot;

        return Vector2(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ) );
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Min( const Vector2& a, const Vector2& b )
    {
        return Vector2( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y );
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Max( const Vector2& a, const Vector2& b )
    {
        return Vector2(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y );
    }

    static Vector2 Transform      ( const Vector2& position, const Matrix& matrix );
    static Vector2 TransformNormal( const Vector2& normal,   const Matrix& matrix );
    static Vector2 TransformCoord ( const Vector2& coord,    const Matrix& matrix );
};


///////////////////////////////////////////////////////////////////////////////////////////////////
// Vector3 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Vector3
{
public:
    union 
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
            f32 z;      //!< Z成分です.
        };
        f32 a[3];       //!< 各成分を表す配列です.
    };

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( const f32 nx, const f32 ny, const f32 nz ) 
    : x( nx )
    , y( ny )
    , z( nz )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( const Vector2& vec, const f32 nz )
    : x( vec.x )
    , y( vec.y )
    , z( nz )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( const Vector3& value )
    : x( value.x )
    , y( value.y )
    , z( value.z )
    { /* DO_NOTHING */ }

    S3D_INLINE
    operator float* ()
    { return &x; }

    S3D_INLINE
    operator const float* () const
    { return &x; }

    //---------------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector3& b ) const
    {
        return ( x == b.x )
            && ( y == b.y )
            && ( z == b.z );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector3& b ) const
    {
        return ( x != b.x )
            || ( y != b.y )
            || ( z != b.z );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator = ( const Vector3& b )
    {
        x = b.x;
        y = b.y;
        z = b.z;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator += ( const Vector3& b )
    {
        x += b.x;
        y += b.y;
        z += b.z;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator -= ( const Vector3& b )
    {
        x -= b.x;
        y -= b.y;
        z -= b.z;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        z *= b;
        return (*this);
    }

    //----------------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //----------------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator += ( const f32 b )
    {
        x += b;
        y += b;
        z += b;
        return (*this);
    }

    //----------------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //----------------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator -= ( const f32 b )
    {
        x -= b;
        y -= b;
        z -= b;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator /= ( const f32 b )
    {
        assert( !IsZero( b ) );
        x /= b;
        y /= b;
        z /= b;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3  operator + () const
    { return Vector3( x, y, z ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - () const
    { return Vector3( -x, -y, -z ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator + (const Vector3 &b) const
    {
        return Vector3(
            x + b.x,
            y + b.y,
            z + b.z);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - (const Vector3 &b) const
    { 
        return Vector3(
            x - b.x,
            y - b.y,
            z - b.z);
    }

    S3D_INLINE
    Vector3 operator + ( const f32 b ) const
    {
        return Vector3(
            x + b,
            y + b,
            z + b );
    }

    S3D_INLINE
    Vector3 operator - ( const f32 b ) const
    {
        return Vector3(
            x - b,
            y - b,
            z - b  );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator * (const f32 b) const
    { 
        return Vector3(
            x * b,
            y * b,
            z * b);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator / (const f32 b) const
    {
        assert( !IsZero( b ) );
        return Vector3(
            x / b,
            y / b,
            z / b);
    }

    S3D_INLINE
    Vector3 operator * ( const Vector3& v ) const
    {
        return Vector3(
            x * v.x,
            y * v.y,
            z * v.z );
    }

    S3D_INLINE
    Vector3 operator / ( const Vector3& v ) const
    {
        return Vector3(
            x / v.x,
            y / v.y,
            z / v.z );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ) + ( z * z ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        auto mag = sqrtf( x * x + y * y + z * z );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
        z /= mag;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        auto mag = sqrtf( x * x + y * y + z * z );
        if ( mag > 0.0f )
        {
             x /= mag;
             y /= mag;
             z /= mag;
        }
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 UnitVector (const Vector3 &v)
    {
        auto mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z );
        assert( mag > 0.0f );
        return Vector3(
            v.x / mag,
            v.y / mag,
            v.z / mag );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 SafeUnitVector (const Vector3& v)
    {
        auto mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z );
        if ( mag > 0.0f )
        {
            return Vector3(
                v.x / mag,
                v.y / mag,
                v.z / mag );
        }
        return v;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Mul (const Vector3 &v1, const Vector3 &v2)
    { 
        return Vector3(
            v1.x * v2.x,
            v1.y * v2.y,
            v1.z * v2.z);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector3 &v1, const Vector3 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ) + ( v1.z * v2.z ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      外積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Cross (const Vector3 &v1, const Vector3 &v2) 
    {
        return Vector3(
            (v1.y * v2.z) - (v1.z * v2.y),
            (v1.z * v2.x) - (v1.x * v2.z),
            (v1.x * v2.y) - (v1.y * v2.x)
        );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Reflect( const Vector3& i, const Vector3& n )
    {
        auto dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
        auto _2dot = 2.0f * dot;

        return Vector3(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ),
            i.z - ( _2dot * n.z ) );
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Min( const Vector3& a, const Vector3& b )
    {
        return Vector3( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y,
            ( a.z < b.z ) ? a.z : b.z );
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Max( const Vector3& a, const Vector3& b )
    {
        return Vector3(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y,
            ( a.z > b.z ) ? a.z : b.z );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      法線ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeNormal( const Vector3& a, const Vector3& b, const Vector3& c )
    {
        auto e1 = b - a;
        auto e2 = c - a;
        return Vector3::UnitVector( Vector3::Cross( e1, e2 ) );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      矩形の法線ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeQuadNormal( const Vector3& a, const Vector3& b, const Vector3& c, const Vector3& d )
    {
        auto n1a = ComputeNormal( a, b, c );
        auto n1b = ComputeNormal( a, c, d );
        auto n2a = ComputeNormal( b, c, d );
        auto n2b = ComputeNormal( b, d, c );

        if ( Vector3::Dot( n1a, n1b ) > Vector3::Dot( n2a, n2b ) )
        { return Vector3::UnitVector( n1a + n1b ); }
        else
        { return Vector3::UnitVector( n2a + n2b ); }
    }

    static Vector3 Transform      ( const Vector3& position, const Matrix& matrix );
    static Vector3 TransformNormal( const Vector3& normal,   const Matrix& matrix );
    static Vector3 TransformCoord ( const Vector3& coord,    const Matrix& matrix );
};

//------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//------------------------------------------------------------------------------------------
S3D_INLINE 
Vector3 operator * (const f32 f, const Vector3 &v)
{ return v * f; }

S3D_INLINE
Vector3 operator / ( const f32 f, const Vector3& v )
{ return Vector3( f / v.x, f / v.y, f / v.z ); }

S3D_INLINE
Vector3 operator + ( const f32 f, const Vector3& v)
{ return Vector3( f + v.x, f + v.y, f + v.z ); }

S3D_INLINE
Vector3 operator - ( const f32 f, const Vector3& v )
{ return Vector3( f - v.x, f - v.y, f - v.z ); }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Vector4 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct S3D_ALIGN(16) Vector4
{
public:
    union 
    {
    #if S3D_IS_SIMD
        b128    v;      //!< パック化された値です.
    #endif
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
            f32 z;      //!< Z成分です.
            f32 w;      //!< W成分です.
        };
        f32     a[4];   //!< 各成分を表す配列です.
    };

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const f32 nx, const f32 ny, const f32 nz, const f32 nw ) 
  #if S3D_IS_SIMD
    : v( _mm_set_ps( nw, nz, ny, nx ) )
  #else
    : x( nx )
    , y( ny )
    , z( nz )
    , w( nz )
  #endif
    {
        /* DO_NOTHING */
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const Vector3& val, const f32 nw )
  #if S3D_IS_SIMD
    : v( _mm_set_ps( nw, val.z, val.y, val.x ) )
  #else
    : x( val.x )
    , y( val.y )
    , z( val.z )
    , w( nw )
  #endif
    {
        /* DO_NOTHING */
    }

  #if S3D_IS_SIMD
    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const b128 nv )
    : v( nv )
    { /* DO_NOTHING */ }
  #endif//S3D_IS_SIMD

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const Vector4& value )
  #if S3D_IS_SIMD
    : v( value.v )
  #else
    : x( value.x )
    , y( value.y )
    , z( value.z )
    , w( value.w )
  #endif
    { /* DO_NOTHING */ }

    S3D_INLINE
    operator float* ()
    { return &x; }

    S3D_INLINE
    operator const float* () const
    { return &x; }

    //---------------------------------------------------------------------------------------------
    //! @brief      X成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetX() const
    {
    #if S3D_IS_SIMD
        return _mm_cvtss_f32( v );
    #else
        return x;
    #endif
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetY() const
    {
    #if S3D_IS_SIMD
        auto temp = _mm_shuffle_ps( v, v, _MM_SHUFFLE( 1, 1, 1, 1 ) );
        return _mm_cvtss_f32( temp );
    #else
        return y;
    #endif
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetZ() const
    {
    #if S3D_IS_SIMD
        auto temp = _mm_shuffle_ps( v, v, _MM_SHUFFLE( 2, 2, 2, 2 ) );
        return _mm_cvtss_f32( temp );
    #else
        return z;
    #endif
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      W成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetW() const
    {
    #if S3D_IS_SIMD
        auto temp = _mm_shuffle_ps( v, v, _MM_SHUFFLE( 3, 3, 3, 3 ) );
        return _mm_cvtss_f32( temp );
    #else
        return w;
    #endif
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector4& b ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_cmpeq_ps( v, b.v );
        return ((_mm_movemask_ps(c) == 0x0f) != 0);
    #else
        return ( x == b.x )
            && ( y == b.y )
            && ( z == b.z )
            && ( w == b.w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector4& b ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_cmpneq_ps( v, b.v );
        return ((_mm_movemask_ps(c)) != 0);
    #else
        return ( x != b.x )
            || ( y != b.y )
            || ( z != b.z )
            || ( w != b.w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator = ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = b.v;
    #else
        x = b.x;
        y = b.y;
        z = b.z;
        w = b.w;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator += ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = _mm_add_ps( v, b.v );
    #else
        x += b.x;
        y += b.y;
        z += b.z;
        w += b.w;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator -= ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = _mm_sub_ps( v, b.v );
    #else
        x -= b.x;
        y -= b.y;
        z -= b.z;
        w -= b.w;
    #endif
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator *= ( const f32 b )
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( b, b, b, b );
        v = _mm_mul_ps( v, c );
    #else
        x *= b;
        y *= b;
        z *= b;
        w *= b;
    #endif
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator /= ( const f32 b )
    {
        assert( !IsZero( b ) );
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( b, b, b, b );
        v = _mm_div_ps( v, c );
    #else
        x /= b;
        y /= b;
        z /= b;
        w /= b;
    #endif
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4  operator + () const
    {
    #if S3D_IS_SIMD
        return Vector4( v );
    #else
        return Vector4( x, y, z, w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - () const
    {
    #if S3D_IS_SIMD
        b128 z = _mm_setzero_ps();
        return Vector4( _mm_sub_ps( z, v ) );
    #else
        return Vector4( -x, -y, -z, -w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator + (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_add_ps( v, b.v ) );
    #else
        return Vector4(
            x + b.x,
            y + b.y,
            z + b.z,
            w + b.w);
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_sub_ps( v, b.v ) );
    #else
        return Vector4(
            x - b.x,
            y - b.y,
            z - b.z,
            w - b.w);
    #endif//S3D_IS_SIMD
    }

    S3D_INLINE
    Vector4 operator * (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_mul_ps( v, b.v ) );
    #else
        return Vector4(
            x * b.x,
            y * b.y,
            z * b.z,
            w * b.w );
    #endif
    }

    S3D_INLINE
    Vector4 operator / ( const Vector4& b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_div_ps( v, b.v ) );
    #else
        return Vector4(
            x / b.x,
            y / b.y,
            z / b.z,
            w / b.w );
    #endif
    }

    S3D_INLINE
    Vector4 operator + ( const f32 b ) const
    {
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_add_ps( v, s ) );
    #else
        return Vector4(
            x + b,
            y + b,
            z + b,
            w + b );
    #endif
    }

    S3D_INLINE
    Vector4 operator - ( const f32 b ) const
    {
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_sub_ps( v, s ) );
    #else
        return Vector4(
            x - b,
            y - b,
            z - b,
            w - b );
    #endif
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator * (const f32 b) const
    {
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_mul_ps( v, s ) );
    #else
        return Vector4(
            x * b,
            y * b,
            z * b,
            w * b);
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator / (const f32 b) const
    {
        assert( !IsZero( b ) );
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_div_ps( v, s ) );
    #else
        return Vector4(
            x / b,
            y / b,
            z / b,
            w / b);
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { 
    #if S3D_IS_SIMD
        return Dot( v, v );
    #else
        return ( x * x ) + ( y * y ) + ( z * z ) + ( w * w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    {
    #if S3D_IS_SIMD
        return sqrtf( Dot( v, v ) );
    #else
        return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    #endif
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
    #if S3D_IS_SIMD
        auto mag = sqrtf( Dot( v, v ) );
        assert( mag > 0.0f );
        b128 c = _mm_set1_ps( mag );
        v = _mm_div_ps( v, c );
    #else
        auto mag = sqrtf( x * x + y * y + z * z + w * w );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
        z /= mag;
        w /= mag;
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
    #if S3D_IS_SIMD
        auto mag = sqrtf( Dot( v, v) );
        if ( mag > 0.0f )
        {
            b128 c = _mm_set1_ps( mag );
            v = _mm_div_ps( v, c );
        }
    #else
        auto mag = sqrtf( x * x + y * y + z * z + w * w );
        if ( mag > 0.0f )
        {
             x /= mag;
             y /= mag;
             z /= mag;
             w /= mag;
        }
    #endif// S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 UnitVector (const Vector4 &v)
    {
    #if S3D_IS_SIMD
        auto mag = sqrtf( Dot( v, v ) );
        assert( mag > 0.0f );
        b128 c = _mm_set1_ps( mag );
        return Vector4( _mm_div_ps( v.v, c ) );
    #else
        auto mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w );
        assert( mag > 0.0f );
        return Vector4(
            v.x / mag,
            v.y / mag,
            v.z / mag,
            v.w / mag );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 SafeUnitVector (const Vector4& v)
    {
    #if S3D_IS_SIMD
        auto mag = sqrtf( Dot( v, v ) );
        if ( mag > 0.0f )
        {
            b128 c = _mm_set1_ps( mag );
            return Vector4( _mm_div_ps( v.v, c ) );
        }
    #else
        auto mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w );
        if ( mag > 0.0f )
        {
            return Vector4(
                v.x / mag,
                v.y / mag,
                v.z / mag,
                v.w / mag );
        }
    #endif
        return v;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Mul (const Vector4 &v1, const Vector4 &v2)
    { 
    #if S3D_IS_SIMD
        return Vector4( _mm_mul_ps( v1.v, v2.v ) );
    #else
        return Vector4(
            v1.x * v2.x,
            v1.y * v2.y,
            v1.z * v2.z,
            v1.w * v2.w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector4 &v1, const Vector4 &v2) 
    {
    #if S3D_IS_SIMD
        Vector4 ret = _mm_mul_ps( v1.v, v2.v );
        return ret.GetX() + ret.GetY() + ret.GetZ() + ret.GetW();
    #else
        return ( v1.x * v2.x ) + ( v1.y * v2.y ) + ( v1.z * v2.z ) + ( v1.w * v2.w );
    #endif
    }


    //---------------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Reflect( const Vector4& i, const Vector4& n )
    {
    #if S3D_IS_SIMD
        register f32 _2dot = 2.0f * Dot( i, n );
        b128 c = _mm_set1_ps( _2dot );
        b128 b = _mm_mul_ps( c, n.v );
        return Vector4( _mm_sub_ps( i.v, b ) );
    #else
        auto dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
        auto _2dot = 2.0f * dot;

        return Vector4(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ),
            i.z - ( _2dot * n.z ),
            i.w - ( _2dot * n.w ) );
    #endif//S3D_IS_SIMD
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Min( const Vector4& a, const Vector4& b )
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_min_ps( a.v, b.v ) );
    #else
        return Vector4( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y,
            ( a.z < b.z ) ? a.z : b.z,
            ( a.w < b.w ) ? a.w : b.w );
    #endif//S3D_IS_SIMD
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Max( const Vector4& a, const Vector4& b )
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_max_ps( a.v, b.v ) );
    #else
        return Vector4(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y,
            ( a.z > b.z ) ? a.z : b.z,
            ( a.w > b.w ) ? a.w : b.w );
    #endif//S3D_IS_SIMD
    }

    static Vector4 Transform( const Vector4& value, const Matrix& matrix );
};

//------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//------------------------------------------------------------------------------------------
S3D_INLINE 
Vector4 operator * (const f32 f, const Vector4 &v)
{
#if S3D_IS_SIMD
    b128 c = _mm_set1_ps( f );
    return Vector4( _mm_mul_ps( c, v.v ) );
#else
    return Vector4(
        f * v.x,
        f * v.y,
        f * v.z,
        f * v.w );
#endif//S3D_IS_SIMD
}

S3D_INLINE
Vector4 operator + (const f32 f, const Vector4& v)
{
#if S3D_IS_SIMD
    b128 s = _mm_set1_ps( f );
    return Vector4( _mm_add_ps( s, v.v ) );
#else
    return Vector4(
        s + v.x,
        s + v.y,
        s + v.z,
        s + v.w );
#endif
}

S3D_INLINE
Vector4 operator - ( const f32 f, const Vector4& v)
{
#if S3D_IS_SIMD
    b128 s = _mm_set1_ps( f );
    return Vector4( _mm_sub_ps( s, v.v ) );
#else
    return Vector4(
        f - v.x,
        f - v.y,
        f - v.z,
        f - v.w );
#endif
}


////////////////////////////////////////////////////////////////////////////////////////////
// Ray structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray
{
    Vector3 pos;            //!< 位置座標です.
    Vector3 dir;            //!< 方向ベクトルです.
    Vector3 invDir;         //!< 方向ベクトルの各成分の逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray( const Vector3& p, const Vector3& d )
    { Update( p, d ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray( const Ray& value )
    { Update( value.pos, value.dir ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      レイを更新します.
    //---------------------------------------------------------------------------------------------
    void Update( const Vector3& p, const Vector3& d )
    {
        pos.x = p.x;
        pos.y = p.y;
        pos.z = p.z;

        dir.x = d.x;
        dir.y = d.y;
        dir.z = d.z;

        invDir.x = 1.0f / dir.x;
        invDir.y = 1.0f / dir.y;
        invDir.z = 1.0f / dir.z;

        sign[0] = ( dir.x >= 0.0f ) ? 0 : 1;
        sign[1] = ( dir.y >= 0.0f ) ? 0 : 1;
        sign[2] = ( dir.z >= 0.0f ) ? 0 : 1;
    }
};

////////////////////////////////////////////////////////////////////////////////////////////
// Ray4 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray4
{
    b128    pos[3];         //!< 位置座標です.
    b128    invDir[3];      //!< 方向ベクトルの逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //-------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray4( const Ray& ray )
    {
    #if S3D_IS_SIMD
        pos[0] = _mm_set1_ps( ray.pos.x );
        pos[1] = _mm_set1_ps( ray.pos.y );
        pos[2] = _mm_set1_ps( ray.pos.z );

        invDir[0] = _mm_set1_ps( ray.invDir.x );
        invDir[1] = _mm_set1_ps( ray.invDir.y );
        invDir[2] = _mm_set1_ps( ray.invDir.z );
    #else
        pos[0].m128_f32[0] = ray.pos.x;
        pos[0].m128_f32[1] = ray.pos.x;
        pos[0].m128_f32[2] = ray.pos.x;
        pos[0].m128_f32[3] = ray.pos.x;

        pos[1].m128_f32[0] = ray.pos.y;
        pos[1].m128_f32[1] = ray.pos.y;
        pos[1].m128_f32[2] = ray.pos.y;
        pos[1].m128_f32[3] = ray.pos.y;

        pos[2].m128_f32[0] = ray.pos.z;
        pos[2].m128_f32[1] = ray.pos.z;
        pos[2].m128_f32[2] = ray.pos.z;
        pos[2].m128_f32[3] = ray.pos.z;

        invDir[0].m128_f32[0] = ray.invDir.x;
        invDir[0].m128_f32[1] = ray.invDir.x;
        invDir[0].m128_f32[2] = ray.invDir.x;
        invDir[0].m128_f32[3] = ray.invDir.x;

        invDir[1].m128_f32[0] = ray.invDir.y;
        invDir[1].m128_f32[1] = ray.invDir.y;
        invDir[1].m128_f32[2] = ray.invDir.y;
        invDir[1].m128_f32[3] = ray.invDir.y;

        invDir[2].m128_f32[0] = ray.invDir.z;
        invDir[2].m128_f32[1] = ray.invDir.z;
        invDir[2].m128_f32[2] = ray.invDir.z;
        invDir[2].m128_f32[3] = ray.invDir.z;
    #endif
        sign[0] = ray.sign[0];
        sign[1] = ray.sign[1];
        sign[2] = ray.sign[2];
    }

    //-------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray4( const Ray4& rayQuad )
    {
        pos[0] = rayQuad.pos[0];
        pos[1] = rayQuad.pos[1];
        pos[2] = rayQuad.pos[2];

        invDir[0] = rayQuad.invDir[0];
        invDir[1] = rayQuad.invDir[1];
        invDir[2] = rayQuad.invDir[2];

        sign[0] = rayQuad.sign[0];
        sign[1] = rayQuad.sign[1];
        sign[2] = rayQuad.sign[2];
    }
};


////////////////////////////////////////////////////////////////////////////////////////////
// Ray4 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray8
{
    b256    pos[3];         //!< 位置座標です.
    b256    invDir[3];      //!< 方向ベクトルの逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //-------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray8( const Ray& ray )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        pos[0] = _mm256_set1_ps( ray.pos.x );
        pos[1] = _mm256_set1_ps( ray.pos.y );
        pos[2] = _mm256_set1_ps( ray.pos.z );

        invDir[0] = _mm256_set1_ps( ray.invDir.x );
        invDir[1] = _mm256_set1_ps( ray.invDir.y );
        invDir[2] = _mm256_set1_ps( ray.invDir.z );
    #else
        pos[0].m256_f32[0] = ray.pos.x;
        pos[0].m256_f32[1] = ray.pos.x;
        pos[0].m256_f32[2] = ray.pos.x;
        pos[0].m256_f32[3] = ray.pos.x;
        pos[0].m256_f32[4] = ray.pos.x;
        pos[0].m256_f32[5] = ray.pos.x;
        pos[0].m256_f32[6] = ray.pos.x;
        pos[0].m256_f32[7] = ray.pos.x;

        pos[1].m256_f32[0] = ray.pos.y;
        pos[1].m256_f32[1] = ray.pos.y;
        pos[1].m256_f32[2] = ray.pos.y;
        pos[1].m256_f32[3] = ray.pos.y;
        pos[1].m256_f32[4] = ray.pos.y;
        pos[1].m256_f32[5] = ray.pos.y;
        pos[1].m256_f32[6] = ray.pos.y;
        pos[1].m256_f32[7] = ray.pos.y;

        pos[2].m256_f32[0] = ray.pos.z;
        pos[2].m256_f32[1] = ray.pos.z;
        pos[2].m256_f32[2] = ray.pos.z;
        pos[2].m256_f32[3] = ray.pos.z;
        pos[2].m256_f32[4] = ray.pos.z;
        pos[2].m256_f32[5] = ray.pos.z;
        pos[2].m256_f32[6] = ray.pos.z;
        pos[2].m256_f32[7] = ray.pos.z;

        invDir[0].m256_f32[0] = ray.invDir.x;
        invDir[0].m256_f32[1] = ray.invDir.x;
        invDir[0].m256_f32[2] = ray.invDir.x;
        invDir[0].m256_f32[3] = ray.invDir.x;
        invDir[0].m256_f32[4] = ray.invDir.x;
        invDir[0].m256_f32[5] = ray.invDir.x;
        invDir[0].m256_f32[6] = ray.invDir.x;
        invDir[0].m256_f32[7] = ray.invDir.x;

        invDir[1].m256_f32[0] = ray.invDir.y;
        invDir[1].m256_f32[1] = ray.invDir.y;
        invDir[1].m256_f32[2] = ray.invDir.y;
        invDir[1].m256_f32[3] = ray.invDir.y;
        invDir[1].m256_f32[4] = ray.invDir.y;
        invDir[1].m256_f32[5] = ray.invDir.y;
        invDir[1].m256_f32[6] = ray.invDir.y;
        invDir[1].m256_f32[7] = ray.invDir.y;

        invDir[2].m256_f32[0] = ray.invDir.z;
        invDir[2].m256_f32[1] = ray.invDir.z;
        invDir[2].m256_f32[2] = ray.invDir.z;
        invDir[2].m256_f32[3] = ray.invDir.z;
        invDir[2].m256_f32[4] = ray.invDir.z;
        invDir[2].m256_f32[5] = ray.invDir.z;
        invDir[2].m256_f32[6] = ray.invDir.z;
        invDir[2].m256_f32[7] = ray.invDir.z;
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
        sign[0] = ray.sign[0];
        sign[1] = ray.sign[1];
        sign[2] = ray.sign[2];
    }

    //-------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray8( const Ray8& rayOct )
    {
        pos[0] = rayOct.pos[0];
        pos[1] = rayOct.pos[1];
        pos[2] = rayOct.pos[2];

        invDir[0] = rayOct.invDir[0];
        invDir[1] = rayOct.invDir[1];
        invDir[2] = rayOct.invDir[2];

        sign[0] = rayOct.sign[0];
        sign[1] = rayOct.sign[1];
        sign[2] = rayOct.sign[2];
    }
};



////////////////////////////////////////////////////////////////////////////////////////////
// Matric structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Matrix
{
public:
    //======================================================================================
    // public variables.
    //======================================================================================
    union
    {
        struct 
        {
            f32 _11, _12, _13, _14;
            f32 _21, _22, _23, _24;
            f32 _31, _32, _33, _34;
            f32 _41, _42, _43, _44;
        };
        f32     a[16];
    #if S3D_IS_SIMD
        struct
        {
            b128    v0;
            b128    v1;
            b128    v2;
            b128    v3;
        };
    #endif
    };

    //======================================================================================
    // public methods
    //======================================================================================

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix
    (
        const f32 m11, const f32 m12, const f32 m13, const f32 m14,
        const f32 m21, const f32 m22, const f32 m23, const f32 m24,
        const f32 m31, const f32 m32, const f32 m33, const f32 m34,
        const f32 m41, const f32 m42, const f32 m43, const f32 m44
    )
  #if S3D_IS_SIMD
    : v0( _mm_set_ps( m14, m13, m12, m11 ) )
    , v1( _mm_set_ps( m24, m23, m22, m21 ) )
    , v2( _mm_set_ps( m34, m33, m32, m31 ) )
    , v3( _mm_set_ps( m44, m43, m42, m41 ) )
  #else
    : _11( m11 ), _12( m12 ), _13( m13 ), _14( m14 )
    , _21( m21 ), _22( m22 ), _23( m23 ), _24( m24 )
    , _31( m31 ), _32( m32 ), _33( m33 ), _34( m34 )
    , _41( m41 ), _42( m42 ), _43( m43 ), _44( m44 )
  #endif//S3D_IS_SIMD
    { /* DO_NOTHING */ }

  #if S3D_IS_SIMD
    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix( const b128& c0, const b128& c1, const b128& c2, const b128& c3 )
    : v0( c0 )
    , v1( c1 )
    , v2( c2 )
    , v3( c3 )
    { /* DO_NOTHING */ }
  #endif//S3D_IS_SIMD

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix( const Matrix& value)
  #if S3D_IS_SIMD
    : v0 ( value.v0 )
    , v1 ( value.v1 )
    , v2 ( value.v2 )
    , v3 ( value.v3 )
  #else
    : _11( value._11 ), _12( value._12 ), _13( value._13 ), _14( value._14 )
    , _21( value._21 ), _22( value._22 ), _23( value._23 ), _24( value._24 )
    , _31( value._31 ), _32( value._32 ), _33( value._33 ), _34( value._34 )
    , _41( value._41 ), _42( value._42 ), _43( value._43 ), _44( value._44 )
  #endif//S3D_IS_SIMD
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator =  ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        v0 = value.v0;
        v1 = value.v1;
        v2 = value.v2;
        v3 = value.v3;
    #else
        _11 = value._11; _12 = value._12; _13 = value._13; _14 = value._14;
        _21 = value._21; _22 = value._22; _23 = value._23; _24 = value._24;
        _31 = value._31; _32 = value._32; _33 = value._33; _34 = value._34;
        _41 = value._41; _42 = value._42; _43 = value._43; _44 = value._44;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator += ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        v0 = _mm_add_ps( v0, value.v0 );
        v1 = _mm_add_ps( v1, value.v1 );
        v2 = _mm_add_ps( v2, value.v2 );
        v3 = _mm_add_ps( v3, value.v3 );
    #else
        _11 += value._11; _12 += value._12; _13 += value._13; _14 += value._14;
        _21 += value._21; _22 += value._22; _23 += value._23; _24 += value._24;
        _31 += value._31; _32 += value._32; _33 += value._33; _34 += value._34;
        _41 += value._41; _42 += value._42; _43 += value._43; _44 += value._44;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator -= ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        v0 = _mm_sub_ps( v0, value.v0 );
        v1 = _mm_sub_ps( v1, value.v1 );
        v2 = _mm_sub_ps( v2, value.v2 );
        v3 = _mm_sub_ps( v3, value.v3 );
    #else
        _11 -= value._11; _12 -= value._12; _13 -= value._13; _14 -= value._14;
        _21 -= value._21; _22 -= value._22; _23 -= value._23; _24 -= value._24;
        _31 -= value._31; _32 -= value._32; _33 -= value._33; _34 -= value._34;
        _41 -= value._41; _42 -= value._42; _43 -= value._43; _44 -= value._44;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator *= ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        b128 r0 = _mm_set_ps( value._41, value._31, value._21, value._11 );
        b128 r1 = _mm_set_ps( value._42, value._32, value._22, value._12 );
        b128 r2 = _mm_set_ps( value._43, value._33, value._23, value._13 );
        b128 r3 = _mm_set_ps( value._44, value._34, value._24, value._14 );

        v0 = _mm_set_ps( 
            Vector4::Dot( v0, r3 ),
            Vector4::Dot( v0, r2 ),
            Vector4::Dot( v0, r1 ),
            Vector4::Dot( v0, r0 ) );

        v1 = _mm_set_ps(
            Vector4::Dot( v1, r3 ),
            Vector4::Dot( v1, r2 ),
            Vector4::Dot( v1, r1 ),
            Vector4::Dot( v1, r0 ) );

        v2 = _mm_set_ps(
            Vector4::Dot( v2, r3 ),
            Vector4::Dot( v2, r2 ),
            Vector4::Dot( v2, r1 ), 
            Vector4::Dot( v2, r0 ) );

        v3 = _mm_set_ps(
            Vector4::Dot( v3, r3 ),
            Vector4::Dot( v3, r2 ),
            Vector4::Dot( v3, r1 ),
            Vector4::Dot( v3, r0 ) );
    #else
        {
            auto m11 = ( _11 * value._11 ) + ( _12 * value._21 ) + ( _13 * value._31 ) + ( _14 * value._41 );
            auto m12 = ( _11 * value._12 ) + ( _12 * value._22 ) + ( _13 * value._32 ) + ( _14 * value._42 );
            auto m13 = ( _11 * value._13 ) + ( _12 * value._23 ) + ( _13 * value._33 ) + ( _14 * value._43 );
            auto m14 = ( _11 * value._14 ) + ( _12 * value._24 ) + ( _13 * value._34 ) + ( _14 * value._44 );

            _11 = m11;
            _12 = m12;
            _13 = m13;
            _14 = m14;
        }

        {
            auto m21 = ( _21 * value._11 ) + ( _22 * value._21 ) + ( _23 * value._31 ) + ( _24 * value._41 );
            auto m22 = ( _21 * value._12 ) + ( _22 * value._22 ) + ( _23 * value._32 ) + ( _24 * value._42 );
            auto m23 = ( _21 * value._13 ) + ( _22 * value._23 ) + ( _23 * value._33 ) + ( _24 * value._43 );
            auto m24 = ( _21 * value._14 ) + ( _22 * value._24 ) + ( _23 * value._34 ) + ( _24 * value._44 );

            _21 = m21;
            _22 = m22;
            _23 = m23;
            _24 = m24;
        }

        {
            auto m31 = ( _31 * value._11 ) + ( _32 * value._21 ) + ( _33 * value._31 ) + ( _34 * value._41 );
            auto m32 = ( _31 * value._12 ) + ( _32 * value._22 ) + ( _33 * value._32 ) + ( _34 * value._42 );
            auto m33 = ( _31 * value._13 ) + ( _32 * value._23 ) + ( _33 * value._33 ) + ( _34 * value._43 );
            auto m34 = ( _31 * value._14 ) + ( _32 * value._24 ) + ( _33 * value._34 ) + ( _34 * value._44 );

            _31 = m31;
            _32 = m32;
            _33 = m33;
            _34 = m34;
        }

        {
            auto m41 = ( _41 * value._11 ) + ( _42 * value._21 ) + ( _43 * value._31 ) + ( _44 * value._41 );
            auto m42 = ( _41 * value._12 ) + ( _42 * value._22 ) + ( _43 * value._32 ) + ( _44 * value._42 );
            auto m43 = ( _41 * value._13 ) + ( _42 * value._23 ) + ( _43 * value._33 ) + ( _44 * value._43 );
            auto m44 = ( _41 * value._14 ) + ( _42 * value._24 ) + ( _43 * value._34 ) + ( _44 * value._44 );

            _41 = m41;
            _42 = m42;
            _43 = m43;
            _44 = m44;
        }
    #endif//S3D_IS_SIMD

        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator *= ( const f32 value )
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( value, value, value, value );
        v0 = _mm_mul_ps( v0, c );
        v1 = _mm_mul_ps( v1, c );
        v2 = _mm_mul_ps( v2, c );
        v3 = _mm_mul_ps( v3, c );
    #else
        _11 *= value; _12 *= value; _13 *= value; _14 *= value;
        _21 *= value; _22 *= value; _23 *= value; _24 *= value;
        _31 *= value; _32 *= value; _33 *= value; _34 *= value;
        _41 *= value; _42 *= value; _43 *= value; _44 *= value;
    #endif//S3D_IS_SIMD
        return (*this); 
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator + () const
    { return (*this); }
    
    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator - () const
    {
    #if S3D_IS_SIMD
        b128 z = _mm_setzero_ps();
        return Matrix(
            _mm_sub_ps( z, v0 ),
            _mm_sub_ps( z, v1 ),
            _mm_sub_ps( z, v2 ),
            _mm_sub_ps( z, v3 ) );
    #else
        return Matrix(
            -_11, -_12, -_13, -_14,
            -_21, -_22, -_23, -_24,
            -_31, -_32, -_33, -_34,
            -_41, -_42, -_43, -_44 );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator + ( const Matrix& value ) const
    {
    #if S3D_IS_SIMD
        return Matrix(
            _mm_add_ps( v0, value.v0 ),
            _mm_add_ps( v1, value.v1 ),
            _mm_add_ps( v2, value.v2 ),
            _mm_add_ps( v3, value.v3 ) );
    #else
        return Matrix(
            _11 + value._11, _12 + value._12, _13 + value._13, _14 + value._14,
            _21 + value._21, _22 + value._22, _23 + value._23, _24 + value._24,
            _31 + value._31, _32 + value._32, _33 + value._33, _34 + value._34,
            _41 + value._41, _42 + value._42, _43 + value._43, _44 + value._44 );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator - ( const Matrix& value ) const
    {
    #if S3D_IS_SIMD
        return Matrix(
            _mm_sub_ps( v0, value.v0 ),
            _mm_sub_ps( v1, value.v1 ),
            _mm_sub_ps( v2, value.v2 ),
            _mm_sub_ps( v3, value.v3 ) );
    #else
        return Matrix(
            _11 - value._11, _12 - value._12, _13 - value._13, _14 - value._14,
            _21 - value._21, _22 - value._22, _23 - value._23, _24 - value._24,
            _31 - value._31, _32 - value._32, _33 - value._33, _34 - value._34,
            _41 - value._41, _42 - value._42, _43 - value._43, _44 - value._44 );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator * ( const Matrix& value ) const
    {
    #if S3D_IS_SIMD
        b128 r0 = _mm_set_ps( value._41, value._31, value._21, value._11 );
        b128 r1 = _mm_set_ps( value._42, value._32, value._22, value._12 );
        b128 r2 = _mm_set_ps( value._43, value._33, value._23, value._13 );
        b128 r3 = _mm_set_ps( value._44, value._34, value._24, value._14 );

        auto e0 = _mm_set_ps(
            Vector4::Dot( v0, r3 ),
            Vector4::Dot( v0, r2 ),
            Vector4::Dot( v0, r1 ),
            Vector4::Dot( v0, r0 ) );

        auto e1 = _mm_set_ps(
            Vector4::Dot( v1, r3 ),
            Vector4::Dot( v1, r2 ),
            Vector4::Dot( v1, r1 ),
            Vector4::Dot( v1, r0 ) );

        auto e2 = _mm_set_ps(
            Vector4::Dot( v2, r3 ),
            Vector4::Dot( v2, r2 ),
            Vector4::Dot( v2, r1 ),
            Vector4::Dot( v2, r0 ) );

        auto e3 = _mm_set_ps(
            Vector4::Dot( v3, r3 ),
            Vector4::Dot( v3, r2 ),
            Vector4::Dot( v3, r1 ),
            Vector4::Dot( v3, r0 ) );

        return Matrix( e0, e1, e2, e3 );
    #else
        return Matrix(
                ( _11 * value._11 ) + ( _12 * value._21 ) + ( _13 * value._31 ) + ( _14 * value._41 ),
                ( _11 * value._12 ) + ( _12 * value._22 ) + ( _13 * value._32 ) + ( _14 * value._42 ),
                ( _11 * value._13 ) + ( _12 * value._23 ) + ( _13 * value._33 ) + ( _14 * value._43 ),
                ( _11 * value._14 ) + ( _12 * value._24 ) + ( _13 * value._34 ) + ( _14 * value._44 ),

                ( _21 * value._11 ) + ( _22 * value._21 ) + ( _23 * value._31 ) + ( _24 * value._41 ),
                ( _21 * value._12 ) + ( _22 * value._22 ) + ( _23 * value._32 ) + ( _24 * value._42 ),
                ( _21 * value._13 ) + ( _22 * value._23 ) + ( _23 * value._33 ) + ( _24 * value._43 ),
                ( _21 * value._14 ) + ( _22 * value._24 ) + ( _23 * value._34 ) + ( _24 * value._44 ),

                ( _31 * value._11 ) + ( _32 * value._21 ) + ( _33 * value._31 ) + ( _34 * value._41 ),
                ( _31 * value._12 ) + ( _32 * value._22 ) + ( _33 * value._32 ) + ( _34 * value._42 ),
                ( _31 * value._13 ) + ( _32 * value._23 ) + ( _33 * value._33 ) + ( _34 * value._43 ),
                ( _31 * value._14 ) + ( _32 * value._24 ) + ( _33 * value._34 ) + ( _34 * value._44 ),

                ( _41 * value._11 ) + ( _42 * value._21 ) + ( _43 * value._31 ) + ( _44 * value._41 ),
                ( _41 * value._12 ) + ( _42 * value._22 ) + ( _43 * value._32 ) + ( _44 * value._42 ),
                ( _41 * value._13 ) + ( _42 * value._23 ) + ( _43 * value._33 ) + ( _44 * value._43 ),
                ( _41 * value._14 ) + ( _42 * value._24 ) + ( _43 * value._34 ) + ( _44 * value._44 ) );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator * ( const f32 value ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set1_ps( value );
        return Matrix(
            _mm_mul_ps( v0, c ),
            _mm_mul_ps( v1, c ),
            _mm_mul_ps( v2, c ),
            _mm_mul_ps( v3, c ) );
    #else
        return Matrix(
            _11 * value, _12 * value, _13 * value, _14 * value,
            _21 * value, _22 * value, _23 * value, _24 * value,
            _31 * value, _32 * value, _33 * value, _34 * value,
            _41 * value, _42 * value, _43 * value, _44 * value );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      行列式を計算します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 Det() const
    {
        return (
            ( _11 * _22 * _33 * _44 ) + ( _11 * _23 * _34 * _42 ) +
            ( _11 * _24 * _32 * _43 ) + ( _12 * _21 * _34 * _43 ) +
            ( _12 * _23 * _31 * _44 ) + ( _12 * _24 * _33 * _41 ) +
            ( _13 * _21 * _32 * _44 ) + ( _13 * _22 * _34 * _41 ) +
            ( _13 * _24 * _31 * _42 ) + ( _14 * _21 * _33 * _42 ) +
            ( _14 * _22 * _31 * _43 ) + ( _14 * _23 * _32 * _41 ) -
            ( _11 * _22 * _34 * _43 ) - ( _11 * _23 * _32 * _44 ) -
            ( _11 * _24 * _33 * _42 ) - ( _12 * _21 * _33 * _44 ) -
            ( _12 * _23 * _34 * _41 ) - ( _12 * _24 * _31 * _43 ) -
            ( _13 * _21 * _34 * _42 ) - ( _13 * _22 * _31 * _44 ) -
            ( _13 * _24 * _32 * _41 ) - ( _14 * _21 * _32 * _43 ) -
            ( _14 * _22 * _33 * _41 ) - ( _14 * _23 * _31 * _42 )
        );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      逆行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Invert( const Matrix& value )
    {
        Matrix result;
        auto det = value.Det();
        assert( !IsZero(det) );

        result._11 = ( value._22 * value._33 * value._44 ) + ( value._23 * value._34 * value._42 ) + ( value._24 * value._32 * value._43 )
                   - ( value._22 * value._34 * value._43 ) - ( value._23 * value._32 * value._44 ) - ( value._24 * value._33 * value._42 ) / det;
        result._12 = ( value._12 * value._34 * value._43 ) + ( value._13 * value._32 * value._44 ) + ( value._14 * value._33 * value._42 )
                   - ( value._12 * value._33 * value._44 ) - ( value._13 * value._34 * value._42 ) - ( value._14 * value._32 * value._43 ) / det;
        result._13 = ( value._12 * value._23 * value._44 ) + ( value._13 * value._24 * value._42 ) + ( value._14 * value._22 * value._43 )
                   - ( value._12 * value._24 * value._43 ) - ( value._13 * value._22 * value._44 ) - ( value._14 * value._23 * value._42 ) / det;
        result._14 = ( value._12 * value._24 * value._33 ) + ( value._13 * value._22 * value._34 ) + ( value._14 * value._23 * value._32 )
                   - ( value._12 * value._23 * value._34 ) - ( value._13 * value._24 * value._32 ) - ( value._14 * value._22 * value._33 ) / det;

        result._21 = ( value._21 * value._34 * value._43 ) + ( value._23 * value._31 * value._44 ) + ( value._24 * value._33 * value._41 )
                   - ( value._21 * value._33 * value._44 ) - ( value._23 * value._34 * value._41 ) - ( value._24 * value._31 * value._43 ) / det;
        result._22 = ( value._11 * value._33 * value._44 ) + ( value._13 * value._34 * value._41 ) + ( value._14 * value._31 * value._43 )
                   - ( value._11 * value._34 * value._43 ) - ( value._13 * value._31 * value._44 ) - ( value._14 * value._33 * value._41 ) / det;
        result._23 = ( value._11 * value._24 * value._43 ) + ( value._13 * value._21 * value._44 ) + ( value._14 * value._23 * value._41 )
                   - ( value._11 * value._23 * value._44 ) - ( value._13 * value._24 * value._41 ) - ( value._14 * value._21 * value._43 ) / det;
        result._24 = ( value._11 * value._23 * value._34 ) + ( value._13 * value._24 * value._31 ) + ( value._14 * value._21 * value._33 )
                   - ( value._11 * value._24 * value._33 ) - ( value._13 * value._21 * value._34 ) - ( value._14 * value._23 * value._31 ) / det;

        result._31 = ( value._21 * value._32 * value._44 ) + ( value._22 * value._34 * value._41 ) + ( value._24 * value._31 * value._42 )
                   - ( value._21 * value._34 * value._42 ) - ( value._22 * value._31 * value._44 ) - ( value._24 * value._32 * value._41 ) / det;
        result._32 = ( value._11 * value._34 * value._42 ) + ( value._12 * value._31 * value._44 ) + ( value._14 * value._32 * value._41 )
                   - ( value._11 * value._32 * value._44 ) - ( value._12 * value._34 * value._41 ) - ( value._14 * value._31 * value._42 ) / det;
        result._33 = ( value._11 * value._22 * value._44 ) + ( value._12 * value._24 * value._41 ) + ( value._14 * value._21 * value._42 )
                   - ( value._11 * value._24 * value._42 ) - ( value._12 * value._21 * value._44 ) - ( value._14 * value._22 * value._41 ) / det;
        result._34 = ( value._11 * value._24 * value._32 ) + ( value._12 * value._21 * value._34 ) + ( value._14 * value._22 * value._31 )
                   - ( value._11 * value._22 * value._34 ) - ( value._12 * value._24 * value._31 ) - ( value._14 * value._21 * value._32 ) / det;

        result._41 = ( value._21 * value._33 * value._42 ) + ( value._22 * value._31 * value._43 ) + ( value._23 * value._32 * value._41 )
                   - ( value._21 * value._32 * value._43 ) - ( value._22 * value._33 * value._41 ) - ( value._23 * value._31 * value._42 ) / det;
        result._42 = ( value._11 * value._32 * value._43 ) + ( value._12 * value._33 * value._41 ) + ( value._13 * value._31 * value._42 )
                   - ( value._11 * value._33 * value._42 ) - ( value._12 * value._31 * value._43 ) - ( value._13 * value._32 * value._41 ) / det;
        result._43 = ( value._11 * value._23 * value._42 ) + ( value._12 * value._21 * value._43 ) + ( value._13 * value._22 * value._41 )
                   - ( value._11 * value._22 * value._43 ) - ( value._12 * value._23 * value._41 ) - ( value._13 * value._21 * value._42 ) / det;
        result._44 = ( value._11 * value._22 * value._33 ) + ( value._12 * value._23 * value._31 ) + ( value._13 * value._21 * value._32 )
                   - ( value._11 * value._23 * value._32 ) - ( value._12 * value._21 * value._33 ) - ( value._13 * value._22 * value._31 ) / det;

        return result;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      転置行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Transpose ( const Matrix& value )
    {
        return Matrix(
            value._11, value._21, value._31, value._41,
            value._12, value._22, value._32, value._42,
            value._13, value._23, value._33, value._43,
            value._14, value._24, value._34, value._44 );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位行列を返却します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Identity()
    {
        return Matrix(
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      平行移動行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Translate( const f32 x, const f32 y, const f32 z )
    {
        return Matrix(
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            x,    y,    z,    1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      拡大縮小行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Scale( const f32 x, const f32 y, const f32 z )
    {
        return Matrix(
            x,    0.0f, 0.0f, 0.0f,
            0.0f, y,    0.0f, 0.0f,
            0.0f, 0.0f, z,    0.0f,
            0.0f, 0.0f, 0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      X軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateX( const f32 rad )
    {
        auto cosRad = cosf( rad );
        auto sinRad = sinf( rad );
        return Matrix(
            1.0f,    0.0f,   0.0f, 0.0f,
            0.0f,  cosRad, sinRad, 0.0f,
            0.0f, -sinRad, cosRad, 0.0f,
            0.0f,    0.0f,   0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateY( const f32 rad )
    {
        auto cosRad = cosf( rad );
        auto sinRad = sinf( rad );
        return Matrix(
            cosRad,  0.0f, -sinRad, 0.0f,
            0.0f,    1.0f,    0.0f, 0.0f,
            sinRad,  0.0f,  cosRad, 0.0f,
            0.0f,    0.0f,    0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateZ( const f32 rad )
    {
        auto cosRad = cosf( rad );
        auto sinRad = sinf( rad );
        return Matrix(
            cosRad, sinRad, 0.0f, 0.0f,
            sinRad, cosRad, 0.0f, 0.0f,
            0.0f,     0.0f, 1.0f, 0.0f,
            0.0f,     0.0f, 0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      任意軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Rotate( const f32 x, const f32 y, const f32 z, const f32 rad )
    {
        Matrix result;

        auto sinRad = sinf(rad);
        auto cosRad = cosf(rad);
        auto a = 1.0f -cosRad;
    
        auto ab = x * y * a;
        auto bc = y * z * a;
        auto ca = z * x * a;
        auto tx = x * x;
        auto ty = y * y;
        auto tz = z * z;

        result._11 = tx + cosRad * (1.0f - tx);
        result._12 = ab + z * sinRad;
        result._13 = ca - y * sinRad;
        result._14 = 0.0f;

        result._21 = ab - z * sinRad;
        result._22 = ty + cosRad * (1.0f - ty);
        result._23 = bc + x * sinRad;
        result._24 = 0.0f;

        result._31 = ca + y * sinRad;
        result._32 = bc - x * sinRad;
        result._33 = tz + cosRad * (1.0f - tz);
        result._34 = 0.0f;

        result._41 = 0.0f;
        result._42 = 0.0f;
        result._43 = 0.0f;
        result._44 = 1.0f;

        return result;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      ビュー行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix LookAt( const Vector3& position, const Vector3& target, const Vector3& upward )
    {
        auto zaxis = Vector3::UnitVector( target - position );
        auto xaxis = Vector3::UnitVector( Vector3::Cross( upward, zaxis ) );
        auto yaxis = Vector3::UnitVector( Vector3::Cross( zaxis, xaxis ) );

        return Matrix(
            xaxis.x, yaxis.x, zaxis.x, 0.0f,
            xaxis.y, yaxis.y, zaxis.y, 0.0f,
            xaxis.z, yaxis.z, zaxis.z, 0.0f,

            -Vector3::Dot( xaxis, position ),
            -Vector3::Dot( yaxis, position ),
            -Vector3::Dot( zaxis, position ),
            1.0 );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      透視投影行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix PersFov( const f32 fieldOfView, const f32 aspectRatio, const f32 nearClip, const f32 farClip )
    {
        auto diff = farClip - nearClip;
        auto yScale = 1.0f / tanf( fieldOfView * 0.5f );
        auto xScale = yScale / aspectRatio;

        Matrix result;
        result._11 = xScale;
        result._12 = 0.0f;
        result._13 = 0.0f;
        result._14 = 0.0f;

        result._21 = 0.0f;
        result._22 = yScale;
        result._23 = 0.0f;
        result._24 = 0.0f;

        result._31 = 0.0f;
        result._32 = 0.0f;
        result._33 = farClip / diff;
        result._34 = -1.0f;

        result._41 = 0.0f;
        result._42 = 0.0f;
        result._43 = - (nearClip * farClip) / diff;
        result._44 = 0.0f;

        return result;
    }
};

S3D_INLINE
Vector2 Vector2::Transform( const Vector2& position, const Matrix& matrix )
{
    return Vector2(
        ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + matrix._41,
        ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + matrix._42
    );
}

S3D_INLINE
Vector2 Vector2::TransformNormal( const Vector2& normal, const Matrix& matrix )
{
    return Vector2(
        ( normal.x * matrix._11 ) + ( normal.y * matrix._21 ),
        ( normal.x * matrix._12 ) + ( normal.y * matrix._22 ) );
}

S3D_INLINE
Vector2 Vector2::TransformCoord( const Vector2& coord, const Matrix& matrix )
{
    auto X = ( coord.x * matrix._11 ) + ( coord.y * matrix._21 ) + matrix._41;
    auto Y = ( coord.x * matrix._12 ) + ( coord.y * matrix._22 ) + matrix._42;
    register f32 W = ( coord.x * matrix._14 ) + ( coord.y * matrix._24 ) + matrix._44;
    assert( !IsZero( W ) );
    return Vector2(
        X / W,
        Y / W
    );
}

S3D_INLINE
Vector3 Vector3::Transform( const Vector3& position, const Matrix& matrix )
{
    return Vector3(
        ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + ( position.z * matrix._31 ) + matrix._41,
        ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + ( position.z * matrix._32 ) + matrix._42,
        ( position.x * matrix._13 ) + ( position.y * matrix._23 ) + ( position.z * matrix._33 ) + matrix._43
    );
}

S3D_INLINE
Vector3 Vector3::TransformNormal( const Vector3& normal, const Matrix& matrix )
{
    return Vector3(
        ( normal.x * matrix._11 ) + ( normal.y * matrix._21 ) + ( normal.z * matrix._31 ),
        ( normal.x * matrix._12 ) + ( normal.y * matrix._22 ) + ( normal.z * matrix._32 ),
        ( normal.x * matrix._13 ) + ( normal.y * matrix._23 ) + ( normal.z * matrix._33 )
    );
}

S3D_INLINE
Vector3 Vector3::TransformCoord( const Vector3& coord, const Matrix& matrix )
{
    auto X = ( coord.x * matrix._11 ) + ( coord.y * matrix._21 ) + ( coord.z * matrix._31 ) + matrix._41;
    auto Y = ( coord.x * matrix._12 ) + ( coord.y * matrix._22 ) + ( coord.z * matrix._32 ) + matrix._42;
    auto Z = ( coord.x * matrix._13 ) + ( coord.y * matrix._23 ) + ( coord.z * matrix._33 ) + matrix._43;
    auto W = ( coord.x * matrix._14 ) + ( coord.y * matrix._24 ) + ( coord.z * matrix._34 ) + matrix._44;
    assert( !IsZero( W ) );
    return Vector3(
        X / W,
        Y / W,
        Z / W
    );
}

S3D_INLINE
Vector4 Vector4::Transform( const Vector4& position, const Matrix& matrix )
{
#if S3D_IS_SIMD
    return Vector4(
        Vector4::Dot( position.v, matrix.v0 ),
        Vector4::Dot( position.v, matrix.v1 ),
        Vector4::Dot( position.v, matrix.v2 ),
        Vector4::Dot( position.v, matrix.v3 ) );
#else
    return Vector4(
        ( position.x * matrix._11 ) + ( position.y * matrix._21 ) + ( position.z * matrix._31 ) + ( position.w * matrix._41 ),
        ( position.x * matrix._12 ) + ( position.y * matrix._22 ) + ( position.z * matrix._32 ) + ( position.w * matrix._42 ),
        ( position.x * matrix._13 ) + ( position.y * matrix._23 ) + ( position.z * matrix._33 ) + ( position.w * matrix._43 ),
        ( position.x * matrix._14 ) + ( position.y * matrix._24 ) + ( position.z * matrix._34 ) + ( position.w * matrix._44 )
    );
#endif
}


/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox structure
/////////////////////////////////////////////////////////////////////////////////////
struct BoundingBox
{
public:
    Vector3 mini;        //!< 最小値です.
    Vector3 maxi;        //!< 最大値です.
    Vector3 center;      //!< 中心座標です.
    bool    empty;       //!< 空かどうか?

    //-------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox()
    : mini(  F_MAX,  F_MAX,  F_MAX )
    , maxi( -F_MAX, -F_MAX, -F_MAX )
    , center( 0.0f, 0.0f, 0.0f )
    , empty ( true )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const Vector3& value )
    : mini  ( value )
    , maxi  ( value )
    , center( value )
    , empty ( false )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const Vector3& _mini, const Vector3& _maxi )
    : mini  ( _mini )
    , maxi  ( _maxi )
    , center( ( _mini + _maxi ) * 0.5f )
    , empty ( false )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const BoundingBox& value )
    : mini  ( value.mini )
    , maxi  ( value.maxi )
    , center( value.center )
    , empty ( value.empty )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    bool IsHit( const Ray& ray ) const
    {
        if ( empty )
        { return false; }

        const Vector3* v[ 2 ] = { &mini, &maxi };
        auto tmin = -F_HIT_MAX;
        auto tmax =  F_HIT_MAX;

        for( auto i=0; i<3; ++i )
        {
            auto idx0 = ray.sign[i];
            auto idx1 = 1 - idx0;

            auto t0 = ( v[idx0]->a[i] - ray.pos.a[i] ) * ray.invDir.a[i];
            auto t1 = ( v[idx1]->a[i] - ray.pos.a[i] ) * ray.invDir.a[i];

            if ( t0 > tmin )   { tmin = t0; }
            if ( t1 < tmax )   { tmax = t1; }
            if ( tmin > tmax ) { return false; }
        }

        return true;
    }


    //-------------------------------------------------------------------------------
    //! @brief      2つのバウンディングボックスをマージします.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Merge( const BoundingBox& a, const BoundingBox& b )
    {
        if ( !a.empty && !b.empty )
        {
            auto mini = Vector3::Min( a.mini, b.mini );
            auto maxi = Vector3::Max( a.maxi, b.maxi );

            return BoundingBox( mini, maxi );
        }
        else if ( a.empty && !b.empty )
        { return b; }
        else if ( !a.empty && b.empty )
        { return a; }

        return a;
    }

    //-------------------------------------------------------------------------------
    //! @brief      バウンディングボックスと点をマージします.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Merge( const BoundingBox& box, const Vector3& p )
    {
        if ( !box.empty )
        {
            auto mini = Vector3::Min( box.mini, p );
            auto maxi = Vector3::Max( box.maxi, p );

            return BoundingBox( mini, maxi );
        }
        return BoundingBox( p );
    }

    S3D_INLINE
    static BoundingBox Transform( const BoundingBox& box, const Matrix& matrix )
    {
        auto mini = Vector3::Transform( box.mini, matrix );
        auto maxi = Vector3::Transform( box.maxi, matrix );
        return BoundingBox( mini, maxi );
    }
};


/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox4 structure
/////////////////////////////////////////////////////////////////////////////////////
S3D_ALIGN(16)
struct BoundingBox4
{
public:
    b128 value[2][3];       // 最大・最小値です( 0:min, 1:max ).

    //--------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4()
    {
    #if S3D_IS_SIMD
        for( auto i=0; i<3; ++i )
        {
            value[0][i] = _mm_set1_ps( F_MAX );
            value[1][i] = _mm_set1_ps( F_MIN );
        }
    #else
        for( auto i=0; i<3; ++i )
        {
            for( auto j=0; j<4; ++j )
            {
                value[0][i].m128_f32[j] = F_MAX;
                value[1][i].m128_f32[j] = F_MIN;
            }
        }
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4
    (
        const BoundingBox& box0,
        const BoundingBox& box1,
        const BoundingBox& box2,
        const BoundingBox& box3
    )
    {
    #if S3D_IS_SIMD
        value[0][0] = _mm_set_ps( box3.mini.x, box2.mini.x, box1.mini.x, box0.mini.x );
        value[0][1] = _mm_set_ps( box3.mini.y, box2.mini.y, box1.mini.y, box0.mini.y );
        value[0][2] = _mm_set_ps( box3.mini.z, box2.mini.z, box1.mini.z, box0.mini.z );

        value[1][0] = _mm_set_ps( box3.maxi.x, box2.maxi.x, box1.maxi.x, box0.maxi.x );
        value[1][1] = _mm_set_ps( box3.maxi.y, box2.maxi.y, box1.maxi.y, box0.maxi.y );
        value[1][2] = _mm_set_ps( box3.maxi.z, box2.maxi.z, box1.maxi.z, box0.maxi.z );
    #else
        value[0][0].m128_f32[0] = box0.mini.x;
        value[0][0].m128_f32[1] = box1.mini.x;
        value[0][0].m128_f32[2] = box2.mini.x;
        value[0][0].m128_f32[3] = box3.mini.x;

        value[0][1].m128_f32[0] = box0.mini.y;
        value[0][1].m128_f32[1] = box1.mini.y;
        value[0][1].m128_f32[2] = box2.mini.y;
        value[0][1].m128_f32[3] = box3.mini.y;

        value[0][2].m128_f32[0] = box0.mini.z;
        value[0][2].m128_f32[1] = box1.mini.z;
        value[0][2].m128_f32[2] = box2.mini.z;
        value[0][2].m128_f32[3] = box3.mini.z;


        value[1][0].m128_f32[0] = box0.maxi.x;
        value[1][0].m128_f32[1] = box1.maxi.x;
        value[1][0].m128_f32[2] = box2.maxi.x;
        value[1][0].m128_f32[3] = box3.maxi.x;

        value[1][1].m128_f32[0] = box0.maxi.y;
        value[1][1].m128_f32[1] = box1.maxi.y;
        value[1][1].m128_f32[2] = box2.maxi.y;
        value[1][1].m128_f32[3] = box3.maxi.y;

        value[1][2].m128_f32[0] = box0.maxi.z;
        value[1][2].m128_f32[1] = box1.maxi.z;
        value[1][2].m128_f32[2] = box2.maxi.z;
        value[1][2].m128_f32[3] = box3.maxi.z;
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4( const BoundingBox* box )
    {
    #if S3D_IS_SIMD
        value[0][0] = _mm_set_ps( box[3].mini.x, box[2].mini.x, box[1].mini.x, box[0].mini.x );
        value[0][1] = _mm_set_ps( box[3].mini.y, box[2].mini.y, box[1].mini.y, box[0].mini.y );
        value[0][2] = _mm_set_ps( box[3].mini.z, box[2].mini.z, box[1].mini.z, box[0].mini.z );

        value[1][0] = _mm_set_ps( box[3].maxi.x, box[2].maxi.x, box[1].maxi.x, box[0].maxi.x );
        value[1][1] = _mm_set_ps( box[3].maxi.y, box[2].maxi.y, box[1].maxi.y, box[0].maxi.y );
        value[1][2] = _mm_set_ps( box[3].maxi.z, box[2].maxi.z, box[1].maxi.z, box[0].maxi.z );
    #else
        value[0][0].m128_f32[0] = box[0].mini.x;
        value[0][0].m128_f32[1] = box[1].mini.x;
        value[0][0].m128_f32[2] = box[2].mini.x;
        value[0][0].m128_f32[3] = box[3].mini.x;

        value[0][1].m128_f32[0] = box[0].mini.y;
        value[0][1].m128_f32[1] = box[1].mini.y;
        value[0][1].m128_f32[2] = box[2].mini.y;
        value[0][1].m128_f32[3] = box[3].mini.y;

        value[0][2].m128_f32[0] = box[0].mini.z;
        value[0][2].m128_f32[1] = box[1].mini.z;
        value[0][2].m128_f32[2] = box[2].mini.z;
        value[0][2].m128_f32[3] = box[3].mini.z;


        value[1][0].m128_f32[0] = box[0].maxi.x;
        value[1][0].m128_f32[1] = box[1].maxi.x;
        value[1][0].m128_f32[2] = box[2].maxi.x;
        value[1][0].m128_f32[3] = box[3].maxi.x;

        value[1][1].m128_f32[0] = box[0].maxi.y;
        value[1][1].m128_f32[1] = box[1].maxi.y;
        value[1][1].m128_f32[2] = box[2].maxi.y;
        value[1][1].m128_f32[3] = box[3].maxi.y;

        value[1][2].m128_f32[0] = box[0].maxi.z;
        value[1][2].m128_f32[1] = box[1].maxi.z;
        value[1][2].m128_f32[2] = box[2].maxi.z;
        value[1][2].m128_f32[3] = box[3].maxi.z;
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4
    (
        const b128& miniX,
        const b128& miniY,
        const b128& miniZ,

        const b128& maxiX,
        const b128& maxiY,
        const b128& maxiZ
    )
    {
        value[0][0] = miniX;
        value[0][1] = miniY;
        value[0][2] = miniZ;

        value[1][0] = maxiX;
        value[1][1] = maxiY;
        value[1][2] = maxiZ;
    }

    //--------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    bool IsHit( const Ray4& ray, s32& mask ) const
    {
    #if S3D_IS_SIMD
        b128 tmin = _mm_set1_ps( -F_HIT_MAX );
        b128 tmax = _mm_set1_ps(  F_HIT_MAX );

        s32 idx0, idx1;

        for( auto i=0; i<3; ++i )
        {
            idx0 = ray.sign[ i ];
            idx1 = 1 - idx0;
            tmin = _mm_max_ps( tmin, _mm_mul_ps( _mm_sub_ps( value[ idx0 ][ i ], ray.pos[ i ] ), ray.invDir[ i ] ) );
            tmax = _mm_min_ps( tmax, _mm_mul_ps( _mm_sub_ps( value[ idx1 ][ i ], ray.pos[ i ] ), ray.invDir[ i ] ) );
        }

        mask = _mm_movemask_ps( _mm_cmpge_ps( tmax, tmin ) );
        return ( mask > 0 );
    #else
        b128 tmin;
        b128 tmax;

        for( auto i=0; i<4; ++i)
        {
            tmin.m128_f32[i] = -F_HIT_MAX;
            tmax.m128_f32[i] =  F_HIT_MAX;
        }

        s32 idx0, idx1;
        b128 flg;

        for( u32 j=0; j<3; ++j )
        {
            idx0 = ray.sign[ j ];
            idx1 = 1 - idx0;
            for ( u32 i=0; i<4; ++i )
            {
                auto t0 = ( value[ idx0 ][ j ].m128_f32[ i ] - ray.pos[ j ].m128_f32[ i ] ) * ray.invDir[ j ].m128_f32[ i ];
                auto t1 = ( value[ idx1 ][ j ].m128_f32[ i ] - ray.pos[ j ].m128_f32[ i ] ) * ray.invDir[ j ].m128_f32[ i ];
                tmin.m128_f32[ i ] = s3d::Max( tmin.m128_f32[ i ], t0 );
                tmax.m128_f32[ i ] = s3d::Min( tmax.m128_f32[ i ], t1 );
            }
        }

        for( u32 i=0; i<4; ++i )
        {
            flg.m128_u32[ i ] = ( tmax.m128_f32[ i ] >= tmin.m128_f32[ i ] ) ? 0xffffffff : 0x0;
        }

        mask = ( (flg.m128_u32[3] > 0 ? 0x1 : 0 ) << 3
               | (flg.m128_u32[2] > 0 ? 0x1 : 0 ) << 2
               | (flg.m128_u32[1] > 0 ? 0x1 : 0 ) << 1
               | (flg.m128_u32[0] > 0 ? 0x1 : 0 ) );
        return ( mask > 0 );
    #endif
    }

    //--------------------------------------------------------------------------------
    //! @brief      バウンディングボックスを取得します.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox GetBox() const
    {
        Vector3 tmin( value[0][0].m128_f32[0], value[0][1].m128_f32[0], value[0][2].m128_f32[0] );
        Vector3 tmax( value[1][0].m128_f32[0], value[1][1].m128_f32[0], value[1][2].m128_f32[0] );

        for( u32 i=1; i<4; ++i )
        {
            tmin = Vector3::Min( tmin, Vector3( value[0][0].m128_f32[i], value[0][1].m128_f32[i], value[0][2].m128_f32[i] ) );
            tmax = Vector3::Max( tmax, Vector3( value[1][0].m128_f32[i], value[1][1].m128_f32[i], value[1][2].m128_f32[i] ) );
        }

        return BoundingBox( tmin, tmax );
    }

    //--------------------------------------------------------------------------------
    //! @brief      2つの4バウンディングボックスをマージします.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox4 Merge( const BoundingBox4& a, const BoundingBox4& b )
    {
    #if S3D_IS_SIMD
        b128 miniX = _mm_min_ps( a.value[0][0], b.value[0][0] );
        b128 miniY = _mm_min_ps( a.value[0][1], b.value[0][1] );
        b128 miniZ = _mm_min_ps( a.value[0][2], b.value[0][2] );

        b128 maxiX = _mm_max_ps( a.value[1][0], b.value[1][0] );
        b128 maxiY = _mm_max_ps( a.value[1][1], b.value[1][1] );
        b128 maxiZ = _mm_max_ps( a.value[1][2], b.value[1][2] );

        return BoundingBox4( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
    #else
        b128 miniX = { 
            ( a.value[0][0].m128_f32[0] < b.value[0][0].m128_f32[0] ) ? a.value[0][0].m128_f32[0] : b.value[0][0].m128_f32[0],
            ( a.value[0][0].m128_f32[1] < b.value[0][0].m128_f32[1] ) ? a.value[0][0].m128_f32[1] : b.value[0][0].m128_f32[1],
            ( a.value[0][0].m128_f32[2] < b.value[0][0].m128_f32[2] ) ? a.value[0][0].m128_f32[2] : b.value[0][0].m128_f32[2],
            ( a.value[0][0].m128_f32[3] < b.value[0][0].m128_f32[3] ) ? a.value[0][0].m128_f32[3] : b.value[0][0].m128_f32[3]
        };
        b128 miniY = { 
            ( a.value[0][1].m128_f32[0] < b.value[0][1].m128_f32[0] ) ? a.value[0][1].m128_f32[0] : b.value[0][1].m128_f32[0],
            ( a.value[0][1].m128_f32[1] < b.value[0][1].m128_f32[1] ) ? a.value[0][1].m128_f32[1] : b.value[0][1].m128_f32[1],
            ( a.value[0][1].m128_f32[2] < b.value[0][1].m128_f32[2] ) ? a.value[0][1].m128_f32[2] : b.value[0][1].m128_f32[2],
            ( a.value[0][1].m128_f32[3] < b.value[0][1].m128_f32[3] ) ? a.value[0][1].m128_f32[3] : b.value[0][1].m128_f32[3]
        };
        b128 miniZ = { 
            ( a.value[0][2].m128_f32[0] < b.value[0][2].m128_f32[0] ) ? a.value[0][2].m128_f32[0] : b.value[0][2].m128_f32[0],
            ( a.value[0][2].m128_f32[1] < b.value[0][2].m128_f32[1] ) ? a.value[0][2].m128_f32[1] : b.value[0][2].m128_f32[1],
            ( a.value[0][2].m128_f32[2] < b.value[0][2].m128_f32[2] ) ? a.value[0][2].m128_f32[2] : b.value[0][2].m128_f32[2],
            ( a.value[0][2].m128_f32[3] < b.value[0][2].m128_f32[3] ) ? a.value[0][2].m128_f32[3] : b.value[0][2].m128_f32[3]
        };

        b128 maxiX = { 
            ( a.value[1][0].m128_f32[0] > b.value[1][0].m128_f32[0] ) ? a.value[1][0].m128_f32[0] : b.value[1][0].m128_f32[0],
            ( a.value[1][0].m128_f32[1] > b.value[1][0].m128_f32[1] ) ? a.value[1][0].m128_f32[1] : b.value[1][0].m128_f32[1],
            ( a.value[1][0].m128_f32[2] > b.value[1][0].m128_f32[2] ) ? a.value[1][0].m128_f32[2] : b.value[1][0].m128_f32[2],
            ( a.value[1][0].m128_f32[3] > b.value[1][0].m128_f32[3] ) ? a.value[1][0].m128_f32[3] : b.value[1][0].m128_f32[3]
        };
        b128 maxiY = { 
            ( a.value[1][1].m128_f32[0] > b.value[1][1].m128_f32[0] ) ? a.value[1][1].m128_f32[0] : b.value[1][1].m128_f32[0],
            ( a.value[1][1].m128_f32[1] > b.value[1][1].m128_f32[1] ) ? a.value[1][1].m128_f32[1] : b.value[1][1].m128_f32[1],
            ( a.value[1][1].m128_f32[2] > b.value[1][1].m128_f32[2] ) ? a.value[1][1].m128_f32[2] : b.value[1][1].m128_f32[2],
            ( a.value[1][1].m128_f32[3] > b.value[1][1].m128_f32[3] ) ? a.value[1][1].m128_f32[3] : b.value[1][1].m128_f32[3]
        };
        b128 maxiZ = { 
            ( a.value[1][2].m128_f32[0] > b.value[1][2].m128_f32[0] ) ? a.value[1][2].m128_f32[0] : b.value[1][2].m128_f32[0],
            ( a.value[1][2].m128_f32[1] > b.value[1][2].m128_f32[1] ) ? a.value[1][2].m128_f32[1] : b.value[1][2].m128_f32[1],
            ( a.value[1][2].m128_f32[2] > b.value[1][2].m128_f32[2] ) ? a.value[1][2].m128_f32[2] : b.value[1][2].m128_f32[2],
            ( a.value[1][2].m128_f32[3] > b.value[1][2].m128_f32[3] ) ? a.value[1][2].m128_f32[3] : b.value[1][2].m128_f32[3]
        };

        return BoundingBox4( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
#endif//S3D_IS_SIMD
    }
};


/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox8 structure
/////////////////////////////////////////////////////////////////////////////////////
S3D_ALIGN(32)
struct BoundingBox8
{
public:
    b256 value[2][3];       // 最大・最小値です( 0:min, 1:max ).

    //--------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8()
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        value[0][0] = _mm256_set1_ps( F_MAX );
        value[0][1] = _mm256_set1_ps( F_MAX );
        value[0][2] = _mm256_set1_ps( F_MAX );

        value[1][0] = _mm256_set1_ps( -F_MAX );
        value[1][1] = _mm256_set1_ps( -F_MAX );
        value[1][2] = _mm256_set1_ps( -F_MAX );
    #else
        value[0][0].m256_f32[0] = F_MAX;    // Empty
        value[0][0].m256_f32[1] = F_MAX;    // Empty
        value[0][0].m256_f32[2] = F_MAX;    // Empty
        value[0][0].m256_f32[3] = F_MAX;    // Empty
        value[0][0].m256_f32[4] = F_MAX;    // Empty
        value[0][0].m256_f32[5] = F_MAX;    // Empty
        value[0][0].m256_f32[6] = F_MAX;    // Empty
        value[0][0].m256_f32[7] = F_MAX;    // Empty

        value[0][1].m256_f32[0] = F_MAX;    // Empty
        value[0][1].m256_f32[1] = F_MAX;    // Empty
        value[0][1].m256_f32[2] = F_MAX;    // Empty
        value[0][1].m256_f32[3] = F_MAX;    // Empty
        value[0][1].m256_f32[4] = F_MAX;    // Empty
        value[0][1].m256_f32[5] = F_MAX;    // Empty
        value[0][1].m256_f32[6] = F_MAX;    // Empty
        value[0][1].m256_f32[7] = F_MAX;    // Empty

        value[0][2].m256_f32[0] = F_MAX;    // Empty
        value[0][2].m256_f32[1] = F_MAX;    // Empty
        value[0][2].m256_f32[2] = F_MAX;    // Empty
        value[0][2].m256_f32[3] = F_MAX;    // Empty
        value[0][2].m256_f32[4] = F_MAX;    // Empty
        value[0][2].m256_f32[5] = F_MAX;    // Empty
        value[0][2].m256_f32[6] = F_MAX;    // Empty
        value[0][2].m256_f32[7] = F_MAX;    // Empty

        value[1][0].m256_f32[0] = -F_MAX;    // Empty
        value[1][0].m256_f32[1] = -F_MAX;    // Empty
        value[1][0].m256_f32[2] = -F_MAX;    // Empty
        value[1][0].m256_f32[3] = -F_MAX;    // Empty
        value[1][0].m256_f32[4] = -F_MAX;    // Empty
        value[1][0].m256_f32[5] = -F_MAX;    // Empty
        value[1][0].m256_f32[6] = -F_MAX;    // Empty
        value[1][0].m256_f32[7] = -F_MAX;    // Empty

        value[1][1].m256_f32[0] = -F_MAX;    // Empty
        value[1][1].m256_f32[1] = -F_MAX;    // Empty
        value[1][1].m256_f32[2] = -F_MAX;    // Empty
        value[1][1].m256_f32[3] = -F_MAX;    // Empty
        value[1][1].m256_f32[4] = -F_MAX;    // Empty
        value[1][1].m256_f32[5] = -F_MAX;    // Empty
        value[1][1].m256_f32[6] = -F_MAX;    // Empty
        value[1][1].m256_f32[7] = -F_MAX;    // Empty

        value[1][2].m256_f32[0] = -F_MAX;    // Empty
        value[1][2].m256_f32[1] = -F_MAX;    // Empty
        value[1][2].m256_f32[2] = -F_MAX;    // Empty
        value[1][2].m256_f32[3] = -F_MAX;    // Empty
        value[1][2].m256_f32[4] = -F_MAX;    // Empty
        value[1][2].m256_f32[5] = -F_MAX;    // Empty
        value[1][2].m256_f32[6] = -F_MAX;    // Empty
        value[1][2].m256_f32[7] = -F_MAX;    // Empty
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //----------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8
    (
        const BoundingBox& box0,
        const BoundingBox& box1,
        const BoundingBox& box2,
        const BoundingBox& box3,
        const BoundingBox& box4,
        const BoundingBox& box5,
        const BoundingBox& box6,
        const BoundingBox& box7
    )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        value[0][0] = _mm256_set_ps( box7.mini.x, box6.mini.x, box5.mini.x, box4.mini.x, box3.mini.x, box2.mini.x, box1.mini.x, box0.mini.x );
        value[0][1] = _mm256_set_ps( box7.mini.y, box6.mini.y, box5.mini.y, box4.mini.y, box3.mini.y, box2.mini.y, box1.mini.y, box0.mini.y );
        value[0][2] = _mm256_set_ps( box7.mini.z, box6.mini.z, box5.mini.z, box4.mini.z, box3.mini.z, box2.mini.z, box1.mini.z, box0.mini.z );

        value[1][0] = _mm256_set_ps( box7.maxi.x, box6.maxi.x, box5.maxi.x, box4.maxi.x, box3.maxi.x, box2.maxi.x, box1.maxi.x, box0.maxi.x );
        value[1][1] = _mm256_set_ps( box7.maxi.y, box6.maxi.y, box5.maxi.y, box4.maxi.y, box3.maxi.y, box2.maxi.y, box1.maxi.y, box0.maxi.y );
        value[1][2] = _mm256_set_ps( box7.maxi.z, box6.maxi.z, box5.maxi.z, box4.maxi.z, box3.maxi.z, box2.maxi.z, box1.maxi.z, box0.maxi.z );
    #else
        value[0][0].m256_f32[0] = box0.mini.x;
        value[0][0].m256_f32[1] = box1.mini.x;
        value[0][0].m256_f32[2] = box2.mini.x;
        value[0][0].m256_f32[3] = box3.mini.x;
        value[0][0].m256_f32[4] = box4.mini.x;
        value[0][0].m256_f32[5] = box5.mini.x;
        value[0][0].m256_f32[6] = box6.mini.x;
        value[0][0].m256_f32[7] = box7.mini.x;

        value[0][1].m256_f32[0] = box0.mini.y;
        value[0][1].m256_f32[1] = box1.mini.y;
        value[0][1].m256_f32[2] = box2.mini.y;
        value[0][1].m256_f32[3] = box3.mini.y;
        value[0][1].m256_f32[4] = box4.mini.y;
        value[0][1].m256_f32[5] = box5.mini.y;
        value[0][1].m256_f32[6] = box6.mini.y;
        value[0][1].m256_f32[7] = box7.mini.y;

        value[0][2].m256_f32[0] = box0.mini.z;
        value[0][2].m256_f32[1] = box1.mini.z;
        value[0][2].m256_f32[2] = box2.mini.z;
        value[0][2].m256_f32[3] = box3.mini.z;
        value[0][2].m256_f32[4] = box4.mini.z;
        value[0][2].m256_f32[5] = box5.mini.z;
        value[0][2].m256_f32[6] = box6.mini.z;
        value[0][2].m256_f32[7] = box7.mini.z;

        value[1][0].m256_f32[0] = box0.maxi.x;
        value[1][0].m256_f32[1] = box1.maxi.x;
        value[1][0].m256_f32[2] = box2.maxi.x;
        value[1][0].m256_f32[3] = box3.maxi.x;
        value[1][0].m256_f32[4] = box4.maxi.x;
        value[1][0].m256_f32[5] = box5.maxi.x;
        value[1][0].m256_f32[6] = box6.maxi.x; 
        value[1][0].m256_f32[7] = box7.maxi.x;

        value[1][1].m256_f32[0] = box0.maxi.y;
        value[1][1].m256_f32[1] = box1.maxi.y;
        value[1][1].m256_f32[2] = box2.maxi.y;
        value[1][1].m256_f32[3] = box3.maxi.y;
        value[1][1].m256_f32[4] = box4.maxi.y;
        value[1][1].m256_f32[5] = box5.maxi.y;
        value[1][1].m256_f32[6] = box6.maxi.y;
        value[1][1].m256_f32[7] = box7.maxi.y;

        value[1][2].m256_f32[0] = box0.maxi.z;
        value[1][2].m256_f32[1] = box1.maxi.z;
        value[1][2].m256_f32[2] = box2.maxi.z;
        value[1][2].m256_f32[3] = box3.maxi.z;
        value[1][2].m256_f32[4] = box4.maxi.z;
        value[1][2].m256_f32[5] = box5.maxi.z;
        value[1][2].m256_f32[6] = box6.maxi.z;
        value[1][2].m256_f32[7] = box7.maxi.z;
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8( const BoundingBox* box )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        value[0][0] = _mm256_set_ps( box[7].mini.x, box[6].mini.x, box[5].mini.x, box[4].mini.x, box[3].mini.x, box[2].mini.x, box[1].mini.x, box[0].mini.x );
        value[0][1] = _mm256_set_ps( box[7].mini.y, box[6].mini.y, box[5].mini.y, box[4].mini.y, box[3].mini.y, box[2].mini.y, box[1].mini.y, box[0].mini.y );
        value[0][2] = _mm256_set_ps( box[7].mini.z, box[6].mini.z, box[5].mini.z, box[4].mini.z, box[3].mini.z, box[2].mini.z, box[1].mini.z, box[0].mini.z );

        value[1][0] = _mm256_set_ps( box[7].maxi.x, box[6].maxi.x, box[5].maxi.x, box[4].maxi.x, box[3].maxi.x, box[2].maxi.x, box[1].maxi.x, box[0].maxi.x );
        value[1][1] = _mm256_set_ps( box[7].maxi.y, box[6].maxi.y, box[5].maxi.y, box[4].maxi.y, box[3].maxi.y, box[2].maxi.y, box[1].maxi.y, box[0].maxi.y );
        value[1][2] = _mm256_set_ps( box[7].maxi.z, box[6].maxi.z, box[5].maxi.z, box[4].maxi.z, box[3].maxi.z, box[2].maxi.z, box[1].maxi.z, box[0].maxi.z );
    #else
        value[0][0].m256_f32[0] = box[0].mini.x;
        value[0][0].m256_f32[1] = box[1].mini.x;
        value[0][0].m256_f32[2] = box[2].mini.x;
        value[0][0].m256_f32[3] = box[3].mini.x;
        value[0][0].m256_f32[4] = box[4].mini.x;
        value[0][0].m256_f32[5] = box[5].mini.x;
        value[0][0].m256_f32[6] = box[6].mini.x;
        value[0][0].m256_f32[7] = box[7].mini.x;

        value[0][1].m256_f32[0] = box[0].mini.y;
        value[0][1].m256_f32[1] = box[1].mini.y;
        value[0][1].m256_f32[2] = box[2].mini.y;
        value[0][1].m256_f32[3] = box[3].mini.y;
        value[0][1].m256_f32[4] = box[4].mini.y;
        value[0][1].m256_f32[5] = box[5].mini.y;
        value[0][1].m256_f32[6] = box[6].mini.y;
        value[0][1].m256_f32[7] = box[7].mini.y;

        value[0][2].m256_f32[0] = box[0].mini.z;
        value[0][2].m256_f32[1] = box[1].mini.z;
        value[0][2].m256_f32[2] = box[2].mini.z;
        value[0][2].m256_f32[3] = box[3].mini.z;
        value[0][2].m256_f32[4] = box[4].mini.z;
        value[0][2].m256_f32[5] = box[5].mini.z;
        value[0][2].m256_f32[6] = box[6].mini.z;
        value[0][2].m256_f32[7] = box[7].mini.z;

        value[1][0].m256_f32[0] = box[0].maxi.x;
        value[1][0].m256_f32[1] = box[1].maxi.x;
        value[1][0].m256_f32[2] = box[2].maxi.x;
        value[1][0].m256_f32[3] = box[3].maxi.x;
        value[1][0].m256_f32[4] = box[4].maxi.x;
        value[1][0].m256_f32[5] = box[5].maxi.x;
        value[1][0].m256_f32[6] = box[6].maxi.x; 
        value[1][0].m256_f32[7] = box[7].maxi.x;

        value[1][1].m256_f32[0] = box[0].maxi.y;
        value[1][1].m256_f32[1] = box[1].maxi.y;
        value[1][1].m256_f32[2] = box[2].maxi.y;
        value[1][1].m256_f32[3] = box[3].maxi.y;
        value[1][1].m256_f32[4] = box[4].maxi.y;
        value[1][1].m256_f32[5] = box[5].maxi.y;
        value[1][1].m256_f32[6] = box[6].maxi.y;
        value[1][1].m256_f32[7] = box[7].maxi.y;

        value[1][2].m256_f32[0] = box[0].maxi.z;
        value[1][2].m256_f32[1] = box[1].maxi.z;
        value[1][2].m256_f32[2] = box[2].maxi.z;
        value[1][2].m256_f32[3] = box[3].maxi.z;
        value[1][2].m256_f32[4] = box[4].maxi.z;
        value[1][2].m256_f32[5] = box[5].maxi.z;
        value[1][2].m256_f32[6] = box[6].maxi.z;
        value[1][2].m256_f32[7] = box[7].maxi.z;
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8
    (
        const b256& miniX,
        const b256& miniY,
        const b256& miniZ,

        const b256& maxiX,
        const b256& maxiY,
        const b256& maxiZ
    )
    {
        value[0][0] = miniX;
        value[0][1] = miniY;
        value[0][2] = miniZ;

        value[1][0] = maxiX;
        value[1][1] = maxiY;
        value[1][2] = maxiZ;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //---------------------------------------------------------------------------------------------
    bool IsHit( const Ray8& ray, s32& mask ) const
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        b256 tmin = _mm256_set1_ps( -F_HIT_MAX );
        b256 tmax = _mm256_set1_ps(  F_HIT_MAX );

        s32 idx0, idx1;

        for( auto i=0; i<3; ++i )
        {
            idx0 = ray.sign[ i ];
            idx1 = 1 - idx0;
            tmin = _mm256_max_ps( tmin, _mm256_mul_ps( _mm256_sub_ps( value[ idx0 ][ i ], ray.pos[ i ] ), ray.invDir[ i ] ) );
            tmax = _mm256_min_ps( tmax, _mm256_mul_ps( _mm256_sub_ps( value[ idx1 ][ i ], ray.pos[ i ] ), ray.invDir[ i ] ) );
        }

        mask = _mm256_movemask_ps( _mm256_cmp_ps( tmax, tmin, _CMP_GE_OS ) );
        return ( mask > 0 );
    #else
        b256 tmin = { F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN };
        b256 tmax = { F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX };

        s32 idx0, idx1;

        // X軸
        idx0 = ray.sign[ 0 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<8; ++i )
        {
            tmin.m256_f32[ i ] = s3d::Max( tmin.m256_f32[ i ], ( value[ idx0 ][ 0 ].m256_f32[ i ] - ray.pos[ 0 ].m256_f32[ i ] ) * ray.invDir[ 0 ].m256_f32[ i ] );
            tmax.m256_f32[ i ] = s3d::Min( tmax.m256_f32[ i ], ( value[ idx1 ][ 0 ].m256_f32[ i ] - ray.pos[ 0 ].m256_f32[ i ] ) * ray.invDir[ 0 ].m256_f32[ i ] );
        }

        // Y軸
        idx0 = ray.sign[ 1 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<8; ++i )
        {
            tmin.m256_f32[ i ] = s3d::Max( tmin.m256_f32[ i ], ( value[ idx0 ][ 1 ].m256_f32[ i ] - ray.pos[ 1 ].m256_f32[ i ] ) * ray.invDir[ 1 ].m256_f32[ i ] );
            tmax.m256_f32[ i ] = s3d::Min( tmax.m256_f32[ i ], ( value[ idx1 ][ 1 ].m256_f32[ i ] - ray.pos[ 1 ].m256_f32[ i ] ) * ray.invDir[ 1 ].m256_f32[ i ] );
        }

        // Z軸
        idx0 = ray.sign[ 2 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<8; ++i )
        {
            tmin.m256_f32[ i ] = s3d::Max( tmin.m256_f32[ i ], ( value[ idx0 ][ 2 ].m256_f32[ i ] - ray.pos[ 2 ].m256_f32[ i ] ) * ray.invDir[ 2 ].m256_f32[ i ] );
            tmax.m256_f32[ i ] = s3d::Min( tmax.m256_f32[ i ], ( value[ idx1 ][ 2 ].m256_f32[ i ] - ray.pos[ 2 ].m256_f32[ i ] ) * ray.invDir[ 2 ].m256_f32[ i ] );
        }

        b256i flg;
        flg.m256i_u32[0] = ( tmax.m256_f32[ 0 ] >= tmin.m256_f32[ 0 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[1] = ( tmax.m256_f32[ 1 ] >= tmin.m256_f32[ 1 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[2] = ( tmax.m256_f32[ 2 ] >= tmin.m256_f32[ 2 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[3] = ( tmax.m256_f32[ 3 ] >= tmin.m256_f32[ 3 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[4] = ( tmax.m256_f32[ 4 ] >= tmin.m256_f32[ 4 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[5] = ( tmax.m256_f32[ 5 ] >= tmin.m256_f32[ 5 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[6] = ( tmax.m256_f32[ 6 ] >= tmin.m256_f32[ 6 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[7] = ( tmax.m256_f32[ 7 ] >= tmin.m256_f32[ 7 ] ) ? 0xffffffff : 0x0;

        mask = (
              ( (flg.m256i_u32[7] > 0 ? 1 : 0 ) << 7 )
            | ( (flg.m256i_u32[6] > 0 ? 1 : 0 ) << 6 )
            | ( (flg.m256i_u32[5] > 0 ? 1 : 0 ) << 5 )
            | ( (flg.m256i_u32[4] > 0 ? 1 : 0 ) << 4 )
            | ( (flg.m256i_u32[3] > 0 ? 1 : 0 ) << 3 )
            | ( (flg.m256i_u32[2] > 0 ? 1 : 0 ) << 2 )
            | ( (flg.m256i_u32[1] > 0 ? 1 : 0 ) << 1 )
            | ( (flg.m256i_u32[0] > 0 ? 1 : 0 ) ) );

        return ( mask > 0 );
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      バウンディングボックスを取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox GetBox() const
    {
        Vector3 tmin( value[0][0].m256_f32[0], value[0][1].m256_f32[0], value[0][2].m256_f32[0] );
        Vector3 tmax( value[1][0].m256_f32[0], value[1][1].m256_f32[0], value[1][2].m256_f32[0] );

        for( u32 i=1; i<8; ++i )
        {
            tmin = Vector3::Min( tmin, Vector3( value[0][0].m256_f32[i], value[0][1].m256_f32[i], value[0][2].m256_f32[i] ) );
            tmax = Vector3::Max( tmax, Vector3( value[1][0].m256_f32[i], value[1][1].m256_f32[i], value[1][2].m256_f32[i] ) );
        }

        return BoundingBox( tmin, tmax );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      2つの4バウンディングボックスをマージします.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox8 Merge( const BoundingBox8& a, const BoundingBox8& b )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        b256 miniX = _mm256_min_ps( a.value[0][0], b.value[0][0] );
        b256 miniY = _mm256_min_ps( a.value[0][1], b.value[0][1] );
        b256 miniZ = _mm256_min_ps( a.value[0][2], b.value[0][2] );

        b256 maxiX = _mm256_max_ps( a.value[1][0], b.value[1][0] );
        b256 maxiY = _mm256_max_ps( a.value[1][1], b.value[1][1] );
        b256 maxiZ = _mm256_max_ps( a.value[1][2], b.value[1][2] );

        return BoundingBox8( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
    #else
        b256 miniX = { 
            ( a.value[0][0].m256_f32[0] < b.value[0][0].m256_f32[0] ) ? a.value[0][0].m256_f32[0] : b.value[0][0].m256_f32[0],
            ( a.value[0][0].m256_f32[1] < b.value[0][0].m256_f32[1] ) ? a.value[0][0].m256_f32[1] : b.value[0][0].m256_f32[1],
            ( a.value[0][0].m256_f32[2] < b.value[0][0].m256_f32[2] ) ? a.value[0][0].m256_f32[2] : b.value[0][0].m256_f32[2],
            ( a.value[0][0].m256_f32[3] < b.value[0][0].m256_f32[3] ) ? a.value[0][0].m256_f32[3] : b.value[0][0].m256_f32[3],
            ( a.value[0][0].m256_f32[4] < b.value[0][0].m256_f32[4] ) ? a.value[0][0].m256_f32[4] : b.value[0][0].m256_f32[4],
            ( a.value[0][0].m256_f32[5] < b.value[0][0].m256_f32[5] ) ? a.value[0][0].m256_f32[5] : b.value[0][0].m256_f32[5],
            ( a.value[0][0].m256_f32[6] < b.value[0][0].m256_f32[6] ) ? a.value[0][0].m256_f32[6] : b.value[0][0].m256_f32[6],
            ( a.value[0][0].m256_f32[7] < b.value[0][0].m256_f32[7] ) ? a.value[0][0].m256_f32[7] : b.value[0][0].m256_f32[7]
        };
        b256 miniY = { 
            ( a.value[0][1].m256_f32[0] < b.value[0][1].m256_f32[0] ) ? a.value[0][1].m256_f32[0] : b.value[0][1].m256_f32[0],
            ( a.value[0][1].m256_f32[1] < b.value[0][1].m256_f32[1] ) ? a.value[0][1].m256_f32[1] : b.value[0][1].m256_f32[1],
            ( a.value[0][1].m256_f32[2] < b.value[0][1].m256_f32[2] ) ? a.value[0][1].m256_f32[2] : b.value[0][1].m256_f32[2],
            ( a.value[0][1].m256_f32[3] < b.value[0][1].m256_f32[3] ) ? a.value[0][1].m256_f32[3] : b.value[0][1].m256_f32[3],
            ( a.value[0][1].m256_f32[4] < b.value[0][1].m256_f32[4] ) ? a.value[0][1].m256_f32[4] : b.value[0][1].m256_f32[4],
            ( a.value[0][1].m256_f32[5] < b.value[0][1].m256_f32[5] ) ? a.value[0][1].m256_f32[5] : b.value[0][1].m256_f32[5],
            ( a.value[0][1].m256_f32[6] < b.value[0][1].m256_f32[6] ) ? a.value[0][1].m256_f32[6] : b.value[0][1].m256_f32[6],
            ( a.value[0][1].m256_f32[7] < b.value[0][1].m256_f32[7] ) ? a.value[0][1].m256_f32[7] : b.value[0][1].m256_f32[7]
        };
        b256 miniZ = { 
            ( a.value[0][2].m256_f32[0] < b.value[0][2].m256_f32[0] ) ? a.value[0][2].m256_f32[0] : b.value[0][2].m256_f32[0],
            ( a.value[0][2].m256_f32[1] < b.value[0][2].m256_f32[1] ) ? a.value[0][2].m256_f32[1] : b.value[0][2].m256_f32[1],
            ( a.value[0][2].m256_f32[2] < b.value[0][2].m256_f32[2] ) ? a.value[0][2].m256_f32[2] : b.value[0][2].m256_f32[2],
            ( a.value[0][2].m256_f32[3] < b.value[0][2].m256_f32[3] ) ? a.value[0][2].m256_f32[3] : b.value[0][2].m256_f32[3],
            ( a.value[0][2].m256_f32[4] < b.value[0][2].m256_f32[4] ) ? a.value[0][2].m256_f32[4] : b.value[0][2].m256_f32[4],
            ( a.value[0][2].m256_f32[5] < b.value[0][2].m256_f32[5] ) ? a.value[0][2].m256_f32[5] : b.value[0][2].m256_f32[5],
            ( a.value[0][2].m256_f32[6] < b.value[0][2].m256_f32[6] ) ? a.value[0][2].m256_f32[6] : b.value[0][2].m256_f32[6],
            ( a.value[0][2].m256_f32[7] < b.value[0][2].m256_f32[7] ) ? a.value[0][2].m256_f32[7] : b.value[0][2].m256_f32[7]
        };

        b256 maxiX = { 
            ( a.value[1][0].m256_f32[0] > b.value[1][0].m256_f32[0] ) ? a.value[1][0].m256_f32[0] : b.value[1][0].m256_f32[0],
            ( a.value[1][0].m256_f32[1] > b.value[1][0].m256_f32[1] ) ? a.value[1][0].m256_f32[1] : b.value[1][0].m256_f32[1],
            ( a.value[1][0].m256_f32[2] > b.value[1][0].m256_f32[2] ) ? a.value[1][0].m256_f32[2] : b.value[1][0].m256_f32[2],
            ( a.value[1][0].m256_f32[3] > b.value[1][0].m256_f32[3] ) ? a.value[1][0].m256_f32[3] : b.value[1][0].m256_f32[3],
            ( a.value[1][0].m256_f32[4] > b.value[1][0].m256_f32[4] ) ? a.value[1][0].m256_f32[4] : b.value[1][0].m256_f32[4],
            ( a.value[1][0].m256_f32[5] > b.value[1][0].m256_f32[5] ) ? a.value[1][0].m256_f32[5] : b.value[1][0].m256_f32[5],
            ( a.value[1][0].m256_f32[6] > b.value[1][0].m256_f32[6] ) ? a.value[1][0].m256_f32[6] : b.value[1][0].m256_f32[6],
            ( a.value[1][0].m256_f32[7] > b.value[1][0].m256_f32[7] ) ? a.value[1][0].m256_f32[7] : b.value[1][0].m256_f32[7]
        };
        b256 maxiY = { 
            ( a.value[1][1].m256_f32[0] > b.value[1][1].m256_f32[0] ) ? a.value[1][1].m256_f32[0] : b.value[1][1].m256_f32[0],
            ( a.value[1][1].m256_f32[1] > b.value[1][1].m256_f32[1] ) ? a.value[1][1].m256_f32[1] : b.value[1][1].m256_f32[1],
            ( a.value[1][1].m256_f32[2] > b.value[1][1].m256_f32[2] ) ? a.value[1][1].m256_f32[2] : b.value[1][1].m256_f32[2],
            ( a.value[1][1].m256_f32[3] > b.value[1][1].m256_f32[3] ) ? a.value[1][1].m256_f32[3] : b.value[1][1].m256_f32[3],
            ( a.value[1][1].m256_f32[4] > b.value[1][1].m256_f32[4] ) ? a.value[1][1].m256_f32[4] : b.value[1][1].m256_f32[4],
            ( a.value[1][1].m256_f32[5] > b.value[1][1].m256_f32[5] ) ? a.value[1][1].m256_f32[5] : b.value[1][1].m256_f32[5],
            ( a.value[1][1].m256_f32[6] > b.value[1][1].m256_f32[6] ) ? a.value[1][1].m256_f32[6] : b.value[1][1].m256_f32[6],
            ( a.value[1][1].m256_f32[7] > b.value[1][1].m256_f32[7] ) ? a.value[1][1].m256_f32[7] : b.value[1][1].m256_f32[7]
        };
        b256 maxiZ = { 
            ( a.value[1][2].m256_f32[0] > b.value[1][2].m256_f32[0] ) ? a.value[1][2].m256_f32[0] : b.value[1][2].m256_f32[0],
            ( a.value[1][2].m256_f32[1] > b.value[1][2].m256_f32[1] ) ? a.value[1][2].m256_f32[1] : b.value[1][2].m256_f32[1],
            ( a.value[1][2].m256_f32[2] > b.value[1][2].m256_f32[2] ) ? a.value[1][2].m256_f32[2] : b.value[1][2].m256_f32[2],
            ( a.value[1][2].m256_f32[3] > b.value[1][2].m256_f32[3] ) ? a.value[1][2].m256_f32[3] : b.value[1][2].m256_f32[3],
            ( a.value[1][2].m256_f32[4] > b.value[1][2].m256_f32[4] ) ? a.value[1][2].m256_f32[4] : b.value[1][2].m256_f32[4],
            ( a.value[1][2].m256_f32[5] > b.value[1][2].m256_f32[5] ) ? a.value[1][2].m256_f32[5] : b.value[1][2].m256_f32[5],
            ( a.value[1][2].m256_f32[6] > b.value[1][2].m256_f32[6] ) ? a.value[1][2].m256_f32[6] : b.value[1][2].m256_f32[6],
            ( a.value[1][2].m256_f32[7] > b.value[1][2].m256_f32[7] ) ? a.value[1][2].m256_f32[7] : b.value[1][2].m256_f32[7]
        };

        return BoundingBox8( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }
};


/////////////////////////////////////////////////////////////////////////////////////////////
// Random class
/////////////////////////////////////////////////////////////////////////////////////////////
class Random
{
    //=======================================================================================
    // list of friend classes and methods.
    //=======================================================================================
    /* NOTHING */

public:
    //=======================================================================================
    // public variables.
    //=======================================================================================
    /* NOTHING */

    //=======================================================================================
    // public methods.
    //=======================================================================================

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random()
    { SetSeed( 123456789 ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random( const u32 seed ) 
    { SetSeed( seed ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random( const Random& value )
    : m_X( value.m_X )
    , m_Y( value.m_Y )
    , m_Z( value.m_Z )
    , m_W( value.m_W )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      乱数種を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetSeed( const u32 seed )
    {
        // 超越数設定.
        m_X = 123456789;
        m_Y = 362436069;
        m_Z = 521288629;
        m_W = ( seed <= 0 ) ? 88675123 : seed;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      u32型として乱数を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    u32 GetAsU32()
    {
        u32 t = m_X ^ ( m_X << 11 );
        m_X   = m_Y;
        m_Y   = m_Z;
        m_Z   = m_W;
        m_W   = ( m_W ^ ( m_W >> 19 ) ) ^ ( t ^ ( t >> 8 ) );
        return m_W;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      f64型として乱数を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f64 GetAsF64()
    { return static_cast<f64>( GetAsU32() ) / 0xffffffffui32; }

    //---------------------------------------------------------------------------------------------
    //! @brief      f32型として乱数を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetAsF32()
    { return static_cast<f32>( GetAsU32() ) / 0xffffffffui32; }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random& operator = ( const Random& value )
    {
        m_X = value.m_X;
        m_Y = value.m_Y;
        m_Z = value.m_Z;
        m_W = value.m_W;
        return (*this);
    }

protected:
    //=======================================================================================
    // protected variables.
    //=======================================================================================
    /* NOTHING */

    //=======================================================================================
    // protected methods.
    //=======================================================================================
    /* NOTHING */

private:
    //=======================================================================================
    // private variables.
    //=======================================================================================
    u32 m_X;
    u32 m_Y;
    u32 m_Z;
    u32 m_W;

    //=======================================================================================
    // private methods.
    //=======================================================================================
    /* NOTHING */
};


/////////////////////////////////////////////////////////////////////////////////////////////
// OrthonormalBasis structure
/////////////////////////////////////////////////////////////////////////////////////////////
struct OrthonormalBasis
{
public:
    Vector3 u;
    Vector3 v;
    Vector3 w;

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    OrthonormalBasis();

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    OrthonormalBasis( const Vector3&, const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      U方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromU( const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      V方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromV( const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      W方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromW( const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      UV方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromUV( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      VU方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromVU( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      UW方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromUW( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      WU方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromWU( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      VW方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromVW( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      WV方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromWV( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //---------------------------------------------------------------------------------------------
    bool operator == ( const OrthonormalBasis& ) const;

    //---------------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //---------------------------------------------------------------------------------------------
    bool operator != ( const OrthonormalBasis& ) const;
};


//------------------------------------------------------------------------------------------
//! @brief      三角形の表面積を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const Vector3& a, const Vector3& b, const Vector3& c )
{
   f32 X = ( b.y - a.y ) * ( c.z - a.z ) - ( c.y - a.y ) * ( b.z - a.z );
   f32 Y = ( b.z - a.z ) * ( c.x - a.x ) - ( c.z - a.z ) * ( b.x - a.x );
   f32 Z = ( b.x - a.x ) * ( c.y - a.y ) - ( c.x - a.x ) * ( b.y - a.y );
   return 0.5f * sqrtf( ( X * X ) + ( Y * Y ) + ( Z * Z ) );
}

//------------------------------------------------------------------------------------------
//! @brief      バウンディングボックスの表面積を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const BoundingBox& box )
{
    f32 X = fabs( box.maxi.x - box.mini.x );
    f32 Y = fabs( box.maxi.y - box.mini.y );
    f32 Z = fabs( box.maxi.z - box.mini.z );
    return 2.0f * ( ( X * Y ) + ( X * Z ) + ( Y * Z ) );
}

//------------------------------------------------------------------------------------------
//! @brief      バウンディングスフィアの表面積を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const f32 radius )
{
    return 4.0f * F_PI * ( radius * radius );
}

} // namespace s3d

