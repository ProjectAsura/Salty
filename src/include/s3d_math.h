//------------------------------------------------------------------------------------------
// File : s3d_math.h.
// Desc : Math Module.
// Copyright(c) Project Asura. All right reserved.
//------------------------------------------------------------------------------------------

#ifndef __S3D_MATH__
#define __S3D_MATH__

//------------------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------------------
#include <s3d_typedef.h>
#include <cmath>
#include <cfloat>
#include <cassert>


namespace s3d {

//------------------------------------------------------------------------------------------
// Forward Declarations.
//------------------------------------------------------------------------------------------
struct  Vector2;
struct  Vector3;
struct  Vector4;
struct  Ray;
struct  Ray4;
struct  Ray8;
struct  Matrix;
struct  BoundingBox;
struct  BoundingBox4;
struct  BoundingBox8;


//------------------------------------------------------------------------------------------
// Type Definitions.
//------------------------------------------------------------------------------------------
typedef Vector3 Color;


//------------------------------------------------------------------------------------------
// Constant Values
//------------------------------------------------------------------------------------------
const f32   F_HIT_MAX   = 1e12f;                                  //!< 交差判定上限値.
const f32   F_HIT_MIN   = 0.1f;                                   //!< 交差判定下限値.
const f32   F_PI        = 3.1415926535897932384626433832795f;     //!< πです.
const f32   F_2PI       = 6.283185307179586476925286766559f;      //!< 2πです.
const f32   F_1DIVPI    = 0.31830988618379067153776752674503f;    //!< 1/πです.
const f32   F_1DIV2PI   = 0.15915494309189533576888376337251f;    //!< 1/2πです.
const f32   F_PIDIV2    = 1.5707963267948966192313216916398f;     //!< π/2です.
const f32   F_PIDIV3    = 1.0471975511965977461542144610932f;     //!< π/3です.
const f32   F_PIDIV4    = 0.78539816339744830961566084581988f;    //!< π/4です.
const f32   F_MAX       = 3.402823466e+38F;                       //!< f32型の最大値です.
const f32   F_MIN       = 1.175494351e-38F;                       //!< f32型の最小値です.


//------------------------------------------------------------------------------------------
//! @brief      符号を求めます.
//------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
s32 Sign( const T val )
{ return ( val > T(0) ) ? 1 : (( val < T(0) ) ? -1 : 0 ); }


//------------------------------------------------------------------------------------------
//! @brief      最大値を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 Max( const f32 a, const f32 b )
{ return ( a > b ) ? a : b; }

//------------------------------------------------------------------------------------------
//! @brief      最小値を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 Min( const f32 a, const f32 b )
{ return ( a < b ) ? a : b; }

//------------------------------------------------------------------------------------------
//! @brief      ラジアンに変換します.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToRad( const f32 deg )
{ return deg * ( F_PI / 180.0f ); }

//------------------------------------------------------------------------------------------
//! @brief      度に変換します.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToDeg( const f32 rad )
{ return rad * ( 180.0f / F_PI ); }

//------------------------------------------------------------------------------------------
//! @brief      非数であるかチェックします.
//------------------------------------------------------------------------------------------
S3D_INLINE
bool IsNan( const f32 value )
{ return ( value != value ); }

//------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SafeSqrt( const f32 value )
{
    if ( value > FLT_EPSILON )
    { return sqrtf( value ); }

    return 0.0f;
}

//------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f64 SafeSqrt( const f64 value )
{
    if ( value > DBL_EPSILON )
    { return sqrt( value ); }

    return 0.0;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Vector2 structure
/////////////////////////////////////////////////////////////////////////////////////////////
struct Vector2
{
public:
    union
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
        };
        f32 a[2];       //!< 各成分を表す配列です;
    };

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector2()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector2( const f32 nx, const f32 ny )
    : x( nx )
    , y( ny )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector2( const Vector2& value )
    : x( value.x )
    , y( value.y )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      等価演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector2& value ) const
    {
        return ( x == value.x )
            && ( y == value.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      非等価演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector2& value ) const
    {
        return ( x != value.x )
            || ( y != value.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator = ( const Vector2& value )
    {
        x = value.x;
        y = value.y;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator += ( const Vector2& b )
    {
        x += b.x;
        y += b.y;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator -= ( const Vector2& b )
    {
        x -= b.x;
        y -= b.y;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator /= ( const f32 b )
    {
        assert( b != 0.0 );
        x /= b;
        y /= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2  operator + () const
    { return Vector2( x, y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - () const
    { return Vector2( -x, -y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator + (const Vector2 &b) const
    {
        return Vector2(
            x + b.x,
            y + b.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - (const Vector2 &b) const
    { 
        return Vector2(
            x - b.x,
            y - b.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator * (const f32 b) const
    { 
        return Vector2(
            x * b,
            y * b );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator / (const f32 b) const
    {
        assert( b != 0.0 );
        return Vector2(
            x / b,
            y / b );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) ); }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        register f32 mag = sqrtf( x * x + y * y );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        register f32 mag = sqrtf( x * x + y * y );
        if ( mag > 0.0f )
        {
            x /= mag;
            y /= mag;
        }
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 UnitVector (const Vector2 &v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y );
        assert( mag != 0.0 );
        return Vector2(
            v.x / mag,
            v.y / mag );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 SafeUnitVector ( const Vector2& v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y );
        if ( mag > 0.0f )
        {
            return Vector2(
                v.x / mag,
                v.y / mag );
        }
        return v;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Mul (const Vector2 &v1, const Vector2 &v2)
    { 
        return Vector2(
            v1.x * v2.x,
            v1.y * v2.y );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector2 &v1, const Vector2 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ); }

    //--------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Reflect( const Vector2& i, const Vector2& n )
    {
        register f32 dot = ( n.x * i.x ) + ( n.y * i.y );
        register f32 _2dot = 2.0f * dot;

        return Vector2(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ) );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Min( const Vector2& a, const Vector2& b )
    {
        return Vector2( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Max( const Vector2& a, const Vector2& b )
    {
        return Vector2(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y );
    }
};


////////////////////////////////////////////////////////////////////////////////////////////
// Vector3 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Vector3
{
public:
    union 
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
            f32 z;      //!< Z成分です.
        };
        f32 a[3];       //!< 各成分を表す配列です.
    };

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector3()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector3( const f32 nx, const f32 ny, const f32 nz ) 
    : x( nx )
    , y( ny )
    , z( nz )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    Vector3( const Vector3& value )
    : x( value.x )
    , y( value.y )
    , z( value.z )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector3& b ) const
    {
        return ( x == b.x )
            && ( y == b.y )
            && ( z == b.z );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector3& b ) const
    {
        return ( x != b.x )
            || ( y != b.y )
            || ( z != b.z );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator = ( const Vector3& b )
    {
        x = b.x;
        y = b.y;
        z = b.z;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator += ( const Vector3& b )
    {
        x += b.x;
        y += b.y;
        z += b.z;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator -= ( const Vector3& b )
    {
        x -= b.x;
        y -= b.y;
        z -= b.z;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        z *= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator /= ( const f32 b )
    {
        assert( b != 0.0 );
        x /= b;
        y /= b;
        z /= b;
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3  operator + () const
    { return Vector3( x, y, z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - () const
    { return Vector3( -x, -y, -z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator + (const Vector3 &b) const
    {
        return Vector3(
            x + b.x,
            y + b.y,
            z + b.z);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - (const Vector3 &b) const
    { 
        return Vector3(
            x - b.x,
            y - b.y,
            z - b.z);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator * (const f32 b) const
    { 
        return Vector3(
            x * b,
            y * b,
            z * b);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator / (const f32 b) const
    {
        assert( b != 0.0 );
        return Vector3(
            x / b,
            y / b,
            z / b);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ) + ( z * z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) ); }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        register f32 mag = sqrtf( x * x + y * y + z * z );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
        z /= mag;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        register f32 mag = sqrtf( x * x + y * y + z * z );
        if ( mag > 0.0f )
        {
             x /= mag;
             y /= mag;
             z /= mag;
        }
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 UnitVector (const Vector3 &v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z );
        assert( mag > 0.0f );
        return Vector3(
            v.x / mag,
            v.y / mag,
            v.z / mag );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 SafeUnitVector (const Vector3& v)
    {
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z );
        if ( mag > 0.0f )
        {
            return Vector3(
                v.x / mag,
                v.y / mag,
                v.z / mag );
        }
        return v;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Mul (const Vector3 &v1, const Vector3 &v2)
    { 
        return Vector3(
            v1.x * v2.x,
            v1.y * v2.y,
            v1.z * v2.z);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector3 &v1, const Vector3 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ) + ( v1.z * v2.z ); }

    //--------------------------------------------------------------------------------------
    //! @brief      外積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Cross (const Vector3 &v1, const Vector3 &v2) 
    {
        return Vector3(
            (v1.y * v2.z) - (v1.z * v2.y),
            (v1.z * v2.x) - (v1.x * v2.z),
            (v1.x * v2.y) - (v1.y * v2.x)
        );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Reflect( const Vector3& i, const Vector3& n )
    {
        register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z );
        register f32 _2dot = 2.0f * dot;

        return Vector3(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ),
            i.z - ( _2dot * n.z ) );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Min( const Vector3& a, const Vector3& b )
    {
        return Vector3( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y,
            ( a.z < b.z ) ? a.z : b.z );
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Max( const Vector3& a, const Vector3& b )
    {
        return Vector3(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y,
            ( a.z > b.z ) ? a.z : b.z );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      法線ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeNormal( const Vector3& a, const Vector3& b, const Vector3& c )
    {
        Vector3 e1 = b - a;
        Vector3 e2 = c - a;
        return Vector3::UnitVector( Vector3::Cross( e1, e2 ) );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      矩形の法線ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeQuadNormal( const Vector3& a, const Vector3& b, const Vector3& c, const Vector3& d )
    {
        Vector3 n1a = ComputeNormal( a, b, c );
        Vector3 n1b = ComputeNormal( a, c, d );
        Vector3 n2a = ComputeNormal( b, c, d );
        Vector3 n2b = ComputeNormal( b, d, c );

        if ( Vector3::Dot( n1a, n1b ) > Vector3::Dot( n2a, n2b ) )
        { return Vector3::UnitVector( n1a + n1b ); }
        else
        { return Vector3::UnitVector( n2a + n2b ); }
    }
};

//------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//------------------------------------------------------------------------------------------
S3D_INLINE 
Vector3 operator * (const f32 f, const Vector3 &v)
{ return v * f; }



////////////////////////////////////////////////////////////////////////////////////////////
// Vector4 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Vector4
{
public:
    union 
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
            f32 z;      //!< Z成分です.
            f32 w;      //!< W成分です.
        };
        f32     a[4];   //!< 各成分を表す配列です.
    #if S3D_IS_SIMD
        b128    v;      //!< パック化された値です.
    #endif//S3D_IS_SIMD
    };

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const f32 nx, const f32 ny, const f32 nz, const f32 nw ) 
  #if S3D_IS_SIMD
    : v( _mm_set_ps( nw, nz, ny, nx ) )
  #else
    : x( nx )
    , y( ny )
    , z( nz )
    , w( nz )
  #endif
    {
        /* DO_NOTHING */
    }

  #if S3D_IS_SIMD
    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const b128 nv )
    : v( nv )
    { /* DO_NOTHING */ }
  #endif//S3D_IS_SIMD

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const Vector4& value )
  #if S3D_IS_SIMD
    : v( value.v )
  #else
    : x( value.x )
    , y( value.y )
    , z( value.z )
    , w( value.w )
  #endif
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector4& b ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_cmpeq_ps( v, b.v );
        return ((_mm_movemask_ps(c) == 0x0f) != 0);
    #else
        return ( x == b.x )
            && ( y == b.y )
            && ( z == b.z )
            && ( w == b.w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector4& b ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_cmpneq_ps( v, b.v );
        return ((_mm_movemask_ps(c)) != 0);
    #else
        return ( x != b.x )
            || ( y != b.y )
            || ( z != b.z )
            || ( w != b.w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator = ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = b.v;
    #else
        x = b.x;
        y = b.y;
        z = b.z;
        w = b.w;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator += ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = _mm_add_ps( v, b.v );
    #else
        x += b.x;
        y += b.y;
        z += b.z;
        w += b.w;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator -= ( const Vector4& b )
    {
    #if S3D_IS_SIMD
        v = _mm_sub_ps( v, b.v );
    #else
        x -= b.x;
        y -= b.y;
        z -= b.z;
        w -= b.w;
    #endif
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator *= ( const f32 b )
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( b, b, b, b );
        v = _mm_mul_ps( v, c );
    #else
        x *= b;
        y *= b;
        z *= b;
        w *= b;
    #endif
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator /= ( const f32 b )
    {
        assert( b != 0.0 );
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( b, b, b, b );
        v = _mm_div_ps( v, c );
    #else
        x /= b;
        y /= b;
        z /= b;
        w /= b;
    #endif
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4  operator + () const
    {
    #if S3D_IS_SIMD
        return Vector4( v );
    #else
        return Vector4( x, y, z, w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - () const
    {
    #if S3D_IS_SIMD
        b128 z = _mm_setzero_ps();
        return Vector4( _mm_sub_ps( z, v ) );
    #else
        return Vector4( -x, -y, -z, -w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator + (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_add_ps( v, b.v ) );
    #else
        return Vector4(
            x + b.x,
            y + b.y,
            z + b.z,
            w + b.w);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - (const Vector4 &b) const
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_sub_ps( v, b.v ) );
    #else
        return Vector4(
            x - b.x,
            y - b.y,
            z - b.z,
            w - b.w);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator * (const f32 b) const
    {
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_mul_ps( v, s ) );
    #else
        return Vector4(
            x * b,
            y * b,
            z * b,
            w * b);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator / (const f32 b) const
    {
        assert( b != 0.0 );
    #if S3D_IS_SIMD
        b128 s = _mm_set1_ps( b );
        return Vector4( _mm_div_ps( v, s ) );
    #else
        return Vector4(
            x / b,
            y / b,
            z / b,
            w / b);
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { 
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        return ( t.x + t.y + t.z + t.w );
    #else
        return ( x * x ) + ( y * y ) + ( z * z ) + ( w * w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        return sqrtf( t.x + t.y + t.z + t.w );
    #else
        return sqrtf( ( x * x ) + ( y * y ) + ( z * z ) + ( w * w ) );
    #endif
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        assert( mag > 0.0f );
        b128 c = _mm_set1_ps( mag );
        v = _mm_div_ps( v, c );
    #else
        register f32 mag = sqrtf( x * x + y * y + z * z + w * w );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
        z /= mag;
        w /= mag;
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v, v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        if ( mag > 0.0f )
        {
            b128 c = _mm_set1_ps( mag );
            v = _mm_div_ps( v, c );
        }
    #else
        register f32 mag = sqrtf( x * x + y * y + z * z + w * w );
        if ( mag > 0.0f )
        {
             x /= mag;
             y /= mag;
             z /= mag;
             w /= mag;
        }
    #endif// S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 UnitVector (const Vector4 &v)
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v.v, v.v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        assert( mag > 0.0f );
        b128 c = _mm_set1_ps( mag );
        return Vector4( _mm_div_ps( v.v, c ) );
    #else
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w );
        assert( mag > 0.0f );
        return Vector4(
            v.x / mag,
            v.y / mag,
            v.z / mag,
            v.w / mag );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 SafeUnitVector (const Vector4& v)
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v.v, v.v );
        register f32 mag = sqrtf( t.x + t.y + t.z + t.w );
        if ( mag > 0.0f )
        {
            b128 c = _mm_set1_ps( mag );
            return Vector4( _mm_div_ps( v.v, c ) );
        }
    #else
        register f32 mag = sqrtf( v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w );
        if ( mag > 0.0f )
        {
            return Vector4(
                v.x / mag,
                v.y / mag,
                v.z / mag,
                v.w / mag );
        }
    #endif
        return v;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Mul (const Vector4 &v1, const Vector4 &v2)
    { 
    #if S3D_IS_SIMD
        return Vector4( _mm_mul_ps( v1.v, v2.v ) );
    #else
        return Vector4(
            v1.x * v2.x,
            v1.y * v2.y,
            v1.z * v2.z,
            v1.w * v2.w );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector4 &v1, const Vector4 &v2) 
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( v1.v, v2.v );
        return ( t.x + t.y + t.z + t.w );
    #else
        return ( v1.x * v2.x ) + ( v1.y * v2.y ) + ( v1.z * v2.z ) + ( v1.w * v2.w );
    #endif
    }


    //--------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //--------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Reflect( const Vector4& i, const Vector4& n )
    {
    #if S3D_IS_SIMD
        Vector4 t = _mm_mul_ps( n.v, i.v );
        register f32 _2dot = 2.0f * ( t.x + t.y + t.z + t.z );
        b128 c = _mm_set1_ps( _2dot );
        b128 b = _mm_mul_ps( c, n.v );
        return Vector4( _mm_sub_ps( i.v, b ) );
    #else
        register f32 dot = ( n.x * i.x ) + ( n.y * i.y ) + ( n.z * i.z ) + ( n.w * i.w );
        register f32 _2dot = 2.0f * dot;

        return Vector4(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ),
            i.z - ( _2dot * n.z ),
            i.w - ( _2dot * n.w ) );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Min( const Vector4& a, const Vector4& b )
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_min_ps( a.v, b.v ) );
    #else
        return Vector4( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y,
            ( a.z < b.z ) ? a.z : b.z,
            ( a.w < b.w ) ? a.w : b.w );
    #endif//S3D_IS_SIMD
    }

    //---------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //---------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Max( const Vector4& a, const Vector4& b )
    {
    #if S3D_IS_SIMD
        return Vector4( _mm_max_ps( a.v, b.v ) );
    #else
        return Vector4(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y,
            ( a.z > b.z ) ? a.z : b.z,
            ( a.w > b.w ) ? a.w : b.w );
    #endif//S3D_IS_SIMD
    }
};

//------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//------------------------------------------------------------------------------------------
S3D_INLINE 
Vector4 operator * (const f32 f, const Vector4 &v)
{
#if S3D_IS_SIMD
    b128 c = _mm_set1_ps( f );
    return Vector4( _mm_mul_ps( c, v.v ) );
#else
    return Vector4(
        f * v.x,
        f * v.y,
        f * v.z,
        f * v.w );
#endif//S3D_IS_SIMD
}


////////////////////////////////////////////////////////////////////////////////////////////
// Ray structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray
{
    Vector3 pos;            //!< 位置座標です.
    Vector3 dir;            //!< 方向ベクトルです.
    Vector3 invDir;         //!< 方向ベクトルの各成分の逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    Ray( const Vector3& p, const Vector3& d )
    { Update( p, d ); }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    Ray( const Ray& value )
    { Update( value.pos, value.dir ); }

    //--------------------------------------------------------------------------------------
    //! @brief      レイを更新します.
    //--------------------------------------------------------------------------------------
    void Update( const Vector3& p, const Vector3& d )
    {
        pos.x = p.x;
        pos.y = p.y;
        pos.z = p.z;

        dir.x = d.x;
        dir.y = d.y;
        dir.z = d.z;

        invDir.x = 1.0f / dir.x;
        invDir.y = 1.0f / dir.y;
        invDir.z = 1.0f / dir.z;

        sign[0] = ( dir.x > 0.0f ) ? 0 : 1;
        sign[1] = ( dir.y > 0.0f ) ? 0 : 1;
        sign[2] = ( dir.z > 0.0f ) ? 0 : 1;
    }
};

////////////////////////////////////////////////////////////////////////////////////////////
// Ray4 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray4
{
    b128    pos[3];         //!< 位置座標です.
    b128    invDir[3];      //!< 方向ベクトルの逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //-------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray4( const Ray& ray )
    {
    #if S3D_IS_SIMD
        pos[0] = _mm_set1_ps( ray.pos.x );
        pos[1] = _mm_set1_ps( ray.pos.y );
        pos[2] = _mm_set1_ps( ray.pos.z );

        invDir[0] = _mm_set1_ps( ray.invDir.x );
        invDir[1] = _mm_set1_ps( ray.invDir.y );
        invDir[2] = _mm_set1_ps( ray.invDir.z );
    #else
        pos[0].m128_f32[0] = ray.pos.x;
        pos[0].m128_f32[1] = ray.pos.x;
        pos[0].m128_f32[2] = ray.pos.x;
        pos[0].m128_f32[3] = ray.pos.x;

        pos[1].m128_f32[0] = ray.pos.y;
        pos[1].m128_f32[1] = ray.pos.y;
        pos[1].m128_f32[2] = ray.pos.y;
        pos[1].m128_f32[3] = ray.pos.y;

        pos[2].m128_f32[0] = ray.pos.z;
        pos[2].m128_f32[1] = ray.pos.z;
        pos[2].m128_f32[2] = ray.pos.z;
        pos[2].m128_f32[3] = ray.pos.z;

        invDir[0].m128_f32[0] = ray.invDir.x;
        invDir[0].m128_f32[1] = ray.invDir.x;
        invDir[0].m128_f32[2] = ray.invDir.x;
        invDir[0].m128_f32[3] = ray.invDir.x;

        invDir[1].m128_f32[0] = ray.invDir.y;
        invDir[1].m128_f32[1] = ray.invDir.y;
        invDir[1].m128_f32[2] = ray.invDir.y;
        invDir[1].m128_f32[3] = ray.invDir.y;

        invDir[2].m128_f32[0] = ray.invDir.z;
        invDir[2].m128_f32[1] = ray.invDir.z;
        invDir[2].m128_f32[2] = ray.invDir.z;
        invDir[2].m128_f32[3] = ray.invDir.z;
    #endif
        sign[0] = ray.sign[0];
        sign[1] = ray.sign[1];
        sign[2] = ray.sign[2];
    }

    //-------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray4( const Ray4& rayQuad )
    {
        pos[0] = rayQuad.pos[0];
        pos[1] = rayQuad.pos[1];
        pos[2] = rayQuad.pos[2];

        invDir[0] = rayQuad.invDir[0];
        invDir[1] = rayQuad.invDir[1];
        invDir[2] = rayQuad.invDir[2];

        sign[0] = rayQuad.sign[0];
        sign[1] = rayQuad.sign[1];
        sign[2] = rayQuad.sign[2];
    }
};


////////////////////////////////////////////////////////////////////////////////////////////
// Ray4 structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Ray8
{
    b256    pos[3];         //!< 位置座標です.
    b256    invDir[3];      //!< 方向ベクトルの逆数です.
    s32     sign[3];        //!< 方向ベクトルの符号です.

    //-------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray8( const Ray& ray )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        pos[0] = _mm256_set1_ps( ray.pos.x );
        pos[1] = _mm256_set1_ps( ray.pos.y );
        pos[2] = _mm256_set1_ps( ray.pos.z );

        invDir[0] = _mm256_set1_ps( ray.invDir.x );
        invDir[1] = _mm256_set1_ps( ray.invDir.y );
        invDir[2] = _mm256_set1_ps( ray.invDir.z );
    #else
        pos[0].m256_f32[0] = ray.pos.x;
        pos[0].m256_f32[1] = ray.pos.x;
        pos[0].m256_f32[2] = ray.pos.x;
        pos[0].m256_f32[3] = ray.pos.x;
        pos[0].m256_f32[4] = ray.pos.x;
        pos[0].m256_f32[5] = ray.pos.x;
        pos[0].m256_f32[6] = ray.pos.x;
        pos[0].m256_f32[7] = ray.pos.x;

        pos[1].m256_f32[0] = ray.pos.y;
        pos[1].m256_f32[1] = ray.pos.y;
        pos[1].m256_f32[2] = ray.pos.y;
        pos[1].m256_f32[3] = ray.pos.y;
        pos[1].m256_f32[4] = ray.pos.y;
        pos[1].m256_f32[5] = ray.pos.y;
        pos[1].m256_f32[6] = ray.pos.y;
        pos[1].m256_f32[7] = ray.pos.y;

        pos[2].m256_f32[0] = ray.pos.z;
        pos[2].m256_f32[1] = ray.pos.z;
        pos[2].m256_f32[2] = ray.pos.z;
        pos[2].m256_f32[3] = ray.pos.z;
        pos[2].m256_f32[4] = ray.pos.z;
        pos[2].m256_f32[5] = ray.pos.z;
        pos[2].m256_f32[6] = ray.pos.z;
        pos[2].m256_f32[7] = ray.pos.z;

        invDir[0].m256_f32[0] = ray.invDir.x;
        invDir[0].m256_f32[1] = ray.invDir.x;
        invDir[0].m256_f32[2] = ray.invDir.x;
        invDir[0].m256_f32[3] = ray.invDir.x;
        invDir[0].m256_f32[4] = ray.invDir.x;
        invDir[0].m256_f32[5] = ray.invDir.x;
        invDir[0].m256_f32[6] = ray.invDir.x;
        invDir[0].m256_f32[7] = ray.invDir.x;

        invDir[1].m256_f32[0] = ray.invDir.y;
        invDir[1].m256_f32[1] = ray.invDir.y;
        invDir[1].m256_f32[2] = ray.invDir.y;
        invDir[1].m256_f32[3] = ray.invDir.y;
        invDir[1].m256_f32[4] = ray.invDir.y;
        invDir[1].m256_f32[5] = ray.invDir.y;
        invDir[1].m256_f32[6] = ray.invDir.y;
        invDir[1].m256_f32[7] = ray.invDir.y;

        invDir[2].m256_f32[0] = ray.invDir.z;
        invDir[2].m256_f32[1] = ray.invDir.z;
        invDir[2].m256_f32[2] = ray.invDir.z;
        invDir[2].m256_f32[3] = ray.invDir.z;
        invDir[2].m256_f32[4] = ray.invDir.z;
        invDir[2].m256_f32[5] = ray.invDir.z;
        invDir[2].m256_f32[6] = ray.invDir.z;
        invDir[2].m256_f32[7] = ray.invDir.z;
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
        sign[0] = ray.sign[0];
        sign[1] = ray.sign[1];
        sign[2] = ray.sign[2];
    }

    //-------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //-------------------------------------------------------------------------------------
    Ray8( const Ray8& rayOct )
    {
        pos[0] = rayOct.pos[0];
        pos[1] = rayOct.pos[1];
        pos[2] = rayOct.pos[2];

        invDir[0] = rayOct.invDir[0];
        invDir[1] = rayOct.invDir[1];
        invDir[2] = rayOct.invDir[2];

        sign[0] = rayOct.sign[0];
        sign[1] = rayOct.sign[1];
        sign[2] = rayOct.sign[2];
    }
};



////////////////////////////////////////////////////////////////////////////////////////////
// Matric structure
////////////////////////////////////////////////////////////////////////////////////////////
struct Matrix
{
public:
    //======================================================================================
    // public variables.
    //======================================================================================
    union
    {
        struct 
        {
            f32 _11, _12, _13, _14;
            f32 _21, _22, _23, _24;
            f32 _31, _32, _33, _34;
            f32 _41, _42, _43, _44;
        };
        f32     a[16];
    #if S3D_IS_SIMD
        struct
        {
            b128    v0;
            b128    v1;
            b128    v2;
            b128    v3;
        };
    #endif
    };

    //======================================================================================
    // public methods
    //======================================================================================

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix()
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix
    (
        const f32 m11, const f32 m12, const f32 m13, const f32 m14,
        const f32 m21, const f32 m22, const f32 m23, const f32 m24,
        const f32 m31, const f32 m32, const f32 m33, const f32 m34,
        const f32 m41, const f32 m42, const f32 m43, const f32 m44
    )
  #if S3D_IS_SIMD
    : v0( _mm_set_ps( m14, m13, m12, m11 ) )
    , v1( _mm_set_ps( m24, m23, m22, m21 ) )
    , v2( _mm_set_ps( m34, m33, m32, m31 ) )
    , v3( _mm_set_ps( m44, m43, m42, m41 ) )
  #else
    : _11( m11 ), _12( m12 ), _13( m13 ), _14( m14 )
    , _21( m21 ), _22( m22 ), _23( m23 ), _24( m24 )
    , _31( m31 ), _32( m32 ), _33( m33 ), _34( m34 )
    , _41( m41 ), _42( m42 ), _43( m43 ), _44( m44 )
  #endif//S3D_IS_SIMD
    { /* DO_NOTHING */ }

  #if S3D_IS_SIMD
    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix( const b128 c0, const b128 c1, const b128 c2, const b128 c3 )
    : v0( c0 )
    , v1( c1 )
    , v2( c2 )
    , v3( c3 )
    { /* DO_NOTHING */ }
  #endif//S3D_IS_SIMD

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix( const Matrix& value)
  #if S3D_IS_SIMD
    : v0 ( value.v0 )
    , v1 ( value.v1 )
    , v2 ( value.v2 )
    , v3 ( value.v3 )
  #else
    : _11( value._11 ), _12( value._12 ), _13( value._13 ), _14( value._14 )
    , _21( value._21 ), _22( value._22 ), _23( value._23 ), _24( value._24 )
    , _31( value._31 ), _32( value._32 ), _33( value._33 ), _34( value._34 )
    , _41( value._41 ), _42( value._42 ), _43( value._43 ), _44( value._44 )
  #endif//S3D_IS_SIMD
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator =  ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        v0 = value.v0;
        v1 = value.v1;
        v2 = value.v2;
        v3 = value.v3;
    #else
        _11 = value._11; _12 = value._12; _13 = value._13; _14 = value._14;
        _21 = value._21; _22 = value._22; _23 = value._23; _24 = value._24;
        _31 = value._31; _32 = value._32; _33 = value._33; _34 = value._34;
        _41 = value._41; _42 = value._42; _43 = value._43; _44 = value._44;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator += ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        v0 = _mm_add_ps( v0, value.v0 );
        v1 = _mm_add_ps( v1, value.v1 );
        v2 = _mm_add_ps( v2, value.v2 );
        v3 = _mm_add_ps( v3, value.v3 );
    #else
        _11 += value._11; _12 += value._12; _13 += value._13; _14 += value._14;
        _21 += value._21; _22 += value._22; _23 += value._23; _24 += value._24;
        _31 += value._31; _32 += value._32; _33 += value._33; _34 += value._34;
        _41 += value._41; _42 += value._42; _43 += value._43; _44 += value._44;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator -= ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        v0 = _mm_sub_ps( v0, value.v0 );
        v1 = _mm_sub_ps( v1, value.v1 );
        v2 = _mm_sub_ps( v2, value.v2 );
        v3 = _mm_sub_ps( v3, value.v3 );
    #else
        _11 -= value._11; _12 -= value._12; _13 -= value._13; _14 -= value._14;
        _21 -= value._21; _22 -= value._22; _23 -= value._23; _24 -= value._24;
        _31 -= value._31; _32 -= value._32; _33 -= value._33; _34 -= value._34;
        _41 -= value._41; _42 -= value._42; _43 -= value._43; _44 -= value._44;
    #endif//S3D_IS_SIMD
        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator *= ( const Matrix& value )
    {
    #if S3D_IS_SIMD
        b128 r0 = _mm_set_ps( value._41, value._31, value._21, value._11 );
        b128 r1 = _mm_set_ps( value._42, value._32, value._22, value._12 );
        b128 r2 = _mm_set_ps( value._43, value._33, value._23, value._13 );
        b128 r3 = _mm_set_ps( value._44, value._34, value._24, value._14 );

        Vector4 m0 = _mm_mul_ps( v0, r0 );
        Vector4 m1 = _mm_mul_ps( v0, r1 );
        Vector4 m2 = _mm_mul_ps( v0, r2 );
        Vector4 m3 = _mm_mul_ps( v0, r3 );

        v0 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        m0 = _mm_mul_ps( v1, r0 );
        m1 = _mm_mul_ps( v1, r1 );
        m2 = _mm_mul_ps( v1, r2 );
        m3 = _mm_mul_ps( v1, r3 );

        v1 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        m0 = _mm_mul_ps( v2, r0 );
        m1 = _mm_mul_ps( v2, r1 );
        m2 = _mm_mul_ps( v2, r2 );
        m3 = _mm_mul_ps( v2, r3 );

        v2 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        m0 = _mm_mul_ps( v3, r0 );
        m1 = _mm_mul_ps( v3, r1 );
        m2 = _mm_mul_ps( v3, r2 );
        m3 = _mm_mul_ps( v3, r3 );

        v3 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

    #else
        {
            register f32 m11 = ( _11 * value._11 ) + ( _12 * value._21 ) + ( _13 * value._31 ) + ( _14 * value._41 );
            register f32 m12 = ( _11 * value._12 ) + ( _12 * value._22 ) + ( _13 * value._32 ) + ( _14 * value._42 );
            register f32 m13 = ( _11 * value._13 ) + ( _12 * value._23 ) + ( _13 * value._33 ) + ( _14 * value._43 );
            register f32 m14 = ( _11 * value._14 ) + ( _12 * value._24 ) + ( _13 * value._34 ) + ( _14 * value._44 );

            _11 = m11;
            _12 = m12;
            _13 = m13;
            _14 = m14;
        }

        {
            register f32 m21 = ( _21 * value._11 ) + ( _22 * value._21 ) + ( _23 * value._31 ) + ( _24 * value._41 );
            register f32 m22 = ( _21 * value._12 ) + ( _22 * value._22 ) + ( _23 * value._32 ) + ( _24 * value._42 );
            register f32 m23 = ( _21 * value._13 ) + ( _22 * value._23 ) + ( _23 * value._33 ) + ( _24 * value._43 );
            register f32 m24 = ( _21 * value._14 ) + ( _22 * value._24 ) + ( _23 * value._34 ) + ( _24 * value._44 );

            _21 = m21;
            _22 = m22;
            _23 = m23;
            _24 = m24;
        }

        {
            register f32 m31 = ( _31 * value._11 ) + ( _32 * value._21 ) + ( _33 * value._31 ) + ( _34 * value._41 );
            register f32 m32 = ( _31 * value._12 ) + ( _32 * value._22 ) + ( _33 * value._32 ) + ( _34 * value._42 );
            register f32 m33 = ( _31 * value._13 ) + ( _32 * value._23 ) + ( _33 * value._33 ) + ( _34 * value._43 );
            register f32 m34 = ( _31 * value._14 ) + ( _32 * value._24 ) + ( _33 * value._34 ) + ( _34 * value._44 );

            _31 = m31;
            _32 = m32;
            _33 = m33;
            _34 = m34;
        }

        {
            register f32 m41 = ( _41 * value._11 ) + ( _42 * value._21 ) + ( _43 * value._31 ) + ( _44 * value._41 );
            register f32 m42 = ( _41 * value._12 ) + ( _42 * value._22 ) + ( _43 * value._32 ) + ( _44 * value._42 );
            register f32 m43 = ( _41 * value._13 ) + ( _42 * value._23 ) + ( _43 * value._33 ) + ( _44 * value._43 );
            register f32 m44 = ( _41 * value._14 ) + ( _42 * value._24 ) + ( _43 * value._34 ) + ( _44 * value._44 );

            _41 = m41;
            _42 = m42;
            _43 = m43;
            _44 = m44;
        }
    #endif//S3D_IS_SIMD

        return (*this);
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator *= ( const f32 value )
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set_ps( value, value, value, value );
        v0 = _mm_mul_ps( v0, c );
        v1 = _mm_mul_ps( v1, c );
        v2 = _mm_mul_ps( v2, c );
        v3 = _mm_mul_ps( v3, c );
    #else
        _11 *= value; _12 *= value; _13 *= value; _14 *= value;
        _21 *= value; _22 *= value; _23 *= value; _24 *= value;
        _31 *= value; _32 *= value; _33 *= value; _34 *= value;
        _41 *= value; _42 *= value; _43 *= value; _44 *= value;
    #endif//S3D_IS_SIMD
        return (*this); 
    }

    //--------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator + () const
    { return (*this); }
    
    //--------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator - () const
    {
    #if S3D_IS_SIMD
        b128 z = _mm_setzero_ps();
        return Matrix(
            _mm_sub_ps( z, v0 ),
            _mm_sub_ps( z, v1 ),
            _mm_sub_ps( z, v2 ),
            _mm_sub_ps( z, v3 ) );
    #else
        return Matrix(
            -_11, -_12, -_13, -_14,
            -_21, -_22, -_23, -_24,
            -_31, -_32, -_33, -_34,
            -_41, -_42, -_43, -_44 );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator + ( const Matrix& value ) const
    {
    #if S3D_IS_SIMD
        return Matrix(
            _mm_add_ps( v0, value.v0 ),
            _mm_add_ps( v1, value.v1 ),
            _mm_add_ps( v2, value.v2 ),
            _mm_add_ps( v3, value.v3 ) );
    #else
        return Matrix(
            _11 + value._11, _12 + value._12, _13 + value._13, _14 + value._14,
            _21 + value._21, _22 + value._22, _23 + value._23, _24 + value._24,
            _31 + value._31, _32 + value._32, _33 + value._33, _34 + value._34,
            _41 + value._41, _42 + value._42, _43 + value._43, _44 + value._44 );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator - ( const Matrix& value ) const
    {
    #if S3D_IS_SIMD
        return Matrix(
            _mm_sub_ps( v0, value.v0 ),
            _mm_sub_ps( v1, value.v1 ),
            _mm_sub_ps( v2, value.v2 ),
            _mm_sub_ps( v3, value.v3 ) );
    #else
        return Matrix(
            _11 - value._11, _12 - value._12, _13 - value._13, _14 - value._14,
            _21 - value._21, _22 - value._22, _23 - value._23, _24 - value._24,
            _31 - value._31, _32 - value._32, _33 - value._33, _34 - value._34,
            _41 - value._41, _42 - value._42, _43 - value._43, _44 - value._44 );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator * ( const Matrix& value ) const
    {
    #if S3D_IS_SIMD
        b128 r0 = _mm_set_ps( value._41, value._31, value._21, value._11 );
        b128 r1 = _mm_set_ps( value._42, value._32, value._22, value._12 );
        b128 r2 = _mm_set_ps( value._43, value._33, value._23, value._13 );
        b128 r3 = _mm_set_ps( value._44, value._34, value._24, value._14 );

        Vector4 m0 = _mm_mul_ps( v0, r0 );
        Vector4 m1 = _mm_mul_ps( v0, r1 );
        Vector4 m2 = _mm_mul_ps( v0, r2 );
        Vector4 m3 = _mm_mul_ps( v0, r3 );

        b128 e0 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        m0 = _mm_mul_ps( v1, r0 );
        m1 = _mm_mul_ps( v1, r1 );
        m2 = _mm_mul_ps( v1, r2 );
        m3 = _mm_mul_ps( v1, r3 );

        b128 e1 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        m0 = _mm_mul_ps( v2, r0 );
        m1 = _mm_mul_ps( v2, r1 );
        m2 = _mm_mul_ps( v2, r2 );
        m3 = _mm_mul_ps( v2, r3 );

        b128 e2 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        m0 = _mm_mul_ps( v3, r0 );
        m1 = _mm_mul_ps( v3, r1 );
        m2 = _mm_mul_ps( v3, r2 );
        m3 = _mm_mul_ps( v3, r3 );

        b128 e3 = _mm_set_ps(
            m3.x + m3.y + m3.z + m3.w,
            m2.x + m2.y + m2.z + m2.w,
            m1.x + m1.y + m1.z + m1.w,
            m0.x + m0.y + m0.z + m0.w );

        return Matrix( e0, e1, e2, e3 );
    #else
        return Matrix(
                ( _11 * value._11 ) + ( _12 * value._21 ) + ( _13 * value._31 ) + ( _14 * value._41 ),
                ( _11 * value._12 ) + ( _12 * value._22 ) + ( _13 * value._32 ) + ( _14 * value._42 ),
                ( _11 * value._13 ) + ( _12 * value._23 ) + ( _13 * value._33 ) + ( _14 * value._43 ),
                ( _11 * value._14 ) + ( _12 * value._24 ) + ( _13 * value._34 ) + ( _14 * value._44 ),

                ( _21 * value._11 ) + ( _22 * value._21 ) + ( _23 * value._31 ) + ( _24 * value._41 ),
                ( _21 * value._12 ) + ( _22 * value._22 ) + ( _23 * value._32 ) + ( _24 * value._42 ),
                ( _21 * value._13 ) + ( _22 * value._23 ) + ( _23 * value._33 ) + ( _24 * value._43 ),
                ( _21 * value._14 ) + ( _22 * value._24 ) + ( _23 * value._34 ) + ( _24 * value._44 ),

                ( _31 * value._11 ) + ( _32 * value._21 ) + ( _33 * value._31 ) + ( _34 * value._41 ),
                ( _31 * value._12 ) + ( _32 * value._22 ) + ( _33 * value._32 ) + ( _34 * value._42 ),
                ( _31 * value._13 ) + ( _32 * value._23 ) + ( _33 * value._33 ) + ( _34 * value._43 ),
                ( _31 * value._14 ) + ( _32 * value._24 ) + ( _33 * value._34 ) + ( _34 * value._44 ),

                ( _41 * value._11 ) + ( _42 * value._21 ) + ( _43 * value._31 ) + ( _44 * value._41 ),
                ( _41 * value._12 ) + ( _42 * value._22 ) + ( _43 * value._32 ) + ( _44 * value._42 ),
                ( _41 * value._13 ) + ( _42 * value._23 ) + ( _43 * value._33 ) + ( _44 * value._43 ),
                ( _41 * value._14 ) + ( _42 * value._24 ) + ( _43 * value._34 ) + ( _44 * value._44 ) );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator * ( const f32 value ) const
    {
    #if S3D_IS_SIMD
        b128 c = _mm_set1_ps( value );
        return Matrix(
            _mm_mul_ps( v0, c ),
            _mm_mul_ps( v1, c ),
            _mm_mul_ps( v2, c ),
            _mm_mul_ps( v3, c ) );
    #else
        return Matrix(
            _11 * value, _12 * value, _13 * value, _14 * value,
            _21 * value, _22 * value, _23 * value, _24 * value,
            _31 * value, _32 * value, _33 * value, _34 * value,
            _41 * value, _42 * value, _43 * value, _44 * value );
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------------
    //! @brief      行列式を計算します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 Det() const
    {
        return (
            ( _11 * _22 * _33 * _44 ) + ( _11 * _23 * _34 * _42 ) +
            ( _11 * _24 * _32 * _43 ) + ( _12 * _21 * _34 * _43 ) +
            ( _12 * _23 * _31 * _44 ) + ( _12 * _24 * _33 * _41 ) +
            ( _13 * _21 * _32 * _44 ) + ( _13 * _22 * _34 * _41 ) +
            ( _13 * _24 * _31 * _42 ) + ( _14 * _21 * _33 * _42 ) +
            ( _14 * _22 * _31 * _43 ) + ( _14 * _23 * _32 * _41 ) -
            ( _11 * _22 * _34 * _43 ) - ( _11 * _23 * _32 * _44 ) -
            ( _11 * _24 * _33 * _42 ) - ( _12 * _21 * _33 * _44 ) -
            ( _12 * _23 * _34 * _41 ) - ( _12 * _24 * _31 * _43 ) -
            ( _13 * _21 * _34 * _42 ) - ( _13 * _22 * _31 * _44 ) -
            ( _13 * _24 * _32 * _41 ) - ( _14 * _21 * _32 * _43 ) -
            ( _14 * _22 * _33 * _41 ) - ( _14 * _23 * _31 * _42 )
        );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      逆行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Invert( const Matrix& value )
    {
        Matrix result;
        register f32 det = value.Det();

        result._11 = ( value._22 * value._33 * value._44 ) + ( value._23 * value._34 * value._42 ) + ( value._24 * value._32 * value._43 )
                   - ( value._22 * value._34 * value._43 ) - ( value._23 * value._32 * value._44 ) - ( value._24 * value._33 * value._42 ) / det;
        result._12 = ( value._12 * value._34 * value._43 ) + ( value._13 * value._32 * value._44 ) + ( value._14 * value._33 * value._42 )
                   - ( value._12 * value._33 * value._44 ) - ( value._13 * value._34 * value._42 ) - ( value._14 * value._32 * value._43 ) / det;
        result._13 = ( value._12 * value._23 * value._44 ) + ( value._13 * value._24 * value._42 ) + ( value._14 * value._22 * value._43 )
                   - ( value._12 * value._24 * value._43 ) - ( value._13 * value._22 * value._44 ) - ( value._14 * value._23 * value._42 ) / det;
        result._14 = ( value._12 * value._24 * value._33 ) + ( value._13 * value._22 * value._34 ) + ( value._14 * value._23 * value._32 )
                   - ( value._12 * value._23 * value._34 ) - ( value._13 * value._24 * value._32 ) - ( value._14 * value._22 * value._33 ) / det;

        result._21 = ( value._21 * value._34 * value._43 ) + ( value._23 * value._31 * value._44 ) + ( value._24 * value._33 * value._41 )
                   - ( value._21 * value._33 * value._44 ) - ( value._23 * value._34 * value._41 ) - ( value._24 * value._31 * value._43 ) / det;
        result._22 = ( value._11 * value._33 * value._44 ) + ( value._13 * value._34 * value._41 ) + ( value._14 * value._31 * value._43 )
                   - ( value._11 * value._34 * value._43 ) - ( value._13 * value._31 * value._44 ) - ( value._14 * value._33 * value._41 ) / det;
        result._23 = ( value._11 * value._24 * value._43 ) + ( value._13 * value._21 * value._44 ) + ( value._14 * value._23 * value._41 )
                   - ( value._11 * value._23 * value._44 ) - ( value._13 * value._24 * value._41 ) - ( value._14 * value._21 * value._43 ) / det;
        result._24 = ( value._11 * value._23 * value._34 ) + ( value._13 * value._24 * value._31 ) + ( value._14 * value._21 * value._33 )
                   - ( value._11 * value._24 * value._33 ) - ( value._13 * value._21 * value._34 ) - ( value._14 * value._23 * value._31 ) / det;

        result._31 = ( value._21 * value._32 * value._44 ) + ( value._22 * value._34 * value._41 ) + ( value._24 * value._31 * value._42 )
                   - ( value._21 * value._34 * value._42 ) - ( value._22 * value._31 * value._44 ) - ( value._24 * value._32 * value._41 ) / det;
        result._32 = ( value._11 * value._34 * value._42 ) + ( value._12 * value._31 * value._44 ) + ( value._14 * value._32 * value._41 )
                   - ( value._11 * value._32 * value._44 ) - ( value._12 * value._34 * value._41 ) - ( value._14 * value._31 * value._42 ) / det;
        result._33 = ( value._11 * value._22 * value._44 ) + ( value._12 * value._24 * value._41 ) + ( value._14 * value._21 * value._42 )
                   - ( value._11 * value._24 * value._42 ) - ( value._12 * value._21 * value._44 ) - ( value._14 * value._22 * value._41 ) / det;
        result._34 = ( value._11 * value._24 * value._32 ) + ( value._12 * value._21 * value._34 ) + ( value._14 * value._22 * value._31 )
                   - ( value._11 * value._22 * value._34 ) - ( value._12 * value._24 * value._31 ) - ( value._14 * value._21 * value._32 ) / det;

        result._41 = ( value._21 * value._33 * value._42 ) + ( value._22 * value._31 * value._43 ) + ( value._23 * value._32 * value._41 )
                   - ( value._21 * value._32 * value._43 ) - ( value._22 * value._33 * value._41 ) - ( value._23 * value._31 * value._42 ) / det;
        result._42 = ( value._11 * value._32 * value._43 ) + ( value._12 * value._33 * value._41 ) + ( value._13 * value._31 * value._42 )
                   - ( value._11 * value._33 * value._42 ) - ( value._12 * value._31 * value._43 ) - ( value._13 * value._32 * value._41 ) / det;
        result._43 = ( value._11 * value._23 * value._42 ) + ( value._12 * value._21 * value._43 ) + ( value._13 * value._22 * value._41 )
                   - ( value._11 * value._22 * value._43 ) - ( value._12 * value._23 * value._41 ) - ( value._13 * value._21 * value._42 ) / det;
        result._44 = ( value._11 * value._22 * value._33 ) + ( value._12 * value._23 * value._31 ) + ( value._13 * value._21 * value._32 )
                   - ( value._11 * value._23 * value._32 ) - ( value._12 * value._21 * value._33 ) - ( value._13 * value._22 * value._31 ) / det;

        return result;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      転置行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Transpose ( const Matrix& value )
    {
        return Matrix(
            value._11, value._21, value._31, value._41,
            value._12, value._22, value._32, value._42,
            value._13, value._23, value._33, value._43,
            value._14, value._24, value._34, value._44 );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      単位行列を返却します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Identity()
    {
        return Matrix(
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      平行移動行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Translate( const f32 x, const f32 y, const f32 z )
    {
        return Matrix(
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            x,    y,    z,    1.0f );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      拡大縮小行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Scale( const f32 x, const f32 y, const f32 z )
    {
        return Matrix(
            x,    0.0f, 0.0f, 0.0f,
            0.0f, y,    0.0f, 0.0f,
            0.0f, 0.0f, z,    0.0f,
            0.0f, 0.0f, 0.0f, 1.0f );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      X軸周りの回転行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateX( const f32 rad )
    {
        register f32 cosRad = cosf( rad );
        register f32 sinRad = sinf( rad );
        return Matrix(
            1.0f,    0.0f,   0.0f, 0.0f,
            0.0f,  cosRad, sinRad, 0.0f,
            0.0f, -sinRad, cosRad, 0.0f,
            0.0f,    0.0f,   0.0f, 1.0f );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      Y軸周りの回転行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateY( const f32 rad )
    {
        register f32 cosRad = cosf( rad );
        register f32 sinRad = sinf( rad );
        return Matrix(
            cosRad,  0.0f, -sinRad, 0.0f,
            0.0f,    1.0f,    0.0f, 0.0f,
            sinRad,  0.0f,  cosRad, 0.0f,
            0.0f,    0.0f,    0.0f, 1.0f );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      Z軸周りの回転行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateZ( const f32 rad )
    {
        register f32 cosRad = cosf( rad );
        register f32 sinRad = sinf( rad );
        return Matrix(
            cosRad, sinRad, 0.0f, 0.0f,
            sinRad, cosRad, 0.0f, 0.0f,
            0.0f,     0.0f, 1.0f, 0.0f,
            0.0f,     0.0f, 0.0f, 1.0f );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      任意軸周りの回転行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Rotate( const f32 x, const f32 y, const f32 z, const f32 rad )
    {
        Matrix result;

        register f32 sinRad = sinf(rad);
        register f32 cosRad = cosf(rad);
        register f32 a = 1.0f -cosRad;
    
        register f32 ab = x * y * a;
        register f32 bc = y * z * a;
        register f32 ca = z * x * a;
        register f32 tx = x * x;
        register f32 ty = y * y;
        register f32 tz = z * z;

        result._11 = tx + cosRad * (1.0f - tx);
        result._12 = ab + z * sinRad;
        result._13 = ca - y * sinRad;
        result._14 = 0.0f;

        result._21 = ab - z * sinRad;
        result._22 = ty + cosRad * (1.0f - ty);
        result._23 = bc + x * sinRad;
        result._24 = 0.0f;

        result._31 = ca + y * sinRad;
        result._32 = bc - x * sinRad;
        result._33 = tz + cosRad * (1.0f - tz);
        result._34 = 0.0f;

        result._41 = 0.0f;
        result._42 = 0.0f;
        result._43 = 0.0f;
        result._44 = 1.0f;

        return result;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      ビュー行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix LookAt( const Vector3& position, const Vector3& target, const Vector3& upward )
    {
        Vector3 zaxis = Vector3::UnitVector( target - position );
        Vector3 xaxis = Vector3::UnitVector( Vector3::Cross( upward, zaxis ) );
        Vector3 yaxis = Vector3::UnitVector( Vector3::Cross( zaxis, xaxis ) );

        return Matrix(
            xaxis.x, yaxis.x, zaxis.x, 0.0f,
            xaxis.y, yaxis.y, zaxis.y, 0.0f,
            xaxis.z, yaxis.z, zaxis.z, 0.0f,

            -Vector3::Dot( xaxis, position ),
            -Vector3::Dot( yaxis, position ),
            -Vector3::Dot( zaxis, position ),
            1.0 );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      透視投影行列を求めます.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix PersFov( const f32 fieldOfView, const f32 aspectRatio, const f32 nearClip, const f32 farClip )
    {
        register f32 diff = farClip - nearClip;
        register f32 yScale = 1.0f / tanf( fieldOfView * 0.5f );
        register f32 xScale = yScale / aspectRatio;

        Matrix result;
        result._11 = xScale;
        result._12 = 0.0f;
        result._13 = 0.0f;
        result._14 = 0.0f;

        result._21 = 0.0f;
        result._22 = yScale;
        result._23 = 0.0f;
        result._24 = 0.0f;

        result._31 = 0.0f;
        result._32 = 0.0f;
        result._33 = farClip / diff;
        result._34 = -1.0f;

        result._41 = 0.0f;
        result._42 = 0.0f;
        result._43 = - (nearClip * farClip) / diff;
        result._44 = 0.0f;

        return result;
    }
};


/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox structure
/////////////////////////////////////////////////////////////////////////////////////
struct BoundingBox
{
public:
    Vector3 mini;        //!< 最小値です.
    Vector3 maxi;        //!< 最大値です.
    bool    isEmpty;

    //-------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox()
    : mini(  F_MAX,  F_MAX,  F_MAX )
    , maxi( -F_MAX, -F_MAX, -F_MAX )
    , isEmpty( true )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const Vector3& value )
    : mini( value )
    , maxi( value )
    , isEmpty( false )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const Vector3& _mini, const Vector3& _maxi )
    : mini( _mini )
    , maxi( _maxi )
    , isEmpty( false )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const BoundingBox& value )
    : mini( value.mini )
    , maxi( value.maxi )
    , isEmpty( value.isEmpty )
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    bool IsHit( const Ray& ray ) const
    {
        if ( isEmpty )
        { return true; }

        const Vector3* v[ 2 ] = { &mini, &maxi };
        f64 intervalMin = F_HIT_MIN;
        f64 intervalMax = F_HIT_MAX;

        s32 idx0, idx1;
        f64 t0, t1;

        // X軸方向.
        idx0 = ray.sign[ 0 ];
        idx1 = 1 - idx0;
        t0 = ( v[ idx0 ]->x - ray.pos.x ) * ray.invDir.x;
        t1 = ( v[ idx1 ]->x - ray.pos.x ) * ray.invDir.x;
        intervalMin = ( t0 > intervalMin ) ? t0 : intervalMin;
        intervalMax = ( t1 < intervalMax ) ? t1 : intervalMax;
        if ( intervalMin > intervalMax )
        { return false; }

        // Y軸方向.
        idx0 = ray.sign[ 1 ];
        idx1 = 1 - idx0;
        t0 = ( v[ idx0 ]->y - ray.pos.y ) * ray.invDir.y;
        t1 = ( v[ idx1 ]->y - ray.pos.y ) * ray.invDir.y;
        intervalMin = ( t0 > intervalMin ) ? t0 : intervalMin;
        intervalMax = ( t1 < intervalMax ) ? t1 : intervalMax;
        if ( intervalMin > intervalMax )
        { return false; }

        // Z軸方向.
        idx0 = ray.sign[ 2 ];
        idx1 = 1 - idx0;
        t0 = ( v[ idx0 ]->z - ray.pos.z ) * ray.invDir.z;
        t1 = ( v[ idx1 ]->z - ray.pos.z ) * ray.invDir.z;
        intervalMin = ( t0 > intervalMin ) ? t0 : intervalMin;
        intervalMax = ( t1 < intervalMax ) ? t1 : intervalMax;
        if ( intervalMin > intervalMax )
        { return false; }

        return true;
    }

    //-------------------------------------------------------------------------------
    //! @brief      2つのバウンディングボックスをマージします.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Merge( const BoundingBox& a, const BoundingBox& b )
    {
        if ( !a.isEmpty && !b.isEmpty )
        {
            Vector3 mini = Vector3::Min( a.mini, b.mini );
            Vector3 maxi = Vector3::Max( a.maxi, b.maxi );

            return BoundingBox( mini, maxi );
        }
        else if ( a.isEmpty && !b.isEmpty )
        { return b; }
        else if ( !a.isEmpty && b.isEmpty )
        { return a; }

        return a;
    }

    //-------------------------------------------------------------------------------
    //! @brief      バウンディングボックスと点をマージします.
    //-------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Merge( const BoundingBox& box, const Vector3& p )
    {
        if ( !box.isEmpty )
        {
            Vector3 mini = Vector3::Min( box.mini, p );
            Vector3 maxi = Vector3::Max( box.maxi, p );

            return BoundingBox( mini, maxi );
        }
        return BoundingBox( p );
    }
};


/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox4 structure
/////////////////////////////////////////////////////////////////////////////////////
struct BoundingBox4
{
public:
    b128 value[2][3];       // 最大・最小値です( 0:min, 1:max ).

    //--------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4()
    {
    #if S3D_IS_SIMD
        value[0][0] = _mm_set1_ps( F_MAX );
        value[0][1] = _mm_set1_ps( F_MAX );
        value[0][2] = _mm_set1_ps( F_MAX );

        value[1][0] = _mm_set1_ps( F_MIN );
        value[1][1] = _mm_set1_ps( F_MIN );
        value[1][2] = _mm_set1_ps( F_MIN );
    #else
        value[0][0].m128_f32[0] = F_MAX;    // Empty
        value[0][0].m128_f32[1] = F_MAX;    // Empty
        value[0][0].m128_f32[2] = F_MAX;    // Empty
        value[0][0].m128_f32[3] = F_MAX;    // Empty

        value[0][1].m128_f32[0] = F_MAX;    // Empty
        value[0][1].m128_f32[1] = F_MAX;    // Empty
        value[0][1].m128_f32[2] = F_MAX;    // Empty
        value[0][1].m128_f32[3] = F_MAX;    // Empty

        value[0][2].m128_f32[0] = F_MAX;    // Empty
        value[0][2].m128_f32[1] = F_MAX;    // Empty
        value[0][2].m128_f32[2] = F_MAX;    // Empty
        value[0][2].m128_f32[3] = F_MAX;    // Empty


        value[1][0].m128_f32[0] = F_MIN;    // Empty
        value[1][0].m128_f32[1] = F_MIN;    // Empty
        value[1][0].m128_f32[2] = F_MIN;    // Empty
        value[1][0].m128_f32[3] = F_MIN;    // Empty

        value[1][1].m128_f32[0] = F_MIN;    // Empty
        value[1][1].m128_f32[1] = F_MIN;    // Empty
        value[1][1].m128_f32[2] = F_MIN;    // Empty
        value[1][1].m128_f32[3] = F_MIN;    // Empty

        value[1][2].m128_f32[0] = F_MIN;    // Empty
        value[1][2].m128_f32[1] = F_MIN;    // Empty
        value[1][2].m128_f32[2] = F_MIN;    // Empty
        value[1][2].m128_f32[3] = F_MIN;    // Empty
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4
    (
        const BoundingBox& box0,
        const BoundingBox& box1,
        const BoundingBox& box2,
        const BoundingBox& box3
    )
    {
    #if S3D_IS_SIMD
        value[0][0] = _mm_set_ps( box3.mini.x, box2.mini.x, box1.mini.x, box0.mini.x );
        value[0][1] = _mm_set_ps( box3.mini.y, box2.mini.y, box1.mini.y, box0.mini.y );
        value[0][2] = _mm_set_ps( box3.mini.z, box2.mini.z, box1.mini.z, box0.mini.z );

        value[1][0] = _mm_set_ps( box3.maxi.x, box2.maxi.x, box1.maxi.x, box0.maxi.x );
        value[1][1] = _mm_set_ps( box3.maxi.y, box2.maxi.y, box1.maxi.y, box0.maxi.y );
        value[1][2] = _mm_set_ps( box3.maxi.z, box2.maxi.z, box1.maxi.z, box0.maxi.z );
    #else
        value[0][0].m128_f32[0] = box0.mini.x;
        value[0][0].m128_f32[1] = box1.mini.x;
        value[0][0].m128_f32[2] = box2.mini.x;
        value[0][0].m128_f32[3] = box3.mini.x;

        value[0][1].m128_f32[0] = box0.mini.y;
        value[0][1].m128_f32[1] = box1.mini.y;
        value[0][1].m128_f32[2] = box2.mini.y;
        value[0][1].m128_f32[3] = box3.mini.y;

        value[0][2].m128_f32[0] = box0.mini.z;
        value[0][2].m128_f32[1] = box1.mini.z;
        value[0][2].m128_f32[2] = box2.mini.z;
        value[0][2].m128_f32[3] = box3.mini.z;


        value[1][0].m128_f32[0] = box0.maxi.x;
        value[1][0].m128_f32[1] = box1.maxi.x;
        value[1][0].m128_f32[2] = box2.maxi.x;
        value[1][0].m128_f32[3] = box3.maxi.x;

        value[1][1].m128_f32[0] = box0.maxi.y;
        value[1][1].m128_f32[1] = box1.maxi.y;
        value[1][1].m128_f32[2] = box2.maxi.y;
        value[1][1].m128_f32[3] = box3.maxi.y;

        value[1][2].m128_f32[0] = box0.maxi.z;
        value[1][2].m128_f32[1] = box1.maxi.z;
        value[1][2].m128_f32[2] = box2.maxi.z;
        value[1][2].m128_f32[3] = box3.maxi.z;
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4( const BoundingBox* box )
    {
    #if S3D_IS_SIMD
        value[0][0] = _mm_set_ps( box[3].mini.x, box[2].mini.x, box[1].mini.x, box[0].mini.x );
        value[0][1] = _mm_set_ps( box[3].mini.y, box[2].mini.y, box[1].mini.y, box[0].mini.y );
        value[0][2] = _mm_set_ps( box[3].mini.z, box[2].mini.z, box[1].mini.z, box[0].mini.z );

        value[1][0] = _mm_set_ps( box[3].maxi.x, box[2].maxi.x, box[1].maxi.x, box[0].maxi.x );
        value[1][1] = _mm_set_ps( box[3].maxi.y, box[2].maxi.y, box[1].maxi.y, box[0].maxi.y );
        value[1][2] = _mm_set_ps( box[3].maxi.z, box[2].maxi.z, box[1].maxi.z, box[0].maxi.z );
    #else
        value[0][0].m128_f32[0] = box[0].mini.x;
        value[0][0].m128_f32[1] = box[1].mini.x;
        value[0][0].m128_f32[2] = box[2].mini.x;
        value[0][0].m128_f32[3] = box[3].mini.x;

        value[0][1].m128_f32[0] = box[0].mini.y;
        value[0][1].m128_f32[1] = box[1].mini.y;
        value[0][1].m128_f32[2] = box[2].mini.y;
        value[0][1].m128_f32[3] = box[3].mini.y;

        value[0][2].m128_f32[0] = box[0].mini.z;
        value[0][2].m128_f32[1] = box[1].mini.z;
        value[0][2].m128_f32[2] = box[2].mini.z;
        value[0][2].m128_f32[3] = box[3].mini.z;


        value[1][0].m128_f32[0] = box[0].maxi.x;
        value[1][0].m128_f32[1] = box[1].maxi.x;
        value[1][0].m128_f32[2] = box[2].maxi.x;
        value[1][0].m128_f32[3] = box[3].maxi.x;

        value[1][1].m128_f32[0] = box[0].maxi.y;
        value[1][1].m128_f32[1] = box[1].maxi.y;
        value[1][1].m128_f32[2] = box[2].maxi.y;
        value[1][1].m128_f32[3] = box[3].maxi.y;

        value[1][2].m128_f32[0] = box[0].maxi.z;
        value[1][2].m128_f32[1] = box[1].maxi.z;
        value[1][2].m128_f32[2] = box[2].maxi.z;
        value[1][2].m128_f32[3] = box[3].maxi.z;
    #endif//S3D_IS_SIMD
    }

    //--------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4
    (
        const b128& miniX,
        const b128& miniY,
        const b128& miniZ,

        const b128& maxiX,
        const b128& maxiY,
        const b128& maxiZ
    )
    {
        value[0][0] = miniX;
        value[0][1] = miniY;
        value[0][2] = miniZ;

        value[1][0] = maxiX;
        value[1][1] = maxiY;
        value[1][2] = maxiZ;
    }

    //--------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    bool IsHit( const Ray4& ray, s32& mask ) const
    {
    #if S3D_IS_SIMD
        b128 tmin = _mm_set1_ps( F_HIT_MIN );
        b128 tmax = _mm_set1_ps( F_HIT_MAX );

        s32 idx0, idx1;

        // X軸.
        idx0 = ray.sign[ 0 ];
        idx1 = 1 - idx0;
        tmin = _mm_max_ps( tmin, _mm_mul_ps( _mm_sub_ps( value[ idx0 ][ 0 ], ray.pos[ 0 ] ), ray.invDir[ 0 ] ) );
        tmax = _mm_min_ps( tmax, _mm_mul_ps( _mm_sub_ps( value[ idx1 ][ 0 ], ray.pos[ 0 ] ), ray.invDir[ 0 ] ) );

        // Y軸.
        idx0 = ray.sign[ 1 ];
        idx1 = 1 - idx0;
        tmin = _mm_max_ps( tmin, _mm_mul_ps( _mm_sub_ps( value[ idx0 ][ 1 ], ray.pos[ 1 ] ), ray.invDir[ 1 ] ) );
        tmax = _mm_min_ps( tmax, _mm_mul_ps( _mm_sub_ps( value[ idx1 ][ 1 ], ray.pos[ 1 ] ), ray.invDir[ 1 ] ) );

        // Z軸.
        idx0 = ray.sign[ 2 ];
        idx1 = 1 - idx0;
        tmin = _mm_max_ps( tmin, _mm_mul_ps( _mm_sub_ps( value[ idx0 ][ 2 ], ray.pos[ 2 ] ), ray.invDir[ 2 ] ) );
        tmax = _mm_min_ps( tmax, _mm_mul_ps( _mm_sub_ps( value[ idx1 ][ 2 ], ray.pos[ 2 ] ), ray.invDir[ 2 ] ) );

        mask = _mm_movemask_ps( _mm_cmpge_ps( tmax, tmin ) );
        return ( mask > 0 );
    #else
        b128 tmin = { F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN };
        b128 tmax = { F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX };

        s32 idx0, idx1;

        // X軸
        idx0 = ray.sign[ 0 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<4; ++i )
        {
            tmin.m128_f32[ i ] = s3d::Max( tmin.m128_f32[ i ], ( value[ idx0 ][ 0 ].m128_f32[ i ] - ray.pos[ 0 ].m128_f32[ i ] ) * ray.invDir[ 0 ].m128_f32[ i ] );
            tmax.m128_f32[ i ] = s3d::Min( tmax.m128_f32[ i ], ( value[ idx1 ][ 0 ].m128_f32[ i ] - ray.pos[ 0 ].m128_f32[ i ] ) * ray.invDir[ 0 ].m128_f32[ i ] );
        }

        // Y軸
        idx0 = ray.sign[ 1 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<4; ++i )
        {
            tmin.m128_f32[ i ] = s3d::Max( tmin.m128_f32[ i ], ( value[ idx0 ][ 1 ].m128_f32[ i ] - ray.pos[ 1 ].m128_f32[ i ] ) * ray.invDir[ 1 ].m128_f32[ i ] );
            tmax.m128_f32[ i ] = s3d::Min( tmax.m128_f32[ i ], ( value[ idx1 ][ 1 ].m128_f32[ i ] - ray.pos[ 1 ].m128_f32[ i ] ) * ray.invDir[ 1 ].m128_f32[ i ] );
        }

        // Z軸
        idx0 = ray.sign[ 2 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<4; ++i )
        {
            tmin.m128_f32[ i ] = s3d::Max( tmin.m128_f32[ i ], ( value[ idx0 ][ 2 ].m128_f32[ i ] - ray.pos[ 2 ].m128_f32[ i ] ) * ray.invDir[ 2 ].m128_f32[ i ] );
            tmax.m128_f32[ i ] = s3d::Min( tmax.m128_f32[ i ], ( value[ idx1 ][ 2 ].m128_f32[ i ] - ray.pos[ 2 ].m128_f32[ i ] ) * ray.invDir[ 2 ].m128_f32[ i ] );
        }

        b128 flg;
        flg.m128_u32[0] = ( tmax.m128_f32[ 0 ] >= tmin.m128_f32[ 0 ] ) ? 0xffffffff : 0x0;
        flg.m128_u32[1] = ( tmax.m128_f32[ 1 ] >= tmin.m128_f32[ 1 ] ) ? 0xffffffff : 0x0;
        flg.m128_u32[2] = ( tmax.m128_f32[ 2 ] >= tmin.m128_f32[ 2 ] ) ? 0xffffffff : 0x0;
        flg.m128_u32[3] = ( tmax.m128_f32[ 3 ] >= tmin.m128_f32[ 3 ] ) ? 0xffffffff : 0x0;

        mask = ( Sign(flg.m128_u32[3]) << 3 | Sign(flg.m128_u32[2]) << 2 | Sign(flg.m128_u32[1]) << 1 | Sign(flg.m128_u32[0]) );
        return ( mask > 0 );
    #endif
    }

    //--------------------------------------------------------------------------------
    //! @brief      バウンディングボックスを取得します.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox GetBox() const
    {
        Vector3 tmin( value[0][0].m128_f32[0], value[0][1].m128_f32[0], value[0][2].m128_f32[0] );
        Vector3 tmax( value[1][0].m128_f32[0], value[1][1].m128_f32[0], value[1][2].m128_f32[0] );

        for( u32 i=1; i<4; ++i )
        {
            tmin = Vector3::Min( tmin, Vector3( value[0][0].m128_f32[i], value[0][1].m128_f32[i], value[0][2].m128_f32[i] ) );
            tmax = Vector3::Max( tmax, Vector3( value[1][0].m128_f32[i], value[1][1].m128_f32[i], value[1][2].m128_f32[i] ) );
        }

        return BoundingBox( tmin, tmax );
    }

    //--------------------------------------------------------------------------------
    //! @brief      2つの4バウンディングボックスをマージします.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox4 Merge( const BoundingBox4& a, const BoundingBox4& b )
    {
    #if S3D_IS_SIMD
        b128 miniX = _mm_min_ps( a.value[0][0], b.value[0][0] );
        b128 miniY = _mm_min_ps( a.value[0][1], b.value[0][1] );
        b128 miniZ = _mm_min_ps( a.value[0][2], b.value[0][2] );

        b128 maxiX = _mm_max_ps( a.value[1][0], b.value[1][0] );
        b128 maxiY = _mm_max_ps( a.value[1][1], b.value[1][1] );
        b128 maxiZ = _mm_max_ps( a.value[1][2], b.value[1][2] );

        return BoundingBox4( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
    #else
        b128 miniX = { 
            ( a.value[0][0].m128_f32[0] < b.value[0][0].m128_f32[0] ) ? a.value[0][0].m128_f32[0] : b.value[0][0].m128_f32[0],
            ( a.value[0][0].m128_f32[1] < b.value[0][0].m128_f32[1] ) ? a.value[0][0].m128_f32[1] : b.value[0][0].m128_f32[1],
            ( a.value[0][0].m128_f32[2] < b.value[0][0].m128_f32[2] ) ? a.value[0][0].m128_f32[2] : b.value[0][0].m128_f32[2],
            ( a.value[0][0].m128_f32[3] < b.value[0][0].m128_f32[3] ) ? a.value[0][0].m128_f32[3] : b.value[0][0].m128_f32[3]
        };
        b128 miniY = { 
            ( a.value[0][1].m128_f32[0] < b.value[0][1].m128_f32[0] ) ? a.value[0][1].m128_f32[0] : b.value[0][1].m128_f32[0],
            ( a.value[0][1].m128_f32[1] < b.value[0][1].m128_f32[1] ) ? a.value[0][1].m128_f32[1] : b.value[0][1].m128_f32[1],
            ( a.value[0][1].m128_f32[2] < b.value[0][1].m128_f32[2] ) ? a.value[0][1].m128_f32[2] : b.value[0][1].m128_f32[2],
            ( a.value[0][1].m128_f32[3] < b.value[0][1].m128_f32[3] ) ? a.value[0][1].m128_f32[3] : b.value[0][1].m128_f32[3]
        };
        b128 miniZ = { 
            ( a.value[0][2].m128_f32[0] < b.value[0][2].m128_f32[0] ) ? a.value[0][2].m128_f32[0] : b.value[0][2].m128_f32[0],
            ( a.value[0][2].m128_f32[1] < b.value[0][2].m128_f32[1] ) ? a.value[0][2].m128_f32[1] : b.value[0][2].m128_f32[1],
            ( a.value[0][2].m128_f32[2] < b.value[0][2].m128_f32[2] ) ? a.value[0][2].m128_f32[2] : b.value[0][2].m128_f32[2],
            ( a.value[0][2].m128_f32[3] < b.value[0][2].m128_f32[3] ) ? a.value[0][2].m128_f32[3] : b.value[0][2].m128_f32[3]
        };

        b128 maxiX = { 
            ( a.value[1][0].m128_f32[0] > b.value[1][0].m128_f32[0] ) ? a.value[1][0].m128_f32[0] : b.value[1][0].m128_f32[0],
            ( a.value[1][0].m128_f32[1] > b.value[1][0].m128_f32[1] ) ? a.value[1][0].m128_f32[1] : b.value[1][0].m128_f32[1],
            ( a.value[1][0].m128_f32[2] > b.value[1][0].m128_f32[2] ) ? a.value[1][0].m128_f32[2] : b.value[1][0].m128_f32[2],
            ( a.value[1][0].m128_f32[3] > b.value[1][0].m128_f32[3] ) ? a.value[1][0].m128_f32[3] : b.value[1][0].m128_f32[3]
        };
        b128 maxiY = { 
            ( a.value[1][1].m128_f32[0] > b.value[1][1].m128_f32[0] ) ? a.value[1][1].m128_f32[0] : b.value[1][1].m128_f32[0],
            ( a.value[1][1].m128_f32[1] > b.value[1][1].m128_f32[1] ) ? a.value[1][1].m128_f32[1] : b.value[1][1].m128_f32[1],
            ( a.value[1][1].m128_f32[2] > b.value[1][1].m128_f32[2] ) ? a.value[1][1].m128_f32[2] : b.value[1][1].m128_f32[2],
            ( a.value[1][1].m128_f32[3] > b.value[1][1].m128_f32[3] ) ? a.value[1][1].m128_f32[3] : b.value[1][1].m128_f32[3]
        };
        b128 maxiZ = { 
            ( a.value[1][2].m128_f32[0] > b.value[1][2].m128_f32[0] ) ? a.value[1][2].m128_f32[0] : b.value[1][2].m128_f32[0],
            ( a.value[1][2].m128_f32[1] > b.value[1][2].m128_f32[1] ) ? a.value[1][2].m128_f32[1] : b.value[1][2].m128_f32[1],
            ( a.value[1][2].m128_f32[2] > b.value[1][2].m128_f32[2] ) ? a.value[1][2].m128_f32[2] : b.value[1][2].m128_f32[2],
            ( a.value[1][2].m128_f32[3] > b.value[1][2].m128_f32[3] ) ? a.value[1][2].m128_f32[3] : b.value[1][2].m128_f32[3]
        };

        return BoundingBox4( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
#endif//S3D_IS_SIMD
    }
};


/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox8 structure
/////////////////////////////////////////////////////////////////////////////////////
struct BoundingBox8
{
public:
    b256 value[2][3];       // 最大・最小値です( 0:min, 1:max ).

    //--------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8()
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        value[0][0] = _mm256_set1_ps( F_MAX );
        value[0][1] = _mm256_set1_ps( F_MAX );
        value[0][2] = _mm256_set1_ps( F_MAX );

        value[1][0] = _mm256_set1_ps( F_MIN );
        value[1][1] = _mm256_set1_ps( F_MIN );
        value[1][2] = _mm256_set1_ps( F_MIN );
    #else
        value[0][0].m256_f32[0] = F_MAX;    // Empty
        value[0][0].m256_f32[1] = F_MAX;    // Empty
        value[0][0].m256_f32[2] = F_MAX;    // Empty
        value[0][0].m256_f32[3] = F_MAX;    // Empty
        value[0][0].m256_f32[4] = F_MAX;    // Empty
        value[0][0].m256_f32[5] = F_MAX;    // Empty
        value[0][0].m256_f32[6] = F_MAX;    // Empty
        value[0][0].m256_f32[7] = F_MAX;    // Empty

        value[0][1].m256_f32[0] = F_MAX;    // Empty
        value[0][1].m256_f32[1] = F_MAX;    // Empty
        value[0][1].m256_f32[2] = F_MAX;    // Empty
        value[0][1].m256_f32[3] = F_MAX;    // Empty
        value[0][1].m256_f32[4] = F_MAX;    // Empty
        value[0][1].m256_f32[5] = F_MAX;    // Empty
        value[0][1].m256_f32[6] = F_MAX;    // Empty
        value[0][1].m256_f32[7] = F_MAX;    // Empty

        value[0][2].m256_f32[0] = F_MAX;    // Empty
        value[0][2].m256_f32[1] = F_MAX;    // Empty
        value[0][2].m256_f32[2] = F_MAX;    // Empty
        value[0][2].m256_f32[3] = F_MAX;    // Empty
        value[0][2].m256_f32[4] = F_MAX;    // Empty
        value[0][2].m256_f32[5] = F_MAX;    // Empty
        value[0][2].m256_f32[6] = F_MAX;    // Empty
        value[0][2].m256_f32[7] = F_MAX;    // Empty

        value[1][0].m256_f32[0] = F_MIN;    // Empty
        value[1][0].m256_f32[1] = F_MIN;    // Empty
        value[1][0].m256_f32[2] = F_MIN;    // Empty
        value[1][0].m256_f32[3] = F_MIN;    // Empty
        value[1][0].m256_f32[4] = F_MIN;    // Empty
        value[1][0].m256_f32[5] = F_MIN;    // Empty
        value[1][0].m256_f32[6] = F_MIN;    // Empty
        value[1][0].m256_f32[7] = F_MIN;    // Empty

        value[1][1].m256_f32[0] = F_MIN;    // Empty
        value[1][1].m256_f32[1] = F_MIN;    // Empty
        value[1][1].m256_f32[2] = F_MIN;    // Empty
        value[1][1].m256_f32[3] = F_MIN;    // Empty
        value[1][1].m256_f32[4] = F_MIN;    // Empty
        value[1][1].m256_f32[5] = F_MIN;    // Empty
        value[1][1].m256_f32[6] = F_MIN;    // Empty
        value[1][1].m256_f32[7] = F_MIN;    // Empty

        value[1][2].m256_f32[0] = F_MIN;    // Empty
        value[1][2].m256_f32[1] = F_MIN;    // Empty
        value[1][2].m256_f32[2] = F_MIN;    // Empty
        value[1][2].m256_f32[3] = F_MIN;    // Empty
        value[1][2].m256_f32[4] = F_MIN;    // Empty
        value[1][2].m256_f32[5] = F_MIN;    // Empty
        value[1][2].m256_f32[6] = F_MIN;    // Empty
        value[1][2].m256_f32[7] = F_MIN;    // Empty
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8
    (
        const BoundingBox& box0,
        const BoundingBox& box1,
        const BoundingBox& box2,
        const BoundingBox& box3,
        const BoundingBox& box4,
        const BoundingBox& box5,
        const BoundingBox& box6,
        const BoundingBox& box7
    )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        value[0][0] = _mm256_set_ps( box7.mini.x, box6.mini.x, box5.mini.x, box4.mini.x, box3.mini.x, box2.mini.x, box1.mini.x, box0.mini.x );
        value[0][1] = _mm256_set_ps( box7.mini.y, box6.mini.y, box5.mini.y, box4.mini.y, box3.mini.y, box2.mini.y, box1.mini.y, box0.mini.y );
        value[0][2] = _mm256_set_ps( box7.mini.z, box6.mini.z, box5.mini.z, box4.mini.z, box3.mini.z, box2.mini.z, box1.mini.z, box0.mini.z );

        value[1][0] = _mm256_set_ps( box7.maxi.x, box6.maxi.x, box5.maxi.x, box4.maxi.x, box3.maxi.x, box2.maxi.x, box1.maxi.x, box0.maxi.x );
        value[1][1] = _mm256_set_ps( box7.maxi.y, box6.maxi.y, box5.maxi.y, box4.maxi.y, box3.maxi.y, box2.maxi.y, box1.maxi.y, box0.maxi.y );
        value[1][2] = _mm256_set_ps( box7.maxi.z, box6.maxi.z, box5.maxi.z, box4.maxi.z, box3.maxi.z, box2.maxi.z, box1.maxi.z, box0.maxi.z );
    #else
        value[0][0].m256_f32[0] = box0.mini.x;
        value[0][0].m256_f32[1] = box1.mini.x;
        value[0][0].m256_f32[2] = box2.mini.x;
        value[0][0].m256_f32[3] = box3.mini.x;
        value[0][0].m256_f32[4] = box4.mini.x;
        value[0][0].m256_f32[5] = box5.mini.x;
        value[0][0].m256_f32[6] = box6.mini.x;
        value[0][0].m256_f32[7] = box7.mini.x;

        value[0][1].m256_f32[0] = box0.mini.y;
        value[0][1].m256_f32[1] = box1.mini.y;
        value[0][1].m256_f32[2] = box2.mini.y;
        value[0][1].m256_f32[3] = box3.mini.y;
        value[0][1].m256_f32[4] = box4.mini.y;
        value[0][1].m256_f32[5] = box5.mini.y;
        value[0][1].m256_f32[6] = box6.mini.y;
        value[0][1].m256_f32[7] = box7.mini.y;

        value[0][2].m256_f32[0] = box0.mini.z;
        value[0][2].m256_f32[1] = box1.mini.z;
        value[0][2].m256_f32[2] = box2.mini.z;
        value[0][2].m256_f32[3] = box3.mini.z;
        value[0][2].m256_f32[4] = box4.mini.z;
        value[0][2].m256_f32[5] = box5.mini.z;
        value[0][2].m256_f32[6] = box6.mini.z;
        value[0][2].m256_f32[7] = box7.mini.z;

        value[1][0].m256_f32[0] = box0.maxi.x;
        value[1][0].m256_f32[1] = box1.maxi.x;
        value[1][0].m256_f32[2] = box2.maxi.x;
        value[1][0].m256_f32[3] = box3.maxi.x;
        value[1][0].m256_f32[4] = box4.maxi.x;
        value[1][0].m256_f32[5] = box5.maxi.x;
        value[1][0].m256_f32[6] = box6.maxi.x; 
        value[1][0].m256_f32[7] = box7.maxi.x;

        value[1][1].m256_f32[0] = box0.maxi.y;
        value[1][1].m256_f32[1] = box1.maxi.y;
        value[1][1].m256_f32[2] = box2.maxi.y;
        value[1][1].m256_f32[3] = box3.maxi.y;
        value[1][1].m256_f32[4] = box4.maxi.y;
        value[1][1].m256_f32[5] = box5.maxi.y;
        value[1][1].m256_f32[6] = box6.maxi.y;
        value[1][1].m256_f32[7] = box7.maxi.y;

        value[1][2].m256_f32[0] = box0.maxi.z;
        value[1][2].m256_f32[1] = box1.maxi.z;
        value[1][2].m256_f32[2] = box2.maxi.z;
        value[1][2].m256_f32[3] = box3.maxi.z;
        value[1][2].m256_f32[4] = box4.maxi.z;
        value[1][2].m256_f32[5] = box5.maxi.z;
        value[1][2].m256_f32[6] = box6.maxi.z;
        value[1][2].m256_f32[7] = box7.maxi.z;
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8( const BoundingBox* box )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        value[0][0] = _mm256_set_ps( box[7].mini.x, box[6].mini.x, box[5].mini.x, box[4].mini.x, box[3].mini.x, box[2].mini.x, box[1].mini.x, box[0].mini.x );
        value[0][1] = _mm256_set_ps( box[7].mini.y, box[6].mini.y, box[5].mini.y, box[4].mini.y, box[3].mini.y, box[2].mini.y, box[1].mini.y, box[0].mini.y );
        value[0][2] = _mm256_set_ps( box[7].mini.z, box[6].mini.z, box[5].mini.z, box[4].mini.z, box[3].mini.z, box[2].mini.z, box[1].mini.z, box[0].mini.z );

        value[1][0] = _mm256_set_ps( box[7].maxi.x, box[6].maxi.x, box[5].maxi.x, box[4].maxi.x, box[3].maxi.x, box[2].maxi.x, box[1].maxi.x, box[0].maxi.x );
        value[1][1] = _mm256_set_ps( box[7].maxi.y, box[6].maxi.y, box[5].maxi.y, box[4].maxi.y, box[3].maxi.y, box[2].maxi.y, box[1].maxi.y, box[0].maxi.y );
        value[1][2] = _mm256_set_ps( box[7].maxi.z, box[6].maxi.z, box[5].maxi.z, box[4].maxi.z, box[3].maxi.z, box[2].maxi.z, box[1].maxi.z, box[0].maxi.z );
    #else
        value[0][0].m256_f32[0] = box[0].mini.x;
        value[0][0].m256_f32[1] = box[1].mini.x;
        value[0][0].m256_f32[2] = box[2].mini.x;
        value[0][0].m256_f32[3] = box[3].mini.x;
        value[0][0].m256_f32[4] = box[4].mini.x;
        value[0][0].m256_f32[5] = box[5].mini.x;
        value[0][0].m256_f32[6] = box[6].mini.x;
        value[0][0].m256_f32[7] = box[7].mini.x;

        value[0][1].m256_f32[0] = box[0].mini.y;
        value[0][1].m256_f32[1] = box[1].mini.y;
        value[0][1].m256_f32[2] = box[2].mini.y;
        value[0][1].m256_f32[3] = box[3].mini.y;
        value[0][1].m256_f32[4] = box[4].mini.y;
        value[0][1].m256_f32[5] = box[5].mini.y;
        value[0][1].m256_f32[6] = box[6].mini.y;
        value[0][1].m256_f32[7] = box[7].mini.y;

        value[0][2].m256_f32[0] = box[0].mini.z;
        value[0][2].m256_f32[1] = box[1].mini.z;
        value[0][2].m256_f32[2] = box[2].mini.z;
        value[0][2].m256_f32[3] = box[3].mini.z;
        value[0][2].m256_f32[4] = box[4].mini.z;
        value[0][2].m256_f32[5] = box[5].mini.z;
        value[0][2].m256_f32[6] = box[6].mini.z;
        value[0][2].m256_f32[7] = box[7].mini.z;

        value[1][0].m256_f32[0] = box[0].maxi.x;
        value[1][0].m256_f32[1] = box[1].maxi.x;
        value[1][0].m256_f32[2] = box[2].maxi.x;
        value[1][0].m256_f32[3] = box[3].maxi.x;
        value[1][0].m256_f32[4] = box[4].maxi.x;
        value[1][0].m256_f32[5] = box[5].maxi.x;
        value[1][0].m256_f32[6] = box[6].maxi.x; 
        value[1][0].m256_f32[7] = box[7].maxi.x;

        value[1][1].m256_f32[0] = box[0].maxi.y;
        value[1][1].m256_f32[1] = box[1].maxi.y;
        value[1][1].m256_f32[2] = box[2].maxi.y;
        value[1][1].m256_f32[3] = box[3].maxi.y;
        value[1][1].m256_f32[4] = box[4].maxi.y;
        value[1][1].m256_f32[5] = box[5].maxi.y;
        value[1][1].m256_f32[6] = box[6].maxi.y;
        value[1][1].m256_f32[7] = box[7].maxi.y;

        value[1][2].m256_f32[0] = box[0].maxi.z;
        value[1][2].m256_f32[1] = box[1].maxi.z;
        value[1][2].m256_f32[2] = box[2].maxi.z;
        value[1][2].m256_f32[3] = box[3].maxi.z;
        value[1][2].m256_f32[4] = box[4].maxi.z;
        value[1][2].m256_f32[5] = box[5].maxi.z;
        value[1][2].m256_f32[6] = box[6].maxi.z;
        value[1][2].m256_f32[7] = box[7].maxi.z;
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8
    (
        const b256& miniX,
        const b256& miniY,
        const b256& miniZ,

        const b256& maxiX,
        const b256& maxiY,
        const b256& maxiZ
    )
    {
        value[0][0] = miniX;
        value[0][1] = miniY;
        value[0][2] = miniZ;

        value[1][0] = maxiX;
        value[1][1] = maxiY;
        value[1][2] = maxiZ;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //--------------------------------------------------------------------------------------
    bool IsHit( const Ray8& ray, s32& mask ) const
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        b256 tmin = _mm256_set1_ps( F_HIT_MIN );
        b256 tmax = _mm256_set1_ps( F_HIT_MAX );

        s32 idx0, idx1;

        // X軸.
        idx0 = ray.sign[ 0 ];
        idx1 = 1 - idx0;
        tmin = _mm256_max_ps( tmin, _mm256_mul_ps( _mm256_sub_ps( value[ idx0 ][ 0 ], ray.pos[ 0 ] ), ray.invDir[ 0 ] ) );
        tmax = _mm256_min_ps( tmax, _mm256_mul_ps( _mm256_sub_ps( value[ idx1 ][ 0 ], ray.pos[ 0 ] ), ray.invDir[ 0 ] ) );

        // Y軸.
        idx0 = ray.sign[ 1 ];
        idx1 = 1 - idx0;
        tmin = _mm256_max_ps( tmin, _mm256_mul_ps( _mm256_sub_ps( value[ idx0 ][ 1 ], ray.pos[ 1 ] ), ray.invDir[ 1 ] ) );
        tmax = _mm256_min_ps( tmax, _mm256_mul_ps( _mm256_sub_ps( value[ idx1 ][ 1 ], ray.pos[ 1 ] ), ray.invDir[ 1 ] ) );

        // Z軸.
        idx0 = ray.sign[ 2 ];
        idx1 = 1 - idx0;
        tmin = _mm256_max_ps( tmin, _mm256_mul_ps( _mm256_sub_ps( value[ idx0 ][ 2 ], ray.pos[ 2 ] ), ray.invDir[ 2 ] ) );
        tmax = _mm256_min_ps( tmax, _mm256_mul_ps( _mm256_sub_ps( value[ idx1 ][ 2 ], ray.pos[ 2 ] ), ray.invDir[ 2 ] ) );

        mask = _mm256_movemask_ps( _mm256_cmp_ps( tmax, tmin, _CMP_GE_OS ) );
        return ( mask > 0 );
    #else
        b256 tmin = { F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN, F_HIT_MIN };
        b256 tmax = { F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX, F_HIT_MAX };

        s32 idx0, idx1;

        // X軸
        idx0 = ray.sign[ 0 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<8; ++i )
        {
            tmin.m256_f32[ i ] = s3d::Max( tmin.m256_f32[ i ], ( value[ idx0 ][ 0 ].m256_f32[ i ] - ray.pos[ 0 ].m256_f32[ i ] ) * ray.invDir[ 0 ].m256_f32[ i ] );
            tmax.m256_f32[ i ] = s3d::Min( tmax.m256_f32[ i ], ( value[ idx1 ][ 0 ].m256_f32[ i ] - ray.pos[ 0 ].m256_f32[ i ] ) * ray.invDir[ 0 ].m256_f32[ i ] );
        }

        // Y軸
        idx0 = ray.sign[ 1 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<8; ++i )
        {
            tmin.m256_f32[ i ] = s3d::Max( tmin.m256_f32[ i ], ( value[ idx0 ][ 1 ].m256_f32[ i ] - ray.pos[ 1 ].m256_f32[ i ] ) * ray.invDir[ 1 ].m256_f32[ i ] );
            tmax.m256_f32[ i ] = s3d::Min( tmax.m256_f32[ i ], ( value[ idx1 ][ 1 ].m256_f32[ i ] - ray.pos[ 1 ].m256_f32[ i ] ) * ray.invDir[ 1 ].m256_f32[ i ] );
        }

        // Z軸
        idx0 = ray.sign[ 2 ];
        idx1 = 1 - idx0;
        for ( u32 i=0; i<8; ++i )
        {
            tmin.m256_f32[ i ] = s3d::Max( tmin.m256_f32[ i ], ( value[ idx0 ][ 2 ].m256_f32[ i ] - ray.pos[ 2 ].m256_f32[ i ] ) * ray.invDir[ 2 ].m256_f32[ i ] );
            tmax.m256_f32[ i ] = s3d::Min( tmax.m256_f32[ i ], ( value[ idx1 ][ 2 ].m256_f32[ i ] - ray.pos[ 2 ].m256_f32[ i ] ) * ray.invDir[ 2 ].m256_f32[ i ] );
        }

        b256i flg;
        flg.m256i_u32[0] = ( tmax.m256_f32[ 0 ] >= tmin.m256_f32[ 0 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[1] = ( tmax.m256_f32[ 1 ] >= tmin.m256_f32[ 1 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[2] = ( tmax.m256_f32[ 2 ] >= tmin.m256_f32[ 2 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[3] = ( tmax.m256_f32[ 3 ] >= tmin.m256_f32[ 3 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[4] = ( tmax.m256_f32[ 4 ] >= tmin.m256_f32[ 4 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[5] = ( tmax.m256_f32[ 5 ] >= tmin.m256_f32[ 5 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[6] = ( tmax.m256_f32[ 6 ] >= tmin.m256_f32[ 6 ] ) ? 0xffffffff : 0x0;
        flg.m256i_u32[7] = ( tmax.m256_f32[ 7 ] >= tmin.m256_f32[ 7 ] ) ? 0xffffffff : 0x0;

        mask = (
              ( Sign(flg.m256i_u32[7]) << 7 )
            | ( Sign(flg.m256i_u32[6]) << 6 )
            | ( Sign(flg.m256i_u32[5]) << 5 )
            | ( Sign(flg.m256i_u32[4]) << 4 )
            | ( Sign(flg.m256i_u32[3]) << 3 )
            | ( Sign(flg.m256i_u32[2]) << 2 )
            | ( Sign(flg.m256i_u32[1]) << 1 )
            | ( Sign(flg.m256i_u32[0]) ) );

        return ( mask > 0 );
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }

    //--------------------------------------------------------------------------------------
    //! @brief      バウンディングボックスを取得します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox GetBox() const
    {
        Vector3 tmin( value[0][0].m256_f32[0], value[0][1].m256_f32[0], value[0][2].m256_f32[0] );
        Vector3 tmax( value[1][0].m256_f32[0], value[1][1].m256_f32[0], value[1][2].m256_f32[0] );

        for( u32 i=1; i<8; ++i )
        {
            tmin = Vector3::Min( tmin, Vector3( value[0][0].m256_f32[i], value[0][1].m256_f32[i], value[0][2].m256_f32[i] ) );
            tmax = Vector3::Max( tmax, Vector3( value[1][0].m256_f32[i], value[1][1].m256_f32[i], value[1][2].m256_f32[i] ) );
        }

        return BoundingBox( tmin, tmax );
    }

    //--------------------------------------------------------------------------------------
    //! @brief      2つの4バウンディングボックスをマージします.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox8 Merge( const BoundingBox8& a, const BoundingBox8& b )
    {
    #if ( S3D_IS_SIMD && S3D_IS_AVX )
        b256 miniX = _mm256_min_ps( a.value[0][0], b.value[0][0] );
        b256 miniY = _mm256_min_ps( a.value[0][1], b.value[0][1] );
        b256 miniZ = _mm256_min_ps( a.value[0][2], b.value[0][2] );

        b256 maxiX = _mm256_max_ps( a.value[1][0], b.value[1][0] );
        b256 maxiY = _mm256_max_ps( a.value[1][1], b.value[1][1] );
        b256 maxiZ = _mm256_max_ps( a.value[1][2], b.value[1][2] );

        return BoundingBox8( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
    #else
        b256 miniX = { 
            ( a.value[0][0].m256_f32[0] < b.value[0][0].m256_f32[0] ) ? a.value[0][0].m256_f32[0] : b.value[0][0].m256_f32[0],
            ( a.value[0][0].m256_f32[1] < b.value[0][0].m256_f32[1] ) ? a.value[0][0].m256_f32[1] : b.value[0][0].m256_f32[1],
            ( a.value[0][0].m256_f32[2] < b.value[0][0].m256_f32[2] ) ? a.value[0][0].m256_f32[2] : b.value[0][0].m256_f32[2],
            ( a.value[0][0].m256_f32[3] < b.value[0][0].m256_f32[3] ) ? a.value[0][0].m256_f32[3] : b.value[0][0].m256_f32[3],
            ( a.value[0][0].m256_f32[4] < b.value[0][0].m256_f32[4] ) ? a.value[0][0].m256_f32[4] : b.value[0][0].m256_f32[4],
            ( a.value[0][0].m256_f32[5] < b.value[0][0].m256_f32[5] ) ? a.value[0][0].m256_f32[5] : b.value[0][0].m256_f32[5],
            ( a.value[0][0].m256_f32[6] < b.value[0][0].m256_f32[6] ) ? a.value[0][0].m256_f32[6] : b.value[0][0].m256_f32[6],
            ( a.value[0][0].m256_f32[7] < b.value[0][0].m256_f32[7] ) ? a.value[0][0].m256_f32[7] : b.value[0][0].m256_f32[7]
        };
        b256 miniY = { 
            ( a.value[0][1].m256_f32[0] < b.value[0][1].m256_f32[0] ) ? a.value[0][1].m256_f32[0] : b.value[0][1].m256_f32[0],
            ( a.value[0][1].m256_f32[1] < b.value[0][1].m256_f32[1] ) ? a.value[0][1].m256_f32[1] : b.value[0][1].m256_f32[1],
            ( a.value[0][1].m256_f32[2] < b.value[0][1].m256_f32[2] ) ? a.value[0][1].m256_f32[2] : b.value[0][1].m256_f32[2],
            ( a.value[0][1].m256_f32[3] < b.value[0][1].m256_f32[3] ) ? a.value[0][1].m256_f32[3] : b.value[0][1].m256_f32[3],
            ( a.value[0][1].m256_f32[4] < b.value[0][1].m256_f32[4] ) ? a.value[0][1].m256_f32[4] : b.value[0][1].m256_f32[4],
            ( a.value[0][1].m256_f32[5] < b.value[0][1].m256_f32[5] ) ? a.value[0][1].m256_f32[5] : b.value[0][1].m256_f32[5],
            ( a.value[0][1].m256_f32[6] < b.value[0][1].m256_f32[6] ) ? a.value[0][1].m256_f32[6] : b.value[0][1].m256_f32[6],
            ( a.value[0][1].m256_f32[7] < b.value[0][1].m256_f32[7] ) ? a.value[0][1].m256_f32[7] : b.value[0][1].m256_f32[7]
        };
        b256 miniZ = { 
            ( a.value[0][2].m256_f32[0] < b.value[0][2].m256_f32[0] ) ? a.value[0][2].m256_f32[0] : b.value[0][2].m256_f32[0],
            ( a.value[0][2].m256_f32[1] < b.value[0][2].m256_f32[1] ) ? a.value[0][2].m256_f32[1] : b.value[0][2].m256_f32[1],
            ( a.value[0][2].m256_f32[2] < b.value[0][2].m256_f32[2] ) ? a.value[0][2].m256_f32[2] : b.value[0][2].m256_f32[2],
            ( a.value[0][2].m256_f32[3] < b.value[0][2].m256_f32[3] ) ? a.value[0][2].m256_f32[3] : b.value[0][2].m256_f32[3],
            ( a.value[0][2].m256_f32[4] < b.value[0][2].m256_f32[4] ) ? a.value[0][2].m256_f32[4] : b.value[0][2].m256_f32[4],
            ( a.value[0][2].m256_f32[5] < b.value[0][2].m256_f32[5] ) ? a.value[0][2].m256_f32[5] : b.value[0][2].m256_f32[5],
            ( a.value[0][2].m256_f32[6] < b.value[0][2].m256_f32[6] ) ? a.value[0][2].m256_f32[6] : b.value[0][2].m256_f32[6],
            ( a.value[0][2].m256_f32[7] < b.value[0][2].m256_f32[7] ) ? a.value[0][2].m256_f32[7] : b.value[0][2].m256_f32[7]
        };

        b256 maxiX = { 
            ( a.value[1][0].m256_f32[0] > b.value[1][0].m256_f32[0] ) ? a.value[1][0].m256_f32[0] : b.value[1][0].m256_f32[0],
            ( a.value[1][0].m256_f32[1] > b.value[1][0].m256_f32[1] ) ? a.value[1][0].m256_f32[1] : b.value[1][0].m256_f32[1],
            ( a.value[1][0].m256_f32[2] > b.value[1][0].m256_f32[2] ) ? a.value[1][0].m256_f32[2] : b.value[1][0].m256_f32[2],
            ( a.value[1][0].m256_f32[3] > b.value[1][0].m256_f32[3] ) ? a.value[1][0].m256_f32[3] : b.value[1][0].m256_f32[3],
            ( a.value[1][0].m256_f32[4] > b.value[1][0].m256_f32[4] ) ? a.value[1][0].m256_f32[4] : b.value[1][0].m256_f32[4],
            ( a.value[1][0].m256_f32[5] > b.value[1][0].m256_f32[5] ) ? a.value[1][0].m256_f32[5] : b.value[1][0].m256_f32[5],
            ( a.value[1][0].m256_f32[6] > b.value[1][0].m256_f32[6] ) ? a.value[1][0].m256_f32[6] : b.value[1][0].m256_f32[6],
            ( a.value[1][0].m256_f32[7] > b.value[1][0].m256_f32[7] ) ? a.value[1][0].m256_f32[7] : b.value[1][0].m256_f32[7]
        };
        b256 maxiY = { 
            ( a.value[1][1].m256_f32[0] > b.value[1][1].m256_f32[0] ) ? a.value[1][1].m256_f32[0] : b.value[1][1].m256_f32[0],
            ( a.value[1][1].m256_f32[1] > b.value[1][1].m256_f32[1] ) ? a.value[1][1].m256_f32[1] : b.value[1][1].m256_f32[1],
            ( a.value[1][1].m256_f32[2] > b.value[1][1].m256_f32[2] ) ? a.value[1][1].m256_f32[2] : b.value[1][1].m256_f32[2],
            ( a.value[1][1].m256_f32[3] > b.value[1][1].m256_f32[3] ) ? a.value[1][1].m256_f32[3] : b.value[1][1].m256_f32[3],
            ( a.value[1][1].m256_f32[4] > b.value[1][1].m256_f32[4] ) ? a.value[1][1].m256_f32[4] : b.value[1][1].m256_f32[4],
            ( a.value[1][1].m256_f32[5] > b.value[1][1].m256_f32[5] ) ? a.value[1][1].m256_f32[5] : b.value[1][1].m256_f32[5],
            ( a.value[1][1].m256_f32[6] > b.value[1][1].m256_f32[6] ) ? a.value[1][1].m256_f32[6] : b.value[1][1].m256_f32[6],
            ( a.value[1][1].m256_f32[7] > b.value[1][1].m256_f32[7] ) ? a.value[1][1].m256_f32[7] : b.value[1][1].m256_f32[7]
        };
        b256 maxiZ = { 
            ( a.value[1][2].m256_f32[0] > b.value[1][2].m256_f32[0] ) ? a.value[1][2].m256_f32[0] : b.value[1][2].m256_f32[0],
            ( a.value[1][2].m256_f32[1] > b.value[1][2].m256_f32[1] ) ? a.value[1][2].m256_f32[1] : b.value[1][2].m256_f32[1],
            ( a.value[1][2].m256_f32[2] > b.value[1][2].m256_f32[2] ) ? a.value[1][2].m256_f32[2] : b.value[1][2].m256_f32[2],
            ( a.value[1][2].m256_f32[3] > b.value[1][2].m256_f32[3] ) ? a.value[1][2].m256_f32[3] : b.value[1][2].m256_f32[3],
            ( a.value[1][2].m256_f32[4] > b.value[1][2].m256_f32[4] ) ? a.value[1][2].m256_f32[4] : b.value[1][2].m256_f32[4],
            ( a.value[1][2].m256_f32[5] > b.value[1][2].m256_f32[5] ) ? a.value[1][2].m256_f32[5] : b.value[1][2].m256_f32[5],
            ( a.value[1][2].m256_f32[6] > b.value[1][2].m256_f32[6] ) ? a.value[1][2].m256_f32[6] : b.value[1][2].m256_f32[6],
            ( a.value[1][2].m256_f32[7] > b.value[1][2].m256_f32[7] ) ? a.value[1][2].m256_f32[7] : b.value[1][2].m256_f32[7]
        };

        return BoundingBox8( miniX, miniY, miniZ, maxiX, maxiY, maxiZ );
    #endif// ( S3D_IS_SIMD && S3D_IS_AVX )
    }
};


/////////////////////////////////////////////////////////////////////////////////////////////
// Random class
/////////////////////////////////////////////////////////////////////////////////////////////
class Random
{
    //=======================================================================================
    // list of friend classes and methods.
    //=======================================================================================
    /* NOTHING */

public:
    //=======================================================================================
    // public variables.
    //=======================================================================================
    /* NOTHING */

    //=======================================================================================
    // public methods.
    //=======================================================================================

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Random()
    { SetSeed( 123456789 ); }

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Random( const u32 seed ) 
    { SetSeed( seed ); }

    //--------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Random( const Random& value )
    : m_X( value.m_X )
    , m_Y( value.m_Y )
    , m_Z( value.m_Z )
    , m_W( value.m_W )
    { /* DO_NOTHING */ }

    //--------------------------------------------------------------------------------------
    //! @brief      乱数種を設定します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    void SetSeed( const u32 seed )
    {
        // 超越数設定.
        m_X = 123456789;
        m_Y = 362436069;
        m_Z = 521288629;
        m_W = ( seed <= 0 ) ? 88675123 : seed;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      u32型として乱数を取得します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    u32 GetAsU32()
    {
        u32 t = m_X ^ ( m_X << 11 );
        m_X   = m_Y;
        m_Y   = m_Z;
        m_Z   = m_W;
        m_W   = ( m_W ^ ( m_W >> 19 ) ) ^ ( t ^ ( t >> 8 ) );
        return m_W;
    }

    //--------------------------------------------------------------------------------------
    //! @brief      f64型として乱数を取得します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f64 GetAsF64()
    { return static_cast<f64>( GetAsU32() ) / 0xffffffffui32; }

    //--------------------------------------------------------------------------------------
    //! @brief      f32型として乱数を取得します.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetAsF32()
    { return static_cast<f32>( GetAsU32() ) / 0xffffffffui32; }

    //--------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //--------------------------------------------------------------------------------------
    S3D_INLINE
    Random& operator = ( const Random& value )
    {
        m_X = value.m_X;
        m_Y = value.m_Y;
        m_Z = value.m_Z;
        m_W = value.m_W;
        return (*this);
    }

protected:
    //=======================================================================================
    // protected variables.
    //=======================================================================================
    /* NOTHING */

    //=======================================================================================
    // protected methods.
    //=======================================================================================
    /* NOTHING */

private:
    //=======================================================================================
    // private variables.
    //=======================================================================================
    u32 m_X;
    u32 m_Y;
    u32 m_Z;
    u32 m_W;

    //=======================================================================================
    // private methods.
    //=======================================================================================
    /* NOTHING */
};


/////////////////////////////////////////////////////////////////////////////////////////////
// OrthonormalBasis structure
/////////////////////////////////////////////////////////////////////////////////////////////
struct OrthonormalBasis
{
public:
    Vector3 u;
    Vector3 v;
    Vector3 w;

    //--------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------------
    OrthonormalBasis();

    //--------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //--------------------------------------------------------------------------------------
    OrthonormalBasis( const Vector3&, const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      U方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromU( const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      V方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromV( const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      W方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromW( const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      UV方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromUV( const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      VU方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromVU( const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      UW方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromUW( const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      WU方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromWU( const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      VW方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromVW( const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      WV方向から初期化します.
    //--------------------------------------------------------------------------------------
    void InitFromWV( const Vector3&, const Vector3& );

    //--------------------------------------------------------------------------------------
    //! @brief      等価比較演算子です.
    //--------------------------------------------------------------------------------------
    bool operator == ( const OrthonormalBasis& ) const;

    //--------------------------------------------------------------------------------------
    //! @brief      非等価比較演算子です.
    //--------------------------------------------------------------------------------------
    bool operator != ( const OrthonormalBasis& ) const;
};


//------------------------------------------------------------------------------------------
//! @brief      三角形の表面積を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const Vector3& a, const Vector3& b, const Vector3& c )
{
   f32 X = ( b.y - a.y ) * ( c.z - a.z ) - ( c.y - a.y ) * ( b.z - a.z );
   f32 Y = ( b.z - a.z ) * ( c.x - a.x ) - ( c.z - a.z ) * ( b.x - a.x );
   f32 Z = ( b.x - a.x ) * ( c.y - a.y ) - ( c.x - a.x ) * ( b.y - a.y );
   return 0.5f * sqrtf( ( X * X ) + ( Y * Y ) + ( Z * Z ) );
}

//------------------------------------------------------------------------------------------
//! @brief      バウンディングボックスの表面積を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const BoundingBox& box )
{
    f32 X = fabs( box.maxi.x - box.mini.x );
    f32 Y = fabs( box.maxi.y - box.mini.y );
    f32 Z = fabs( box.maxi.z - box.mini.z );
    return 2.0f * ( ( X * Y ) + ( X * Z ) + ( Y * Z ) );
}

//------------------------------------------------------------------------------------------
//! @brief      バウンディングスフィアの表面積を求めます.
//------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const f32 radius )
{
    return 4.0f * F_PI * ( radius * radius );
}


} // namespace s3d


#endif//__S3D_MATH__
