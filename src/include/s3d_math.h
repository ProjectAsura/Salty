//-------------------------------------------------------------------------------------------------
// File : s3d_math.h.
// Desc : Math Module.
// Copyright(c) Project Asura. All right reserved.
//-------------------------------------------------------------------------------------------------
#pragma once

//-------------------------------------------------------------------------------------------------
// Includes
//-------------------------------------------------------------------------------------------------
#include <s3d_typedef.h>
#include <s3d_Simd.h>
#include <cmath>
#include <cfloat>
#include <cassert>


namespace s3d {

//-------------------------------------------------------------------------------------------------
// Forward Declarations.
//-------------------------------------------------------------------------------------------------
struct  Vector2;
struct  Vector3;
struct  Vector4;
struct  Ray;
struct  Ray4;
struct  Ray8;
struct  Matrix;
struct  BoundingBox;
struct  BoundingBox4;
struct  BoundingBox8;


//-------------------------------------------------------------------------------------------------
// Type Definitions.
//-------------------------------------------------------------------------------------------------
typedef Vector3 Color3;
typedef Vector4 Color4;


//-------------------------------------------------------------------------------------------------
// Constant Values
//-------------------------------------------------------------------------------------------------
const f32   F_HIT_MAX   = 1e12f;                                  //!< 交差判定上限値.
const f32   F_HIT_MIN   = 1e-3f;                                  //!< 交差判定下限値.
const f32   F_PI        = 3.1415926535897932384626433832795f;     //!< πです.
const f32   F_2PI       = 6.283185307179586476925286766559f;      //!< 2πです.
const f32   F_1DIVPI    = 0.31830988618379067153776752674503f;    //!< 1/πです.
const f32   F_1DIV2PI   = 0.15915494309189533576888376337251f;    //!< 1/2πです.
const f32   F_PIDIV2    = 1.5707963267948966192313216916398f;     //!< π/2です.
const f32   F_PIDIV3    = 1.0471975511965977461542144610932f;     //!< π/3です.
const f32   F_PIDIV4    = 0.78539816339744830961566084581988f;    //!< π/4です.
const f32   F_MAX       = 3.402823466e+38F;                       //!< f32型の最大値です.
const f32   F_MIN       = 1.175494351e-38F;                       //!< f32型の最小値です.


//-------------------------------------------------------------------------------------------------
//! @brief      符号を求めます.
//-------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
s32 Sign( const T val )
{ return ( val > T(0) ) ? 1 : (( val < T(0) ) ? -1 : 0 ); }

//-------------------------------------------------------------------------------------------------
//! @brief      最大値を求めます.
//-------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Max( const T a, const T b )
{ return ( a > b ) ? a : b; }

//-------------------------------------------------------------------------------------------------
//! @brief      最小値を求めます.
//-------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Min( const T a, const T b )
{ return ( a < b ) ? a : b; }

//--------------------------------------------------------------------------------------------------
//! @brief      値を指定された範囲内に収めます.
//!
//! @param [in]     value   クランプする値.
//! @param [in]     a       最小値.
//! @param [in]     b       最大値.
//! @return     値をaからbの範囲内に収めた結果を返却します.
//--------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Clamp( T value, T mini, T maxi )
{ return Max( mini, Min( maxi, value ) ); }

//--------------------------------------------------------------------------------------------------
//! @brief      値を0～1に収めます.
//!
//! @param [in]     value   クランプする値.
//! @return     値を0から1の範囲内に収めた結果を返却します.
//--------------------------------------------------------------------------------------------------
template< typename T > S3D_INLINE
T Saturate( T value )
{ return Clamp( value, T(0), T(1) ); }

//-------------------------------------------------------------------------------------------------
//! @brief      ラジアンに変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToRad( const f32 deg )
{ return deg * ( F_PI / 180.0f ); }

//-------------------------------------------------------------------------------------------------
//! @brief      度に変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 ToDeg( const f32 rad )
{ return rad * ( 180.0f / F_PI ); }

//-------------------------------------------------------------------------------------------------
//! @brief      非数であるかチェックします.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
bool IsNan( const f32 value )
{ return ( value != value ); }

//-------------------------------------------------------------------------------------------------
//! @brief      ゼロであるかチェックします.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
bool IsZero( const f32 value )
{ return ( fabs( value ) <= FLT_EPSILON ); }

//-------------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 SafeSqrt( const f32 value )
{
    if ( value > FLT_EPSILON )
    { return sqrtf( value ); }

    return 0.0f;
}

//-------------------------------------------------------------------------------------------------
//! @brief      安全に平方根を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f64 SafeSqrt( const f64 value )
{
    if ( value > DBL_EPSILON )
    { return sqrt( value ); }

    return 0.0;
}

//-------------------------------------------------------------------------------------------------
//! @brief      入力のうち下位16ビットを1つのビットごとに分離します
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Part1By1( u32 n )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.323参照 */

    // 入力のうち低いほうの16ビットを1つのビットごとに分離する.
    // n = ----------------fedcba9876543210 : 最初のビットの状態.
    // n = --------fedcba98--------76543210 : (1)の後.
    // n = ----fedc----ba98----7654----3210 : (2)の後.
    // n = --fe--dc--ba--98--76--54--32--10 : (3)の後.
    // n = -f-e-d-c-b-a-9-8-7-6-5-4-3-2-1-0 : (4)の後.
    n = ( n ^ ( n << 8 ) ) & 0x00ff00ff;    // (1)
    n = ( n ^ ( n << 4 ) ) & 0x0f0f0f0f;    // (2)
    n = ( n ^ ( n << 2 ) ) & 0x33333333;    // (3)
    n = ( n ^ ( n << 1 ) ) & 0x55555555;    // (4)

    return n;
}

//-------------------------------------------------------------------------------------------------
//! @brief      入力のうち下位10ビットを2つのビットごとに分離します
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Part1By2( u32 n )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.322参照 */

    // 入力のうち低いほうの10ビットを2つのビットごとに分離する.
    // n = ----------------------9876543210 : 最初のビットの状態.
    // n = ------98----------------76543210 : (1)の後.
    // n = ------98--------7654--------3210 : (2)の後.
    // n = ------98----76----54----32----10 : (3)の後.
    // n = ----9--8--7--6--5--4--3--2--1--0 : (4)の後.
    n = ( n ^ ( n << 16 ) ) & 0xff0000ff;   // (1)
    n = ( n ^ ( n <<  8 ) ) & 0x0300f00f;   // (2)
    n = ( n ^ ( n <<  4 ) ) & 0x030c30c3;   // (3)
    n = ( n ^ ( n <<  2 ) ) & 0x09249249;   // (4)

    return n;
}

//-------------------------------------------------------------------------------------------------
//! @brief      2次元を表すモートンコードを求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Morton2( u32 x, u32 y )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.323参照 */

    // 2つの16ビットの数字を入力として，それらの間にビットを挟み込んで1つの数字にする.
    return ( Part1By1( y ) << 1 )
         + ( Part1By1( x ) << 0 );
}

//-------------------------------------------------------------------------------------------------
//! @brief      3次元を表すモートンコードを求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
u32 Morton3( u32 x, u32 y, u32 z )
{
    /* ゲームプログラミングのためのリアルタイム衝突判定 p.322参照 */

    // 3つの10ビットの数字を入力として，それらをビットとして挟み込んで1つの数字にする.
    return ( Part1By2( z ) << 2 ) 
         + ( Part1By2( y ) << 1 )
         + ( Part1By2( x ) << 0 );
}

//-------------------------------------------------------------------------------------------------
//! @brief      ビットが立っているかどうかチェックします.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
bool IsMask(int mask, int index)
{
    auto bit = 0x1 << index;
    return ((mask & bit) == bit) != 0;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Vector2 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Vector2
{
public:
    union
    {
        struct
        {
            f32 x;      //!< X成分です.
            f32 y;      //!< Y成分です.
        };
        f32 a[2];       //!< 各成分を表す配列です;
    };

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector2()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector2( const f32 nx, const f32 ny )
    : x( nx )
    , y( ny )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector2( const Vector2& value )
    : x( value.x )
    , y( value.y )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    operator float* ()
    { return &x; }

    //---------------------------------------------------------------------------------------------
    //! @brief
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    operator const float* () const
    { return &x; }

    //---------------------------------------------------------------------------------------------
    //! @brief      等価演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator == ( const Vector2& value ) const
    {
        return ( x == value.x )
            && ( y == value.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      非等価演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool operator != ( const Vector2& value ) const
    {
        return ( x != value.x )
            || ( y != value.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator = ( const Vector2& value )
    {
        x = value.x;
        y = value.y;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator += ( const Vector2& b )
    {
        x += b.x;
        y += b.y;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator -= ( const Vector2& b )
    {
        x -= b.x;
        y -= b.y;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator *= ( const f32 b )
    {
        x *= b;
        y *= b;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2& operator /= ( const f32 b )
    {
        assert( !IsZero( b ) );
        x /= b;
        y /= b;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2  operator + () const
    { return Vector2( x, y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - () const
    { return Vector2( -x, -y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator + (const Vector2 &b) const
    {
        return Vector2(
            x + b.x,
            y + b.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator - (const Vector2 &b) const
    { 
        return Vector2(
            x - b.x,
            y - b.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator * (const f32 b) const
    { 
        return Vector2(
            x * b,
            y * b );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector2 operator / (const f32 b) const
    {
        assert( !IsZero( b ) );
        return Vector2(
            x / b,
            y / b );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return ( x * x ) + ( y * y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return sqrtf( ( x * x ) + ( y * y ) ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    {
        auto mag = sqrtf( x * x + y * y );
        assert( mag > 0.0f );
        x /= mag;
        y /= mag;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化を試みます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SafeNormalize()
    {
        auto mag = sqrtf( x * x + y * y );
        if ( mag > 0.0f )
        {
            x /= mag;
            y /= mag;
        }
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 UnitVector (const Vector2 &v)
    {
        auto mag = sqrtf( v.x * v.x + v.y * v.y );
        assert( !IsZero( mag ) );
        return Vector2(
            v.x / mag,
            v.y / mag );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めるのを試みます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 SafeUnitVector ( const Vector2& v)
    {
        auto mag = sqrtf( v.x * v.x + v.y * v.y );
        if ( mag > 0.0f )
        {
            return Vector2(
                v.x / mag,
                v.y / mag );
        }
        return v;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      各成分ごとに乗算します.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Mul (const Vector2 &v1, const Vector2 &v2)
    { 
        return Vector2(
            v1.x * v2.x,
            v1.y * v2.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector2 &v1, const Vector2 &v2) 
    { return ( v1.x * v2.x ) + ( v1.y * v2.y ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Reflect( const Vector2& i, const Vector2& n )
    {
        auto dot = ( n.x * i.x ) + ( n.y * i.y );
        auto _2dot = 2.0f * dot;

        return Vector2(
            i.x - ( _2dot * n.x ),
            i.y - ( _2dot * n.y ) );
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Min( const Vector2& a, const Vector2& b )
    {
        return Vector2( 
            ( a.x < b.x ) ? a.x : b.x,
            ( a.y < b.y ) ? a.y : b.y );
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector2 Max( const Vector2& a, const Vector2& b )
    {
        return Vector2(
            ( a.x > b.x ) ? a.x : b.x,
            ( a.y > b.y ) ? a.y : b.y );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief
    //---------------------------------------------------------------------------------------------
    static Vector2 Transform( const Vector2& position, const Matrix& matrix );
};


///////////////////////////////////////////////////////////////////////////////////////////////////
// Vector3 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Vector3
{
public:
    b128    v;

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( b128 value )
    : v( value )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( const f32 nx, const f32 ny, const f32 nz ) 
    : v( Simd4::Make(nx, ny, nz, 0.0f))
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( const Vector2& vec, const f32 nz )
    : v( Simd4::Make(vec.x, vec.y, nz, 0.0f))
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Vector3( const Vector3& value )
    : v( value.v )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      X成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetX() const { return Simd4::GetX(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetY() const { return Simd4::GetY(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetZ() const { return Simd4::GetZ(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      X成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetX(f32 value) { Simd4::SetX(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetY(f32 value) { Simd4::SetY(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetZ(f32 value) { Simd4::SetZ(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator = ( const Vector3& value )
    { 
        v = value.v;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator += ( const Vector3& value )
    {
        v = Simd4::Add( v, value.v );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator -= ( const Vector3& value )
    {
        v = Simd4::Sub( v, value.v );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator *= ( const Vector3& value )
    {
        v = Simd4::Mul( v, value.v );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator *= ( const f32 value )
    {
        v = Simd4::Mul( v, Simd4::Make(value) );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator += ( const f32 value )
    {
        v = Simd4::Add( v, Simd4::Make(value) );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator -= ( const f32 value )
    {
        v = Simd4::Sub( v, Simd4::Make(value) );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3& operator /= ( const f32 value )
    {
        v = Simd4::Div( v, Simd4::Make(value) );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3  operator + () const
    { return *this; }

    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - () const
    { return Simd4::Neg(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator + (const Vector3& value) const
    { return Simd4::Add(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - (const Vector3& value) const
    { return Simd4::Sub(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator * ( const Vector3& value ) const
    { return Simd4::Mul(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator / ( const Vector3& value ) const
    { return Simd4::Div(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator + ( const f32 value ) const
    { return Simd4::Add(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator - ( const f32 value ) const
    { return Simd4::Sub(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator * (const f32 value) const
    { return Simd4::Mul(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector3 operator / (const f32 value) const
    { return Simd4::Div(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return Simd4::Dp3(v, v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return Simd4::Mag3(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    { v = Simd4::Unit3(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 UnitVector (const Vector3 &value)
    { return Simd4::Unit3(value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector3 &v1, const Vector3 &v2) 
    { return Simd4::Dp3(v1.v, v2.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      外積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Cross (const Vector3 &v1, const Vector3 &v2) 
    { return Simd4::Crs(v1.v, v2.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Reflect( const Vector3& i, const Vector3& n )
    {
        auto twoDot = 2.0f * Simd4::Dp3(i.v, n.v);
        auto v = Simd4::Mul( Simd4::Make(twoDot), n.v );
        return Simd4::Sub(i.v, v);
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Min( const Vector3& a, const Vector3& b )
    { return Simd4::Min(a.v, b.v); }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 Max( const Vector3& a, const Vector3& b )
    { return Simd4::Max(a.v, b.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      法線ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeNormal( const Vector3& a, const Vector3& b, const Vector3& c )
    {
        auto e1 = b - a;
        auto e2 = c - a;
        return Vector3::UnitVector( Vector3::Cross( e1, e2 ) );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      矩形の法線ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector3 ComputeQuadNormal( const Vector3& a, const Vector3& b, const Vector3& c, const Vector3& d )
    {
        auto n1a = ComputeNormal( a, b, c );
        auto n1b = ComputeNormal( a, c, d );
        auto n2a = ComputeNormal( b, c, d );
        auto n2b = ComputeNormal( b, d, c );

        if ( Vector3::Dot( n1a, n1b ) > Vector3::Dot( n2a, n2b ) )
        { return Vector3::UnitVector( n1a + n1b ); }
        else
        { return Vector3::UnitVector( n2a + n2b ); }
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      指定行列で変換します.
    //---------------------------------------------------------------------------------------------
    static Vector3 Transform( const Vector3& position, const Matrix& matrix );

    //---------------------------------------------------------------------------------------------
    //! @brief      指定行列で法線ベクトルを変換します.
    //---------------------------------------------------------------------------------------------
    static Vector3 TransformNormal( const Vector3& normal, const Matrix& matrix );

    //---------------------------------------------------------------------------------------------
    //! @brief      指定行列で変換し，w = 1 に射影します.
    //---------------------------------------------------------------------------------------------
    static Vector3 TransformCoord ( const Vector3& coord, const Matrix& matrix );
};

//-------------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//-------------------------------------------------------------------------------------------------
S3D_INLINE 
Vector3 operator * (const f32 f, const Vector3 &v)
{ return v * f; }

//-------------------------------------------------------------------------------------------------
//! @brief      除算演算子です.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector3 operator / ( const f32 f, const Vector3& v )
{ return Simd4::Div(Simd4::Make(f), v.v); }

//-------------------------------------------------------------------------------------------------
//! @brief      加算演算子です.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector3 operator + ( const f32 f, const Vector3& v)
{ return Simd4::Add(Simd4::Make(f), v.v); }

//-------------------------------------------------------------------------------------------------
//! @brief      減算演算子です.
//--------------------------------------------------------------------------------------------------
S3D_INLINE
Vector3 operator - ( const f32 f, const Vector3& v )
{ return Simd4::Sub(Simd4::Make(f), v.v); }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Vector4 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct S3D_ALIGN(16) Vector4
{
public:
    b128 v;

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4(b128 value)
    : v(value)
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const f32 nx, const f32 ny, const f32 nz, const f32 nw ) 
    : v( Simd4::Make(nx, ny, nz, nw) )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const Vector3& val, const f32 nw )
    : v( val.v )
    { Simd4::SetW(v, nw); }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4( const Vector4& value )
    : v( value.v )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      X成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetX() const
    { return Simd4::GetX(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetY() const
    { return Simd4::GetY(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetZ() const
    { return Simd4::GetZ(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      W成分を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetW() const
    { return Simd4::GetW(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      X成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetX(f32 value)
    { Simd4::SetX(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetY(f32 value)
    { Simd4::SetY(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetZ(f32 value)
    { Simd4::SetZ(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      W成分を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetW(f32 value)
    { Simd4::SetW(v, value); }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator = ( const Vector4& value )
    {
        v = value.v;
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator += ( const Vector4& value )
    {
        v = Simd4::Add(v, value.v);
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator -= ( const Vector4& value )
    {
        v = Simd4::Sub(v, value.v);
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator *= (const Vector4& value )
    {
        v = Simd4::Mul(v, value.v);
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator *= ( const f32 value )
    {
        v = Simd4::Mul(v, Simd4::Make(value));
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4& operator /= ( const f32 value )
    {
        v = Simd4::Div(v, Simd4::Make(value));
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator + () const
    { return *this; }

    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - () const
    { return Simd4::Neg(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator + (const Vector4& value) const
    { return Simd4::Add(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - (const Vector4& value) const
    { return Simd4::Sub(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //--------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator * (const Vector4& value) const
    { return Simd4::Mul(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator / ( const Vector4& value) const
    { return Simd4::Div(v, value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator + ( const f32 value ) const
    { return Simd4::Add(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //--------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator - ( const f32 value ) const
    { return Simd4::Sub(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator * ( const f32 value ) const
    { return Simd4::Mul(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      除算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Vector4 operator / (const f32 value) const
    { return Simd4::Div(v, Simd4::Make(value)); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さの2乗値を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 LengthSq() const
    { return Simd4::Dp4(v, v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      長さを求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE 
    f32 Length() const
    { return Simd4::Mag4(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      正規化します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void Normalize()
    { v = Simd4::Unit4(v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 UnitVector (const Vector4& value)
    { return Simd4::Unit4(value.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      内積を求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    f32 Dot (const Vector4 &v1, const Vector4 &v2) 
    { return Simd4::Dp4(v1.v, v2.v); }

    //---------------------------------------------------------------------------------------------
    //! @brief      反射ベクトルを求めます.
    //---------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Reflect( const Vector4& i, const Vector4& n )
    {
        auto twoDot = 2.0f * Simd4::Dp4(i.v, n.v);
        auto v = Simd4::Mul( Simd4::Make(twoDot), n.v );
        return Simd4::Sub(i.v, v);
    }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最小値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Min( const Vector4& a, const Vector4& b )
    { return Simd4::Min(a.v, b.v); }

    //----------------------------------------------------------------------------------------------
    //! @brief      各成分の最大値を求めます.
    //----------------------------------------------------------------------------------------------
    static S3D_INLINE
    Vector4 Max( const Vector4& a, const Vector4& b )
    { return Simd4::Max(a.v, b.v); }

    //----------------------------------------------------------------------------------------------
    //! @brief      指定行列で変換します.
    //----------------------------------------------------------------------------------------------
    static Vector4 Transform( const Vector4& value, const Matrix& matrix );
};

//-------------------------------------------------------------------------------------------------
//! @brief      乗算演算子です.
//-------------------------------------------------------------------------------------------------
S3D_INLINE 
Vector4 operator * (const f32 f, const Vector4 &v)
{ return Simd4::Mul(Simd4::Make(f), v.v); }

//-------------------------------------------------------------------------------------------------
//! @brief      加算演算子です.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector4 operator + (const f32 f, const Vector4& v)
{ return Simd4::Add(Simd4::Make(f), v.v); }

//-------------------------------------------------------------------------------------------------
//! @brief      減算演算子です.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector4 operator - ( const f32 f, const Vector4& v)
{ return Simd4::Sub(Simd4::Make(f), v.v); }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Ray structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Ray
{
    Vector3 pos;            //!< 位置座標です.
    Vector3 dir;            //!< 方向ベクトルです.

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray( const Vector3& p, const Vector3& d )
    {
        pos.v = p.v;
        dir.v = d.v;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray( const Ray& value )
    : pos   ( value.pos )
    , dir   ( value.dir )
    { /* DO_NOTHING */ }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// Ray4 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Ray4
{
    b128    pos[3];         //!< 位置座標です.
    b128    dir[3];         //!< 方向ベクトルです.

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray4( const Ray& ray )
    {
        Float4 p, d;
        Simd4::Store(p, ray.pos.v);
        Simd4::Store(d, ray.dir.v);

        pos[0] = Simd4::Make(p.v[0]);
        pos[1] = Simd4::Make(p.v[1]);
        pos[2] = Simd4::Make(p.v[2]);
        
        dir[0] = Simd4::Make(d.v[0]);
        dir[1] = Simd4::Make(d.v[1]);
        dir[2] = Simd4::Make(d.v[2]);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray4( const Ray4& rayQuad )
    {
        pos[0] = rayQuad.pos[0];
        pos[1] = rayQuad.pos[1];
        pos[2] = rayQuad.pos[2];

        dir[0] = rayQuad.dir[0];
        dir[1] = rayQuad.dir[1];
        dir[2] = rayQuad.dir[2];
    }
};

#if S3D_IS_AVX
///////////////////////////////////////////////////////////////////////////////////////////////////
// Ray4 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Ray8
{
    b256    pos[3];         //!< 位置座標です.
    b256    dir[3];         //!< 方向ベクトルです.

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray8( const Ray& ray )
    {
        Float4 p, d;
        Simd4::Store(p, ray.pos.v);
        Simd4::Store(d, ray.dir.v);

        pos[0] = Simd8::Make(p.v[0]);
        pos[1] = Simd8::Make(p.v[1]);
        pos[2] = Simd8::Make(p.v[2]);

        dir[0] = Simd8::Make(d.v[0]);
        dir[1] = Simd8::Make(d.v[1]);
        dir[2] = Simd8::Make(d.v[2]);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    Ray8( const Ray8& rayOct )
    {
        pos[0] = rayOct.pos[0];
        pos[1] = rayOct.pos[1];
        pos[2] = rayOct.pos[2];

        dir[0] = rayOct.dir[0];
        dir[1] = rayOct.dir[1];
        dir[2] = rayOct.dir[2];
    }
};
#endif// S3D_IS_AVX


///////////////////////////////////////////////////////////////////////////////////////////////////
// Matric structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Matrix
{
public:
    //=============================================================================================
    // public variables.
    //=============================================================================================
    b128 v[4];

    //=============================================================================================
    // public methods
    //=============================================================================================

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix()
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix
    (
        const f32 m11, const f32 m12, const f32 m13, const f32 m14,
        const f32 m21, const f32 m22, const f32 m23, const f32 m24,
        const f32 m31, const f32 m32, const f32 m33, const f32 m34,
        const f32 m41, const f32 m42, const f32 m43, const f32 m44
    )
    {
        v[0] = Simd4::Make( m14, m13, m12, m11 );
        v[1] = Simd4::Make( m24, m23, m22, m21 );
        v[2] = Simd4::Make( m34, m33, m32, m31 );
        v[3] = Simd4::Make( m44, m43, m42, m41 );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix( const b128& c0, const b128& c1, const b128& c2, const b128& c3 )
    {
        v[0] = c0;
        v[1] = c1;
        v[2] = c2;
        v[3] = c3;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix( const Matrix& value)
    {
        v[0] = value.v[0];
        v[1] = value.v[1];
        v[2] = value.v[2];
        v[3] = value.v[3];
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator =  ( const Matrix& value )
    {
        v[0] = value.v[0];
        v[1] = value.v[1];
        v[2] = value.v[2];
        v[3] = value.v[3];
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator += ( const Matrix& value )
    {
        v[0] = Simd4::Add(v[0], value.v[0]);
        v[1] = Simd4::Add(v[1], value.v[1]);
        v[2] = Simd4::Add(v[2], value.v[2]);
        v[3] = Simd4::Add(v[3], value.v[3]);
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator -= ( const Matrix& value )
    {
        v[0] = Simd4::Sub(v[0], value.v[0]);
        v[1] = Simd4::Sub(v[1], value.v[1]);
        v[2] = Simd4::Sub(v[2], value.v[2]);
        v[3] = Simd4::Sub(v[3], value.v[3]);
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator *= ( const Matrix& value )
    {
        v[0] = Simd4::Trs4( v[0], value.v );
        v[1] = Simd4::Trs4( v[1], value.v );
        v[2] = Simd4::Trs4( v[2], value.v );
        v[3] = Simd4::Trs4( v[3], value.v );
        return (*this);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix& operator *= ( const f32 value )
    {
        auto s = Simd4::Make(value);
        v[0] = Simd4::Mul(v[0], s);
        v[1] = Simd4::Mul(v[1], s);
        v[2] = Simd4::Mul(v[2], s);
        v[3] = Simd4::Mul(v[3], s);
        return (*this); 
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      正符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator + () const
    { return (*this); }
    
    //---------------------------------------------------------------------------------------------
    //! @brief      負符号演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator - () const
    {
        return Matrix(
            Simd4::Neg(v[0]),
            Simd4::Neg(v[1]),
            Simd4::Neg(v[2]),
            Simd4::Neg(v[3]));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      加算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator + ( const Matrix& value ) const
    {
        return Matrix(
            Simd4::Add(v[0], value.v[0]),
            Simd4::Add(v[1], value.v[1]),
            Simd4::Add(v[2], value.v[2]),
            Simd4::Add(v[3], value.v[3]));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      減算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator - ( const Matrix& value ) const
    {
        return Matrix(
            Simd4::Sub(v[0], value.v[0]),
            Simd4::Sub(v[1], value.v[1]),
            Simd4::Sub(v[2], value.v[2]),
            Simd4::Sub(v[3], value.v[3]));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator * ( const Matrix& value ) const
    {
        return Matrix(
            Simd4::Trs4(v[0], value.v),
            Simd4::Trs4(v[1], value.v),
            Simd4::Trs4(v[2], value.v),
            Simd4::Trs4(v[3], value.v));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      乗算演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Matrix operator * ( const f32 value ) const
    {
        auto s = Simd4::Make(value);
        return Matrix(
            Simd4::Mul(v[0], s),
            Simd4::Mul(v[1], s),
            Simd4::Mul(v[2], s),
            Simd4::Mul(v[3], s));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      逆行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Invert( const Matrix& value )
    {
        auto t   = Matrix::Transpose(value);
        auto v11 = _mm_shuffle_ps(t.v[2], t.v[2], _MM_SHUFFLE(1 ,1, 0, 0));
        auto v21 = _mm_shuffle_ps(t.v[3], t.v[3], _MM_SHUFFLE(3 ,2, 3, 2));
        auto v12 = _mm_shuffle_ps(t.v[0], t.v[0], _MM_SHUFFLE(1 ,1, 0, 0));
        auto v22 = _mm_shuffle_ps(t.v[1], t.v[1], _MM_SHUFFLE(3 ,2, 3, 2));
        auto v13 = _mm_shuffle_ps(t.v[2], t.v[0], _MM_SHUFFLE(2 ,0, 2, 0));
        auto v23 = _mm_shuffle_ps(t.v[3], t.v[1], _MM_SHUFFLE(3 ,1 ,3, 1));

        auto d1 = Simd4::Mul(v11, v21);
        auto d2 = Simd4::Mul(v12, v22);
        auto d3 = Simd4::Mul(v13, v23);

        v11 = _mm_shuffle_ps(t.v[2], t.v[2], _MM_SHUFFLE(3 ,2, 3, 2));
        v21 = _mm_shuffle_ps(t.v[3], t.v[3], _MM_SHUFFLE(1 ,1, 0, 0));
        v12 = _mm_shuffle_ps(t.v[0], t.v[0], _MM_SHUFFLE(3 ,2, 3, 2));
        v22 = _mm_shuffle_ps(t.v[1], t.v[1], _MM_SHUFFLE(1 ,1, 0, 0));
        v13 = _mm_shuffle_ps(t.v[2], t.v[0], _MM_SHUFFLE(3 ,1, 3, 1));
        v23 = _mm_shuffle_ps(t.v[3], t.v[1], _MM_SHUFFLE(2 ,0, 2, 0));

        v11 = Simd4::Mul(v11, v21);
        v12 = Simd4::Mul(v12, v22);
        v13 = Simd4::Mul(v13, v23);
        d1  = Simd4::Sub(d1,  v11);
        d2  = Simd4::Sub(d2,  v12);
        d3  = Simd4::Sub(d3,  v13);

        v22 = _mm_shuffle_ps(d1,         d3,    _MM_SHUFFLE(1, 1, 3, 1));
        v11 = _mm_shuffle_ps(t.v[1], t.v[1],    _MM_SHUFFLE(1, 0, 2, 1));
        v21 = _mm_shuffle_ps(v22,        d1,    _MM_SHUFFLE(0, 3, 0, 2));
        v12 = _mm_shuffle_ps(t.v[0], t.v[0],    _MM_SHUFFLE(0, 1, 0, 2));
        v22 = _mm_shuffle_ps(v22,        d1,    _MM_SHUFFLE(2, 1, 2, 1));

        __m128 v24, v14;
        v24 = _mm_shuffle_ps(d2,         d3,    _MM_SHUFFLE(3, 3, 3, 1));
        v13 = _mm_shuffle_ps(t.v[3], t.v[3],    _MM_SHUFFLE(1, 0, 2, 1));
        v23 = _mm_shuffle_ps(v24,        d2,    _MM_SHUFFLE(0, 3, 0, 2));
        v14 = _mm_shuffle_ps(t.v[2], t.v[2],    _MM_SHUFFLE(0, 1, 0, 2));
        v24 = _mm_shuffle_ps(v24,        d2,    _MM_SHUFFLE(2, 1, 2, 1));

        auto r1 = Simd4::Mul(v11, v21);
        auto r3 = Simd4::Mul(v12, v22);
        auto r5 = Simd4::Mul(v13, v23);
        auto r7 = Simd4::Mul(v14, v24);

        v22 = _mm_shuffle_ps(d1,         d3,    _MM_SHUFFLE(0, 0, 1, 0));
        v11 = _mm_shuffle_ps(t.v[1], t.v[1],    _MM_SHUFFLE(2, 1, 3, 2));
        v21 = _mm_shuffle_ps(d1,         v22,   _MM_SHUFFLE(2, 1, 0, 3));
        v12 = _mm_shuffle_ps(t.v[0], t.v[0],    _MM_SHUFFLE(1, 3, 2, 3));
        v22 = _mm_shuffle_ps(d1,         v22,   _MM_SHUFFLE(0, 2, 1, 2));

        v24 = _mm_shuffle_ps(d2,         d3,    _MM_SHUFFLE(2, 2, 1, 0));
        v13 = _mm_shuffle_ps(t.v[3], t.v[3],    _MM_SHUFFLE(2, 1, 3, 2));
        v23 = _mm_shuffle_ps(d2,         v24,   _MM_SHUFFLE(2, 1, 0, 3));
        v14 = _mm_shuffle_ps(t.v[2], t.v[2],    _MM_SHUFFLE(1, 3, 2, 3));
        v24 = _mm_shuffle_ps(d2,         v24,   _MM_SHUFFLE(0, 2, 1, 2));

        v11 = Simd4::Mul(v11, v21);
        v12 = Simd4::Mul(v12, v22);
        v13 = Simd4::Mul(v13, v23);
        v14 = Simd4::Mul(v14, v24);
        r1  = Simd4::Sub(r1,  v11);
        r3  = Simd4::Sub(r3,  v12);
        r5  = Simd4::Sub(r5,  v13);
        r7  = Simd4::Sub(r7,  v14);

        v11 = _mm_shuffle_ps(t.v[1], t.v[1],    _MM_SHUFFLE(0, 3, 0, 3));
        v21 = _mm_shuffle_ps(d1,         d3,    _MM_SHUFFLE(1, 0, 2, 2));
        v21 = _mm_shuffle_ps(v21,        v21,   _MM_SHUFFLE(0, 2, 3, 0));
        v12 = _mm_shuffle_ps(t.v[0], t.v[0],    _MM_SHUFFLE(2, 0, 3, 1));
        v22 = _mm_shuffle_ps(d1,         d3,    _MM_SHUFFLE(1, 0, 3, 0));
        v22 = _mm_shuffle_ps(v22,        v22,   _MM_SHUFFLE(2, 1, 0, 3));
        v13 = _mm_shuffle_ps(t.v[3], t.v[3],    _MM_SHUFFLE(0, 3, 0, 3));
        v23 = _mm_shuffle_ps(d2,         d3,    _MM_SHUFFLE(3, 2, 2, 2));
        v23 = _mm_shuffle_ps(v23,        v23,   _MM_SHUFFLE(0, 2, 3, 0));
        v14 = _mm_shuffle_ps(t.v[2], t.v[2],    _MM_SHUFFLE(2, 0, 3, 1));
        v24 = _mm_shuffle_ps(d2,         d3,    _MM_SHUFFLE(3, 2, 3, 0));
        v24 = _mm_shuffle_ps(v24,        v24,   _MM_SHUFFLE(2, 1, 0, 3));

        v11 = Simd4::Mul(v11, v21);
        v12 = Simd4::Mul(v12, v22);
        v13 = Simd4::Mul(v13, v23);
        v14 = Simd4::Mul(v14, v24);

        __m128 r2, r4, r6, r8;
        r2 = Simd4::Sub(r1, v11);
        r1 = Simd4::Add(r1, v11);
        r4 = Simd4::Add(r3, v12);
        r3 = Simd4::Sub(r3, v12);
        r6 = Simd4::Sub(r5, v13);
        r5 = Simd4::Add(r5, v13);
        r8 = Simd4::Add(r7, v14);
        r7 = Simd4::Sub(r7, v14);

        r1 = _mm_shuffle_ps(r1, r2, _MM_SHUFFLE(3, 1, 2, 0));
        r3 = _mm_shuffle_ps(r3, r4, _MM_SHUFFLE(3, 1, 2, 0));
        r5 = _mm_shuffle_ps(r5, r6, _MM_SHUFFLE(3, 1, 2, 0));
        r7 = _mm_shuffle_ps(r7, r8, _MM_SHUFFLE(3, 1, 2, 0));
        r1 = _mm_shuffle_ps(r1, r1, _MM_SHUFFLE(3, 1, 2, 0));
        r3 = _mm_shuffle_ps(r3, r3, _MM_SHUFFLE(3, 1, 2, 0));
        r5 = _mm_shuffle_ps(r5, r5, _MM_SHUFFLE(3, 1, 2, 0));
        r7 = _mm_shuffle_ps(r7, r7, _MM_SHUFFLE(3, 1, 2, 0));

        __m128 tmp;
        tmp = _mm_dp_ps(r1, t.v[0], 0xff);
        tmp = Simd4::Div(Simd4::One4, tmp);

        Matrix ret;
        ret.v[0] = Simd4::Mul(r1, tmp);
        ret.v[1] = Simd4::Mul(r3, tmp);
        ret.v[2] = Simd4::Mul(r5, tmp);
        ret.v[3] = Simd4::Mul(r7, tmp);
        return ret;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      転置行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Transpose ( const Matrix& value )
    {
        Float4 row[4];
        Simd4::Store(row[0], value.v[0]);
        Simd4::Store(row[1], value.v[1]);
        Simd4::Store(row[2], value.v[2]);
        Simd4::Store(row[3], value.v[3]);

        return Matrix(
            row[0].v[0], row[1].v[0], row[2].v[0], row[3].v[0],
            row[0].v[1], row[1].v[1], row[2].v[1], row[3].v[1],
            row[0].v[2], row[1].v[2], row[2].v[2], row[3].v[2],
            row[0].v[3], row[1].v[3], row[2].v[3], row[3].v[3]
        );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      単位行列を返却します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Identity()
    {
        return Matrix(
            Simd4::UnitX,
            Simd4::UnitY,
            Simd4::UnitZ,
            Simd4::UnitW);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      平行移動行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Translate( const f32 x, const f32 y, const f32 z )
    {
        return Matrix(
            Simd4::UnitX,
            Simd4::UnitY,
            Simd4::UnitZ,
            Simd4::Make(x, y, z, 1.0f));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      拡大縮小行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Scale( const f32 x, const f32 y, const f32 z )
    {
        return Matrix(
            Simd4::Make(x, 0.0f, 0.0f, 0.0f),
            Simd4::Make(0.0f, y, 0.0f, 0.0f),
            Simd4::Make(0.0f, 0.0f, z, 0.0f),
            Simd4::UnitW);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      X軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateX( const f32 rad )
    {
        auto cosRad = std::cos( rad );
        auto sinRad = std::sin( rad );
        return Matrix(
            1.0f,    0.0f,   0.0f, 0.0f,
            0.0f,  cosRad, sinRad, 0.0f,
            0.0f, -sinRad, cosRad, 0.0f,
            0.0f,    0.0f,   0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      Y軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateY( const f32 rad )
    {
        auto cosRad = std::cos( rad );
        auto sinRad = std::sin( rad );
        return Matrix(
            cosRad,  0.0f, -sinRad, 0.0f,
            0.0f,    1.0f,    0.0f, 0.0f,
            sinRad,  0.0f,  cosRad, 0.0f,
            0.0f,    0.0f,    0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      Z軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix RotateZ( const f32 rad )
    {
        auto cosRad = std::cos( rad );
        auto sinRad = std::sin( rad );
        return Matrix(
            cosRad, sinRad, 0.0f, 0.0f,
            sinRad, cosRad, 0.0f, 0.0f,
            0.0f,     0.0f, 1.0f, 0.0f,
            0.0f,     0.0f, 0.0f, 1.0f );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      任意軸周りの回転行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix Rotate( const f32 x, const f32 y, const f32 z, const f32 rad )
    {
        Matrix result;

        auto sinRad = sinf(rad);
        auto cosRad = cosf(rad);
        auto a = 1.0f -cosRad;
    
        auto ab = x * y * a;
        auto bc = y * z * a;
        auto ca = z * x * a;
        auto tx = x * x;
        auto ty = y * y;
        auto tz = z * z;

        result.v[0] = Simd4::Make(
            tx + cosRad * (1.0f - tx),
            ab + z * sinRad,
            ca - y * sinRad,
            0.0f
        );

        result.v[1] = Simd4::Make(
            ab - z * sinRad,
            ty + cosRad * (1.0f - ty),
            bc + x * sinRad,
            0.0f
        );

        result.v[2] = Simd4::Make(
            ca + y * sinRad,
            bc - x * sinRad,
            tz + cosRad * (1.0f - tz),
            0.0f
        );

        result.v[3] = Simd4::UnitW;

        return result;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      ビュー行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix LookAt( const Vector3& position, const Vector3& target, const Vector3& upward )
    {
        auto zaxis = Vector3::UnitVector( target - position );
        auto xaxis = Vector3::UnitVector( Vector3::Cross( upward, zaxis ) );
        auto yaxis = Vector3::UnitVector( Vector3::Cross( zaxis, xaxis ) );

        Float4 x, y, z;
        Simd4::Store(x, xaxis.v);
        Simd4::Store(y, yaxis.v);
        Simd4::Store(z, zaxis.v);

        return Matrix(
            x.v[0], y.v[0], z.v[0], 0.0f,
            x.v[1], y.v[1], z.v[1], 0.0f,
            x.v[2], y.v[2], z.v[2], 0.0f,
            -Vector3::Dot( xaxis, position ),
            -Vector3::Dot( yaxis, position ),
            -Vector3::Dot( zaxis, position ),
            1.0 );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      透視投影行列を求めます.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static Matrix PersFov( const f32 fieldOfView, const f32 aspectRatio, const f32 nearClip, const f32 farClip )
    {
        auto diff = farClip - nearClip;
        auto yScale = 1.0f / tanf( fieldOfView * 0.5f );
        auto xScale = yScale / aspectRatio;

        return Matrix(
            xScale, 0.0f, 0.0f, 0.0f,
            0.0f, yScale, 0.0f, 0.0f,
            0.0f, 0.0f, farClip / diff, -1.0f,
            0.0f, 0.0f, -(nearClip * farClip) / diff, 0.0f);
    }
};

//-------------------------------------------------------------------------------------------------
//      指定行列で変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector2 Vector2::Transform( const Vector2& position, const Matrix& matrix )
{ 
    auto v = Simd4::Trs2(Simd4::Make(position.x, position.y, 0.0f, 0.0f), matrix.v);
    return Vector2( Simd4::GetX(v), Simd4::GetY(v) );
}

//-------------------------------------------------------------------------------------------------
//      指定行列で変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector3 Vector3::Transform( const Vector3& position, const Matrix& matrix )
{ return Simd4::Trs3(position.v, matrix.v); }

//-------------------------------------------------------------------------------------------------
//      指定行列で法線ベクトルを変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector3 Vector3::TransformNormal( const Vector3& normal, const Matrix& matrix )
{ return Simd4::TrsN(normal.v, matrix.v); }

//-------------------------------------------------------------------------------------------------
//      指定行列で変換し，w = 1 に射影します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector3 Vector3::TransformCoord( const Vector3& coord, const Matrix& matrix )
{ return Simd4::TrsC(coord.v, matrix.v); }

//-------------------------------------------------------------------------------------------------
//      指定行列で変換します.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
Vector4 Vector4::Transform( const Vector4& position, const Matrix& matrix )
{ return Simd4::Trs4(position.v, matrix.v); }


///////////////////////////////////////////////////////////////////////////////////////////////////
// BoundingBox structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct BoundingBox
{
public:
    Vector3 mini;
    Vector3 maxi;
    Vector3 center;

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox()
    {
        mini   = Vector3( Simd4::Maxi );
        maxi   = Vector3( Simd4::Lowest );
        center = Vector3( Simd4::Zero );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const Vector3& value )
    {
        mini   = value.v;
        maxi   = value.v;
        center = Vector3( value.v );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const Vector3& _mini, const Vector3& _maxi )
    {
        mini   = _mini;
        maxi   = _maxi;
        center = (_mini + _maxi) * 0.5f;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox( const BoundingBox& value )
    : mini  ( value.mini )
    , maxi  ( value.maxi )
    , center( value.center )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool IsHit( const Ray& ray ) const
    {
        auto tmin = Simd4::Make( -F_HIT_MAX );
        auto tmax = Simd4::Make(  F_HIT_MAX );

        auto t0 = Simd4::Div( Simd4::Sub( mini.v, ray.pos.v ), ray.dir.v );
        auto t1 = Simd4::Div( Simd4::Sub( maxi.v, ray.pos.v ), ray.dir.v );

        auto n = Simd4::Min(t0, t1);
        auto f = Simd4::Max(t0, t1);

        tmin = Simd4::Max(tmin, n);
        tmax = Simd4::Min(tmax, f);

        auto mask = Simd4::Mask( Simd4::CmpGt( tmin, tmax ) );
        mask &= 0x7; // 4番目の要素はいらないので，XYZが格納されている下位3ビット分(0111 = 0x7)だけ取り出す.
        return ( mask == 0 );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      2つのバウンディングボックスをマージします.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Merge( const BoundingBox& a, const BoundingBox& b )
    { 
        return BoundingBox(
            Vector3::Min(a.mini, b.mini),
            Vector3::Max(a.maxi, b.maxi));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      バウンディングボックスと点をマージします.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Merge( const BoundingBox& box, const Vector3& p )
    {
        return BoundingBox(
            Vector3::Min(box.mini, p),
            Vector3::Max(box.maxi, p));
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      指定行列でボックスを変換します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    static BoundingBox Transform( const BoundingBox& lhs, const Matrix& rhs )
    {
        auto center = lhs.center;
        auto size = (lhs.maxi - lhs.mini).Length();

        const Vector3 offset[8] = {
            Vector3( -1.0f, -1.0f,  1.0f ),
            Vector3(  1.0f, -1.0f,  1.0f ),
            Vector3(  1.0f,  1.0f,  1.0f ),
            Vector3( -1.0f,  1.0f,  1.0f ),
            Vector3( -1.0f, -1.0f, -1.0f ),
            Vector3(  1.0f, -1.0f, -1.0f ),
            Vector3(  1.0f,  1.0f, -1.0f ),
            Vector3( -1.0f,  1.0f, -1.0f ),
        };

        auto extent = offset[0] * size;
        auto corner = Vector3::Transform( center + extent, rhs );
        auto mini   = corner;
        auto maxi   = corner;

        for(auto i=1; i<8; ++i)
        {
            extent = offset[i] * size;
            corner = Vector3::Transform( center + extent, rhs );

            mini = Vector3::Min(mini, corner);
            maxi = Vector3::Max(maxi, corner);
        }

        return BoundingBox(mini, maxi);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// BoundingBox4 structure
///////////////////////////////////////////////////////////////////////////////////////////////////
S3D_ALIGN(16)
struct BoundingBox4
{
public:
    b128 v[2][3];       // 最大・最小値です( 0:min, 1:max ).

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4()
    {
        v[0][0] = Simd4::Maxi;
        v[0][1] = Simd4::Maxi;
        v[0][2] = Simd4::Maxi;

        v[1][0] = Simd4::Lowest;
        v[1][1] = Simd4::Lowest;
        v[1][2] = Simd4::Lowest;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4
    (
        const BoundingBox& box0,
        const BoundingBox& box1,
        const BoundingBox& box2,
        const BoundingBox& box3
    )
    {
        Float4 s0, s1, s2, s3;
        Float4 b0, b1, b2, b3;

        Simd4::Store(s0, box0.mini.v);
        Simd4::Store(s1, box1.mini.v);
        Simd4::Store(s2, box2.mini.v);
        Simd4::Store(s3, box3.mini.v);

        Simd4::Store(b0, box0.maxi.v);
        Simd4::Store(b1, box1.maxi.v);
        Simd4::Store(b2, box2.maxi.v);
        Simd4::Store(b3, box3.maxi.v);

        v[0][0] = Simd4::Make( s0.v[0], s1.v[0], s2.v[0], s3.v[0] );
        v[0][1] = Simd4::Make( s0.v[1], s1.v[1], s2.v[1], s3.v[1] );
        v[0][2] = Simd4::Make( s0.v[2], s1.v[2], s2.v[2], s3.v[2] );

        v[1][0] = Simd4::Make( b0.v[0], b1.v[0], b2.v[0], b3.v[0] );
        v[1][1] = Simd4::Make( b0.v[1], b1.v[1], b2.v[1], b3.v[1] );
        v[1][2] = Simd4::Make( b0.v[2], b1.v[2], b2.v[2], b3.v[2] );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4( const BoundingBox* box )
    {
        Float4 s0, s1, s2, s3;
        Float4 b0, b1, b2, b3;

        Simd4::Store(s0, box[0].mini.v);
        Simd4::Store(s1, box[1].mini.v);
        Simd4::Store(s2, box[2].mini.v);
        Simd4::Store(s3, box[3].mini.v);

        Simd4::Store(b0, box[0].maxi.v);
        Simd4::Store(b1, box[1].maxi.v);
        Simd4::Store(b2, box[2].maxi.v);
        Simd4::Store(b3, box[3].maxi.v);

        v[0][0] = Simd4::Make( s0.v[0], s1.v[0], s2.v[0], s3.v[0] );
        v[0][1] = Simd4::Make( s0.v[1], s1.v[1], s2.v[1], s3.v[1] );
        v[0][2] = Simd4::Make( s0.v[2], s1.v[2], s2.v[2], s3.v[2] );

        v[1][0] = Simd4::Make( b0.v[0], b1.v[0], b2.v[0], b3.v[0] );
        v[1][1] = Simd4::Make( b0.v[1], b1.v[1], b2.v[1], b3.v[1] );
        v[1][2] = Simd4::Make( b0.v[2], b1.v[2], b2.v[2], b3.v[2] );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox4
    (
        const b128& miniX,
        const b128& miniY,
        const b128& miniZ,

        const b128& maxiX,
        const b128& maxiY,
        const b128& maxiZ
    )
    {
        v[0][0] = miniX;
        v[0][1] = miniY;
        v[0][2] = miniZ;

        v[1][0] = maxiX;
        v[1][1] = maxiY;
        v[1][2] = maxiZ;
    }

    //--------------------------------------------------------------------------------
    //! @brief      バウンディングボックスを取得します.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox GetBox() const
    {
        Float4 sx, sy, sz;
        Float4 bx, by, bz;
        Simd4::Store(sx, v[0][0]);  Simd4::Store(bx, v[1][0]);
        Simd4::Store(sy, v[0][1]);  Simd4::Store(by, v[1][1]);
        Simd4::Store(sz, v[0][2]);  Simd4::Store(bz, v[1][2]);

        Vector3 tmin( sx.v[0], sy.v[0], sz.v[0] );
        Vector3 tmax( bx.v[0], by.v[0], bz.v[0] );

        for( u32 i=1; i<3; ++i )
        {
            tmin = Vector3::Min( tmin, Vector3( sx.v[i], sy.v[i], sz.v[i] ) );
            tmax = Vector3::Max( tmax, Vector3( bx.v[i], bz.v[i], bz.v[i] ) );
        }

        return BoundingBox( tmin, tmax );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    bool IsHit( const Ray4& ray, s32& mask ) const
    {
        auto tmin = Simd4::Make( -F_HIT_MAX );
        auto tmax = Simd4::Make(  F_HIT_MAX );

        int flg = 0;

        for( auto i=0; i<3; ++i )
        {
            auto t0 = Simd4::Div( Simd4::Sub( v[0][i], ray.pos[i] ), ray.dir[i] );
            auto t1 = Simd4::Div( Simd4::Sub( v[1][i], ray.pos[i] ), ray.dir[i] );

            auto n = Simd4::Min(t0, t1);
            auto f = Simd4::Max(t0, t1);

            tmin = Simd4::Max(tmin, n);
            tmax = Simd4::Min(tmax, f);

            // 失敗している奴のビットフラグが立つ.
            flg |= Simd4::Mask( Simd4::CmpGt( tmin, tmax) );

            // 全ビットが立っていたら打ち切り.
            if (flg == 0xf)
            {
                mask = 0;
                return false;
            }
        }

        // ビット反転.
        mask = flg ^ 0xf;

        return (mask != 0);
    }
};

#if S3D_IS_AVX
/////////////////////////////////////////////////////////////////////////////////////
// BoundingBox8 structure
/////////////////////////////////////////////////////////////////////////////////////
S3D_ALIGN(32)
struct BoundingBox8
{
public:
    b256 v[2][3];       // 最大・最小値です( 0:min, 1:max ).

    //--------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //--------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8()
    {
        v[0][0] = Simd8::Maxi;
        v[0][1] = Simd8::Maxi;
        v[0][2] = Simd8::Maxi;

        v[1][0] = Simd8::Lowest;
        v[1][1] = Simd8::Lowest;
        v[1][2] = Simd8::Lowest;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //----------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8
    (
        const BoundingBox& box0,
        const BoundingBox& box1,
        const BoundingBox& box2,
        const BoundingBox& box3,
        const BoundingBox& box4,
        const BoundingBox& box5,
        const BoundingBox& box6,
        const BoundingBox& box7
    )
    {
        Float4 s0, s1, s2, s3, s4, s5, s6, s7;
        Float4 b0, b1, b2, b3, b4, b5, b6, b7;

        Simd4::Store(s0, box0.mini.v);   Simd4::Store(b0, box0.maxi.v);
        Simd4::Store(s1, box1.mini.v);   Simd4::Store(b1, box1.maxi.v);
        Simd4::Store(s2, box2.mini.v);   Simd4::Store(b2, box2.maxi.v);
        Simd4::Store(s3, box3.mini.v);   Simd4::Store(b3, box3.maxi.v);
        Simd4::Store(s4, box4.mini.v);   Simd4::Store(b4, box4.maxi.v);
        Simd4::Store(s5, box5.mini.v);   Simd4::Store(b5, box5.maxi.v);
        Simd4::Store(s6, box6.mini.v);   Simd4::Store(b6, box6.maxi.v);
        Simd4::Store(s7, box7.mini.v);   Simd4::Store(b7, box7.maxi.v);

        v[0][0] = Simd8::Make(s0.v[0], s1.v[0], s2.v[0], s3.v[0], s3.v[0], s4.v[0], s5.v[0], s6.v[0], s7.v[0]);
        v[0][1] = Simd8::Make(s0.v[1], s1.v[1], s2.v[1], s3.v[1], s3.v[1], s4.v[1], s5.v[1], s6.v[1], s7.v[1]);
        v[0][2] = Simd8::Make(s0.v[2], s1.v[2], s2.v[2], s3.v[2], s3.v[2], s4.v[2], s5.v[2], s6.v[2], s7.v[2]);

        v[1][0] = Simd8::Make(b0.v[0], b1.v[0], b2.v[0], b3.v[0], b3.v[0], b4.v[0], b5.v[0], b6.v[0], b7.v[0]);
        v[1][1] = Simd8::Make(b0.v[1], b1.v[1], b2.v[1], b3.v[1], b3.v[1], b4.v[1], b5.v[1], b6.v[1], b7.v[1]);
        v[1][2] = Simd8::Make(b0.v[2], b1.v[2], b2.v[2], b3.v[2], b3.v[2], b4.v[2], b5.v[2], b6.v[2], b7.v[2]);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8( const BoundingBox* box )
    {
        Float4 b0, b1, b2, b3, b4, b5, b6, b7;

        Simd4::Store(s0, box[0].mini.v);   Simd4::Store(b0, box[0].maxi.v);
        Simd4::Store(s1, box[1].mini.v);   Simd4::Store(b1, box[1].maxi.v);
        Simd4::Store(s2, box[2].mini.v);   Simd4::Store(b2, box[2].maxi.v);
        Simd4::Store(s3, box[3].mini.v);   Simd4::Store(b3, box[3].maxi.v);
        Simd4::Store(s4, box[4].mini.v);   Simd4::Store(b4, box[4].maxi.v);
        Simd4::Store(s5, box[5].mini.v);   Simd4::Store(b5, box[5].maxi.v);
        Simd4::Store(s6, box[6].mini.v);   Simd4::Store(b6, box[6].maxi.v);
        Simd4::Store(s7, box[7].mini.v);   Simd4::Store(b7, box[7].maxi.v);

        v[0][0] = Simd8::Make(s0.v[0], s1.v[0], s2.v[0], s3.v[0], s3.v[0], s4.v[0], s5.v[0], s6.v[0], s7.v[0]);
        v[0][1] = Simd8::Make(s0.v[1], s1.v[1], s2.v[1], s3.v[1], s3.v[1], s4.v[1], s5.v[1], s6.v[1], s7.v[1]);
        v[0][2] = Simd8::Make(s0.v[2], s1.v[2], s2.v[2], s3.v[2], s3.v[2], s4.v[2], s5.v[2], s6.v[2], s7.v[2]);

        v[1][0] = Simd8::Make(b0.v[0], b1.v[0], b2.v[0], b3.v[0], b3.v[0], b4.v[0], b5.v[0], b6.v[0], b7.v[0]);
        v[1][1] = Simd8::Make(b0.v[1], b1.v[1], b2.v[1], b3.v[1], b3.v[1], b4.v[1], b5.v[1], b6.v[1], b7.v[1]);
        v[1][2] = Simd8::Make(b0.v[2], b1.v[2], b2.v[2], b3.v[2], b3.v[2], b4.v[2], b5.v[2], b6.v[2], b7.v[2]);
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox8
    (
        const b256& miniX,
        const b256& miniY,
        const b256& miniZ,

        const b256& maxiX,
        const b256& maxiY,
        const b256& maxiZ
    )
    {
        v[0][0] = miniX;
        v[0][1] = miniY;
        v[0][2] = miniZ;

        v[1][0] = maxiX;
        v[1][1] = maxiY;
        v[1][2] = maxiZ;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      バウンディングボックスを取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    BoundingBox GetBox() const
    {
        Float8 sx, sy, sz;
        Float8 bx, by, bz;
        Simd8::Store(sx, v[0][0]);  Simd8::Store(bx, v[1][0]);
        Simd8::Store(sy, v[0][1]);  Simd8::Store(by, v[1][1]);
        Simd8::Store(sz, v[0][2]);  Simd8::Store(bz, v[1][2]);

        Vector3 tmin( sx.v[0], sy.v[0], sz.v[0] );
        Vector3 tmax( bx.v[0], by.v[0], bz.v[0] );

        for( u32 i=1; i<8; ++i )
        {
            tmin = Vector3::Min( tmin, Vector3( sx.v[i], sy.v[i], sz.v[i] ) );
            tmax = Vector3::Max( tmax, Vector3( bx.v[i], by.v[i], bz.v[i] ) );
        }

        return BoundingBox( tmin, tmax );
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      交差判定を行います.
    //---------------------------------------------------------------------------------------------
    bool IsHit( const Ray8& ray, s32& mask ) const
    {
        auto tmin = Simd8::Make( -F_HIT_MAX );
        auto tmax = Simd8::Make(  F_HIT_MAX );

        int flg = 0;

        for( auto i=0; i<3; ++i )
        {
            auto t0 = Simd8::Div( Simd8::Sub( v[0][i], ray.pos[i] ), ray.dir[i] );
            auto t1 = Simd8::Div( Simd8::Sub( v[1][i], ray.pos[i] ), ray.dir[i] );

            auto n = Simd8::Min(t0, t1);
            auto f = Simd8::Max(t0, t1);

            tmin = Simd8::Max(tmin, n);
            tmax = Simd8::Min(tmax, f);

            // 失敗している奴のビットフラグが立つ.
            flg |= Simd8::Mask( Simd8::CmpGt( tmin, tmax) );

            // 全ビットが立っていたら打ち切り.
            if (flg == 0xff)
            {
                mask = 0;
                return false;
            }
        }

        // ビット反転.
        mask = flg ^ 0xff;

        return (mask != 0);
    }
};
#endif//S3D_IS_AVX

///////////////////////////////////////////////////////////////////////////////////////////////////
// Random class
///////////////////////////////////////////////////////////////////////////////////////////////////
class Random
{
    //=============================================================================================
    // list of friend classes and methods.
    //=============================================================================================
    /* NOTHING */

public:
    //=============================================================================================
    // public variables.
    //=============================================================================================
    /* NOTHING */

    //=============================================================================================
    // public methods.
    //=============================================================================================

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random()
    { SetSeed( 123456789 ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random( const u32 seed ) 
    { SetSeed( seed ); }

    //---------------------------------------------------------------------------------------------
    //! @brief      コピーコンストラクタです.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random( const Random& value )
    : m_X( value.m_X )
    , m_Y( value.m_Y )
    , m_Z( value.m_Z )
    , m_W( value.m_W )
    { /* DO_NOTHING */ }

    //---------------------------------------------------------------------------------------------
    //! @brief      乱数種を設定します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    void SetSeed( const u32 seed )
    {
        // 超越数設定.
        m_X = 123456789;
        m_Y = 362436069;
        m_Z = 521288629;
        m_W = ( seed <= 0 ) ? 88675123 : seed;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      u32型として乱数を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    u32 GetAsU32()
    {
        u32 t = m_X ^ ( m_X << 11 );
        m_X   = m_Y;
        m_Y   = m_Z;
        m_Z   = m_W;
        m_W   = ( m_W ^ ( m_W >> 19 ) ) ^ ( t ^ ( t >> 8 ) );
        return m_W;
    }

    //---------------------------------------------------------------------------------------------
    //! @brief      f64型として乱数を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f64 GetAsF64()
    { return static_cast<f64>( GetAsU32() ) / 0xffffffffui32; }

    //---------------------------------------------------------------------------------------------
    //! @brief      f32型として乱数を取得します.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    f32 GetAsF32()
    { return static_cast<f32>( GetAsU32() ) / 0xffffffffui32; }

    //---------------------------------------------------------------------------------------------
    //! @brief      代入演算子です.
    //---------------------------------------------------------------------------------------------
    S3D_INLINE
    Random& operator = ( const Random& value )
    {
        m_X = value.m_X;
        m_Y = value.m_Y;
        m_Z = value.m_Z;
        m_W = value.m_W;
        return (*this);
    }

protected:
    //=============================================================================================
    // protected variables.
    //=============================================================================================
    /* NOTHING */

    //=============================================================================================
    // protected methods.
    //=============================================================================================
    /* NOTHING */

private:
    //=============================================================================================
    // private variables.
    //=============================================================================================
    u32 m_X;
    u32 m_Y;
    u32 m_Z;
    u32 m_W;

    //=============================================================================================
    // private methods.
    //=============================================================================================
    /* NOTHING */
};


///////////////////////////////////////////////////////////////////////////////////////////////////
// OrthonormalBasis structure
///////////////////////////////////////////////////////////////////////////////////////////////////
struct OrthonormalBasis
{
public:
    Vector3 u;
    Vector3 v;
    Vector3 w;

    //---------------------------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //---------------------------------------------------------------------------------------------
    OrthonormalBasis();

    //---------------------------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //---------------------------------------------------------------------------------------------
    OrthonormalBasis( const Vector3&, const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      U方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromU( const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      V方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromV( const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      W方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromW( const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      UV方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromUV( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      VU方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromVU( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      UW方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromUW( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      WU方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromWU( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      VW方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromVW( const Vector3&, const Vector3& );

    //---------------------------------------------------------------------------------------------
    //! @brief      WV方向から初期化します.
    //---------------------------------------------------------------------------------------------
    void InitFromWV( const Vector3&, const Vector3& );
};


//-------------------------------------------------------------------------------------------------
//! @brief      三角形の表面積を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const Vector3& a, const Vector3& b, const Vector3& c )
{
    auto x = b - a;
    auto y = c - a;
    auto z = Vector3::Cross( x, y );
    return 0.5f * z.Length();
}

//-------------------------------------------------------------------------------------------------
//! @brief      バウンディングボックスの表面積を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const BoundingBox& box )
{
    Float4 t;
    auto v = Simd4::Abs( Simd4::Sub( box.maxi.v, box.mini.v ) );
    Simd4::Store( t, v );
    return 2.0f * ( t.v[0] * t.v[1] + t.v[0] * t.v[2] + t.v[1] * t.v[2] );
}

//-------------------------------------------------------------------------------------------------
//! @brief      バウンディングスフィアの表面積を求めます.
//-------------------------------------------------------------------------------------------------
S3D_INLINE
f32 SurfaceArea( const f32 radius )
{
    return 4.0f * F_PI * ( radius * radius );
}

} // namespace s3d

