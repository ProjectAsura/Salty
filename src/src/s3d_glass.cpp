//-------------------------------------------------------------------------------------------------
// File : s3d_glass.cpp
// Desc : Glass Material.
// Copyright(c) Project Asura. All right reserved.
//-------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------
// Includes
//-------------------------------------------------------------------------------------------------
#include <s3d_glass.h>


namespace s3d {

///////////////////////////////////////////////////////////////////////////////////////////////////
// Glass class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      コンストラクタです.
//-------------------------------------------------------------------------------------------------
Glass::Glass(const Color4& specular, f32 ior, const Color4& emissive)
: m_Count   (1)
, m_Specular(specular)
, m_Ior     (ior)
, m_Emissive(emissive)
{ /* DO_NOTHING */ }

//-------------------------------------------------------------------------------------------------
//      デストラクタです.
//-------------------------------------------------------------------------------------------------
Glass::~Glass()
{ /* DO_NOTHING */}

//-------------------------------------------------------------------------------------------------
//      参照カウントを増やします.
//-------------------------------------------------------------------------------------------------
void Glass::AddRef()
{ m_Count++; }

//-------------------------------------------------------------------------------------------------
//      解放処理を行います.
//-------------------------------------------------------------------------------------------------
void Glass::Release()
{
    m_Count--;
    if ( m_Count == 0 )
    { delete this; }
}

//-------------------------------------------------------------------------------------------------
//      参照カウントを取得します.
//-------------------------------------------------------------------------------------------------
u32 Glass::GetCount() const
{ return m_Count; }

//-------------------------------------------------------------------------------------------------
//      シェーディングします.
//-------------------------------------------------------------------------------------------------
Color4 Glass::Shade( ShadingArg& arg ) const
{
    // 補正済み法線データ (レイの入出を考慮済み).
    const Vector3 normalMod = ( Vector3::Dot ( arg.normal, arg.input ) < 0.0 ) ? arg.normal : -arg.normal;

    // 反射ベクトルを求める.
    Vector3 reflect = Vector3::Reflect( arg.input, arg.normal );
    reflect.Normalize();

    // レイがオブジェクトから出るのか? 入るのか?
    const bool into = ( Vector3::Dot( arg.normal, normalMod ) > 0.0 );

    arg.dice = false;

    // ===============
    // Snellの法則
    // ===============

    // 真空の屈折率
    const f32 nc    = 1.0f;

    // オブジェクトの屈折率
    const f32 nt    = m_Ior;

    const f32 nnt   = ( into ) ? ( nc / nt ) : ( nt / nc );
    const f32 ddn   = Vector3::Dot( arg.input, normalMod );
    const f32 cos2t = 1.0f - nnt * nnt * (1.0f - ddn * ddn);

    // 全反射
    if ( cos2t < 0.0f )
    {
        // 出射方向.
        arg.output = reflect;
        return m_Specular;
    }

    // 屈折ベクトル.
    Vector3 refract = Vector3::UnitVector(
        arg.input * nnt - arg.normal * ( ( into ) ? 1.0f : -1.0f ) * ( ddn * nnt + SafeSqrt(cos2t) ) );

    // SchlickによるFresnelの反射係数の近似を使う
    const f32 a = nt - nc;
    const f32 b = nt + nc;
    const f32 R0 = (a * a) / (b * b);

    const f32 c = 1.0f - ( ( into ) ? -ddn : Vector3::Dot( refract, arg.normal ) );
    auto c2 = c * c;
    const f32 Re = R0 + (1.0f - R0) * ( c2 * c2 * c ); // 反射方向の光が反射してray.dirの方向に運ぶ割合。同時に屈折方向の光が反射する方向に運ぶ割合。
    const f32 Tr = ( 1.0f - Re );

    // 一定以上レイを追跡したら屈折と反射のどちらか一方を追跡する
    // ロシアンルーレットで決定する。
    const f32 P = 0.25f + 0.5f * Re;      // フレネルのグラフを参照.
    auto prob = 0.5f;

    // 反射の場合.
    if ( arg.random.GetAsF32() < P )
    {
        // 出射方向.
        arg.output = reflect;
        return m_Specular * Re / ( P * prob );
    }
    // 屈折の場合.
    else
    {
        // 出射方向.
        arg.output = refract;
        return m_Specular * Tr / ( ( 1.0f - P ) * prob );
    }
}

//-------------------------------------------------------------------------------------------------
//      エミッシブカラーを取得します.
//-------------------------------------------------------------------------------------------------
Color4 Glass::GetEmissive() const
{ return m_Emissive; }

//-------------------------------------------------------------------------------------------------
//      デルタ関数を持つかどうか?
//-------------------------------------------------------------------------------------------------
bool Glass::HasDelta() const
{ return true; }

//-------------------------------------------------------------------------------------------------
//      生成処理.
//-------------------------------------------------------------------------------------------------
IMaterial* Glass::Create(const Color4& specular, f32 ior)
{ return Glass::Create(specular, ior, Color4(0.0f, 0.0f, 0.0f, 1.0f)); }

//-------------------------------------------------------------------------------------------------
//      生成処理.
//-------------------------------------------------------------------------------------------------
IMaterial* Glass::Create(const Color4& specular, f32 ior, const Color4& emissive)
{ return new(std::nothrow) Glass(specular, ior, emissive); }

} // namespace s3d
